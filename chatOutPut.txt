nick = turtle' time = 22 18:12:18 test 
nick = turtle' time = 22 18:12:18 test 
nick = sectoid time = 22 18:19:48 есть тест 
nick = sectoid time = 22 18:19:52 всем привет 
nick = turtle' time = 22 18:19:54 Вижу. 
nick = turtle' time = 22 18:21:0 Ждём остальных. 
nick = grepz time = 22 18:29:7 Привет 
nick = turtle' time = 22 18:29:15 Привет. ) 
nick = swizard time = 22 18:40:30 привет 
nick = swizard time = 22 18:40:33 во отлично 
nick = turtle' time = 22 18:40:53 Все в сборе. :) 
nick = turtle' time = 22 18:41:11 В общем, осталось меньше 3 суток до старта. 
nick = grepz time = 22 18:41:37 o/ 
nick = turtle' time = 22 18:42:12 Я планирую сразу по началу приступить к чтению задания. Как опубликуют. 
nick = swizard time = 22 18:44:3 я смогу часам к 17 ориентировочно в пятницу подтянуться 
nick = grepz time = 22 18:46:27 Я сразу как будет задание смогу начать. 
nick = turtle' time = 22 18:47:37 Судя по всему, авторы заядлые хаскелисты. 
nick = sectoid time = 22 18:47:49 я буду сразу 
nick = sectoid time = 22 18:48:4 собсно клиентов предупредил, что с пт по вт меня нет) 
nick = turtle' time = 22 18:48:22 И задачу  нужно ожидать, как мы с swizard'ом прикинули, ближе к лямбда калкулюсу и т.д. 
nick = turtle' time = 22 18:48:38 Никто, кстати, ничего дополнительно не знает? 
nick = sectoid time = 22 18:49:10 нету. может где и есть намеки, но не на оффсайте 
nick = turtle' time = 22 18:52:15 В некоторых исфпц по лого намётки были. 
nick = turtle' time = 22 18:52:24 Тут вообще глушак. :) 
nick = grepz time = 22 18:55:6 Да, если исходить из того, что хаскеллисты в оргах и называются Well-Typed consultants, то может и да, какие нибудь типы Хиндли-Милнера и прочее с этим связанное. :) 
nick = sectoid time = 22 18:55:53 можно будет освежить в памяти 
nick = sectoid time = 22 18:56:1 а какие часовые пояса у остальных? 
nick = grepz time = 22 18:56:49 +5 к мск(+9 к utc) 
nick = turtle' time = 22 18:57:17 В целом, все в одном, кроме сектоида. :) 
nick = turtle' time = 22 18:57:26 Но он сказал, что у него сон смещённый. :) 
nick = grepz time = 22 18:58:35 Оно может и к лучшему, всегда будет кто-нибудь выспавшийся и со свежим взглядом. 
nick = turtle' time = 22 18:58:56 Да, так неплохо было бы. 
nick = sectoid time = 22 19:28:43 как раз хорошо 
nick = turtle' time = 25 11:14:48 Ну. Меньше 5 часов осталось до старта. 
nick = swizard time = 25 12:49:17 хм, на сайте 0 Day 03 Hour 10 Min 40 Sec 
nick = swizard time = 25 12:49:31 получается, в 16:00 по Москве старт, а не в 15 
nick = swizard time = 25 12:51:4 «don’t forget to buy plenty of fruit!« — подсказка какая-нибудь, наверно  
nick = swizard time = 25 13:6:33 если что, нагуглился некий хаскельный фреймворк Fruit: Functional Reactive User Interface Toolkit 
nick = sectoid time = 25 13:57:43 тогда будет совсем весело 
nick = sectoid time = 25 13:57:57 [11:49:31] &lt;swizard&gt; получается, в 16:00 по Москве старт, а не в 15<br /><br />ну собственно да. москва же +4. 
nick = sectoid time = 25 13:58:52 у меня первый мелкий облом: я к началу контеста буду у клиента в офисе, и часа 3 голосом обсуждать задание не смогу. а вот где-то в 15-16 по UTC - смогу и войс 
nick = swizard time = 25 13:59:35 sectoid, а ты умеешь в эти все стрелки, трансформеры и тд? :) а то мне что-то тревожно 
nick = sectoid time = 25 14:1:21 swizard: ни разу не пробовал, но очень много наслушался о них от друга-хаскеллиста. прорвемся. 
nick = swizard time = 25 14:2:42 окай, поглядим 
nick = turtle' time = 25 14:11:37 Действительно 16:00. Я тупанул что-то. :) 
nick = turtle' time = 25 14:13:43 Да, FRP это один из последних модных трендов, можно было бы и догадаться. 
nick = turtle' time = 25 14:14:33 http://www.cliki.net/cells 
nick = turtle' time = 25 14:14:44 Может, в деталях будет не то. 
nick = swizard time = 25 14:19:40 есть подозрение, что там будет какая-то задача, не связанная с UI, но использующая все эти идеи сигналов / сигнал трансформеров  
nick = turtle' time = 25 14:20:36 Может, и не UI, а просто FRP. 
nick = sectoid time = 25 14:20:43 скорее просто frp 
nick = turtle' time = 25 14:20:46 С UI сложновато организовать конкурс. 
nick = sectoid time = 25 14:21:2 кстати, не забудьте: ограничений на платформу/язык никаких нет 
nick = sectoid time = 25 14:21:16 что наталкивает на мысль о токенах 
nick = sectoid time = 25 14:21:24 скорборде и прочим 
nick = sectoid time = 25 14:21:50 гадать осталось 1.5 часа всего) 
nick = turtle' time = 25 14:23:10 Я думаю, как обычно, будет публиковаться промежуточный результат, который будет запускаться у них на серваке. И да, скорборд следует ожидать, наверное. 
nick = grepz time = 25 14:31:36 Functional Reactive Programming (FRP) integrates time flow and compositional events into functional programming. This provides an elegant way to express computation in domains such as interactive animations, robotics, computer vision, user interfaces, and simulation. <br />А что, вполне, под этот FRP много интересных задач придумать можно. 
nick = turtle' time = 25 14:36:30 В общем, в эксельке всё сделаем. :) 
nick = grepz time = 25 14:36:43 :) 
nick = sectoid time = 25 14:38:2 jtootf будет кусать локти, что забил на контест) 
nick = turtle' time = 25 14:38:17 Это кто? 
nick = swizard time = 25 14:38:47 http://jtootf.livejournal.com 
nick = swizard time = 25 14:39:18 а чего он забил на контест, кстати? 
nick = turtle' time = 25 14:39:41 А он собирался что ли? 
nick = grepz time = 25 14:39:58 Могу только предположить что им сейчас не до того, с учётом всего происходящего на Донбасе. 
nick = swizard time = 25 14:40:19 а он разве не из Киева? 
nick = grepz time = 25 14:40:38 Он сам в Киеве, у него родственники из Донбасаю 
nick = turtle' time = 25 14:40:50 Ясно. Не до конкурсов. 
nick = swizard time = 25 14:40:58 а, ну тогда понятно 
nick = turtle' time = 25 14:47:49 Мне кажется, будут роботы. 
nick = turtle' time = 25 14:48:16 Как-то читал, реактивное программирование для управления роботами. 
nick = turtle' time = 25 14:48:33 Даже на русском что-то было. Товарищ где-то из этих мест плюс-минус. 
nick = grepz time = 25 14:48:52 Слишком уж много роботов, уже раза 3 управление какими-то вундер-вафлями было. Скорее что-то из application, вроде computer vision. 
nick = turtle' time = 25 14:49:19 Ну, computer vision это тоже, в конечном счёте, роботы. :) 
nick = turtle' time = 25 14:49:32 Ну было 3 раза управление вундервафлями, почему бы 4 раз не сделать? 
nick = swizard time = 25 14:49:46 да погодите пока, ещё же не факт, что вообще будет frp :) 
nick = grepz time = 25 14:50:2 :) Поглядим через час. 
nick = turtle' time = 25 14:50:2 Надо ознакомиться, тем не менее. :) 
nick = turtle' time = 25 14:50:11 Даже если не понадобится. :) 
nick = turtle' time = 25 14:50:30 Давайте организационные вопросы решим. 
nick = turtle' time = 25 14:50:37 Голосом то будем что-нибудь обсуждать? 
nick = turtle' time = 25 14:50:46 Или кнопки топтать будем? 
nick = swizard time = 25 14:51:41 идеологически мне кнопки больше нравятся — от них остаётся лог, с которым могут ознакомится остальные, (отсутствовавшие например) члены команды  
nick = turtle' time = 25 14:51:45 В коммон лиспе есть что-нибудь, что делает delay? 
nick = swizard time = 25 14:51:52 но если что, мой скайп swizard0 
nick = turtle' time = 25 14:51:55 Мне кнопки тоже больше нравятся. 
nick = grepz time = 25 14:52:4 я тоже за кнопки 
nick = swizard time = 25 14:52:37 «В коммон лиспе есть что-нибудь, что делает delay?» — sleep же 
nick = turtle' time = 25 14:52:45 Не, не такой delay. 
nick = turtle' time = 25 14:52:50 Как в clojure. 
nick = turtle' time = 25 14:53:4 http://clojuredocs.org/clojure_core/1.2.0/clojure.core/delay 
nick = turtle' time = 25 14:53:10 Мой скайп turtle_bazon 
nick = turtle' time = 25 14:53:14 На всякий, так сказать. 
nick = swizard time = 25 14:53:49 а, типа замыкание с мемоизацией результата вызова? штатно вроде нет, но макросом делается за минуту 
nick = turtle' time = 25 14:54:21 Блин, не совсем. Мемоизация есть библиотекой. 
nick = turtle' time = 25 14:54:31 1. Мемоизация 
nick = turtle' time = 25 14:54:39 2. Блокирование потока до появления результата. 
nick = swizard time = 25 14:55:51 ну казалось бы, оборачиваешь в замыкание две переменные — результат и мьютекс :) 
nick = swizard time = 25 14:56:10 и за макросом всё это прячешь 
nick = turtle' time = 25 14:56:25 Ну можно не хардкорно мьютексами, просто condition-wait и condition-notify 
nick = turtle' time = 25 14:56:38 Да, делается недолго, интересовало есть ли готовое. 
nick = turtle' time = 25 14:57:2 Если городить frp, то удобно было бы через эту хрень забубенить, наверное. 
nick = turtle' time = 25 14:57:9 Хотя, если считать изменения результата. 
nick = turtle' time = 25 14:57:12 Да, тут думать надо. 
nick = swizard time = 25 14:57:39 имхо готовое нецелесообразно вносить в стандартную библиотеку в том плане, потому что вычисления в cl не чистые, поэтому нахаляву их мемоизировать нельзя 
nick = swizard time = 25 14:58:14 а в кложуре, насколько я знаю, там есть разделение в этих местах на чистые/нечистые 
nick = swizard time = 25 14:58:29 хотя могу ошибаться 
nick = turtle' time = 25 14:58:42 Ну... Сильно такого разделения нет. Во всяком случае, компилятор у тебя не контролирует. 
nick = turtle' time = 25 14:58:49 Хотя, в целом, по идеологии, там всё чистое. 
nick = turtle' time = 25 14:58:52 Как в хаскеле. :) 
nick = turtle' time = 25 14:59:10 И есть мутирующие переменные я-ля STM. Хотя, STM и есть. 
nick = turtle' time = 25 15:3:36 С оргами на ирке кто будет висеть? 
nick = grepz time = 25 15:4:21 Не долго законнектится если понадобится, всё равно аннаунсы/багфиксы они будут на сайт выкладывать. 
nick = turtle' time = 25 15:7:0 http://bodil.org/hipster/m/lambda-man.jpg 
nick = turtle' time = 25 15:7:11 Чувака знаете? В твиттере орги ссыль кинули. 
nick = grepz time = 25 15:9:42 Professor Philip Wadler 
nick = turtle' time = 25 15:9:54 Что-то знакомое. 
nick = turtle' time = 25 15:10:19 Чот тормознул, надо было в гугле картинку поискать. :) 
nick = grepz time = 25 15:11:9 Орги активно пропагандируют свою кухню, я так понимаю крупный тип в их комунити. 
nick = turtle' time = 25 15:12:25 Да, весомая фигура. 
nick = grepz time = 25 15:22:34 А на битбакете можно как-то ключ добавить, чтобы пароль каждый раз не вводить? 
nick = turtle' time = 25 15:24:19 Можно. 
nick = grepz time = 25 15:24:37 Отдельно для репы icfp? 
nick = turtle' time = 25 15:25:15 Вот это точно не скажу. Но репу icfpc когда я создавал, у меня уже был привязан ключ. И в репу меня с ключом пустило. 
nick = grepz time = 25 15:25:53 Я сейчас добавил ключ, но icfp всё равно пароль требует, ну и ладно, не страшно. 
nick = turtle' time = 25 15:26:7 В твиттере мессага, что 3072 секунды осталось. 
nick = turtle' time = 25 15:26:33 Что за число - хз. 
nick = turtle' time = 25 15:27:49 https://bitbucket.org/account/user/turtle_bazon/ssh-keys/ 
nick = turtle' time = 25 15:27:53 Тут добавлял ключи? 
nick = grepz time = 25 15:28:11 Да, конечно, для своего акка 
nick = grepz time = 25 15:28:34 Думаю дело в том, что icfp твоя репа, потому тебя туда пускает по умолчанию, а с меня пароль требует. 
nick = turtle' time = 25 15:28:47 swizard, вроде, тоже с ключом. 
nick = turtle' time = 25 15:28:56 Это не совсем моя репа, это репа команды. 
nick = turtle' time = 25 15:28:58 team. 
nick = grepz time = 25 15:29:19 Хмм, сейчас ещё поковыряю, пока время есть. 
nick = turtle' time = 25 15:29:46 Можешь мне скопировать, я попробую добавить в SSH keys в тиме. 
nick = grepz time = 25 15:30:20 скинул в окне чата 
nick = swizard time = 25 15:30:53 мне с ключом разрешают писать в репу 
nick = turtle' time = 25 15:31:27 Попробуй перезабери репу. 
nick = grepz time = 25 15:31:39 one moment 
nick = grepz time = 25 15:32:39 Во 
nick = grepz time = 25 15:32:49 Пересоздал репу на локальном диске, всё ок теперь 
nick = turtle' time = 25 15:32:54 Ну отлично тогда. 
nick = turtle' time = 25 15:33:6 Надо бы им этот глюк записать куда-нибудь. :) 
nick = turtle' time = 25 15:33:29 Есть мысли по поводу 3072? 
nick = grepz time = 25 15:33:54 Это случайно выбранный момент времени мне кажется. :) 
nick = turtle' time = 25 15:34:24 https://github.com/icfpcontest2014/icfpcontest2014.github.io 
nick = turtle' time = 25 15:34:26 Не знаю. 
nick = turtle' time = 25 15:42:7 Пнгшку первую, которая bk.png уровнями обработал, там рисунок проглядывается. 
nick = turtle' time = 25 15:42:11 Вряд ли случайный. 
nick = grepz time = 25 15:43:32 что-то конкретное? 
nick = turtle' time = 25 15:44:22 Ничего конкретного. :) 
nick = turtle' time = 25 15:44:55 http://imgur.com/b9krthc 
nick = turtle' time = 25 15:44:59 Хрень какая-то. :) 
nick = swizard time = 25 15:45:12 если к этой картинке чёрные квадраты по углам добавить, не получится ли в результате qr-код? :) 
nick = turtle' time = 25 15:45:28 ХЗ. :) 
nick = turtle' time = 25 15:45:35 Надо попробовать. 
nick = turtle' time = 25 15:45:55 Мне пока не на чём. :) 
nick = turtle' time = 25 15:47:7 Кто-нибудь просканируйте. 
nick = turtle' time = 25 15:47:52 На втором - кошка гитхабовская. 
nick = sectoid time = 25 15:48:30 я доехаль 
nick = sectoid time = 25 15:48:40 что за png'шка? 
nick = grepz time = 25 15:49:4 За 10-15 минут не успею, там надо код версии добавлять + код маски и уровня коррекции, хз какие они там должны быть 
nick = turtle' time = 25 15:50:17 https://github.com/icfpcontest2014/icfpcontest2014.github.io 
nick = turtle' time = 25 15:50:19 Отсюда. 
nick = sectoid time = 25 15:51:13 угу, уже листаю 
nick = grepz time = 25 15:55:54 меньше 5 минут 
nick = turtle' time = 25 15:57:33 Не успел почитать про FRP для роботов. :) 
nick = sectoid time = 25 15:57:54 успеешь еще) 
nick = sectoid time = 25 15:58:7 из их свиттера:<br />%    =     \...o..... 
nick = turtle' time = 25 15:58:9 За три дня то? :) 
nick = turtle' time = 25 15:58:15 Да, я не понял. 
nick = sectoid time = 25 15:58:20 интересно, это что-то значит или нет?) 
nick = turtle' time = 25 15:58:29 Думаю, значит. 
nick = grepz time = 25 15:58:57 Эти хаскеллисты хуже поэтов символистов, чесс слово 
nick = turtle' time = 25 15:59:12 3072 это же круглое число. 
nick = turtle' time = 25 15:59:18 0xC00 
nick = turtle' time = 25 15:59:36 На низком старте. :) 
nick = grepz time = 25 15:59:51 или 2 единички в старших разрядах в двоичной 
nick = swizard time = 25 16:0:18 обратный таймер покраснел 
nick = turtle' time = 25 16:0:29 На странице ничего не поменялось. 
nick = grepz time = 25 16:0:29 в минус ушёл :) 
nick = grepz time = 25 16:0:50 есть 
nick = sectoid time = 25 16:0:53 поехали! 
nick = sectoid time = 25 16:1:1 лямбда-мэн 
nick = sectoid time = 25 16:1:4 ояебу 
nick = turtle' time = 25 16:1:44 Эх, сразу видна ленивость хаскеля. :) 
nick = swizard time = 25 16:2:1 похоже как мы в 2012 лямбды в пещерах собирали 
nick = turtle' time = 25 16:2:8 Я ещё не читал. 
nick = turtle' time = 25 16:2:22 О, микроконтроллер. 
nick = turtle' time = 25 16:3:53 Дуэли. 
nick = sectoid time = 25 16:5:33 /me ушел в чтение 
nick = turtle' time = 25 16:6:8 Да, пока читаем. 
nick = turtle' time = 25 16:8:31 ЭТо же этот, как его блин. 
nick = turtle' time = 25 16:8:35 Вспомнил, пакман. 
nick = grepz time = 25 16:8:40 угу 
nick = grepz time = 25 16:8:50 только с AI для пакмана 
nick = turtle' time = 25 16:9:28 А вот и понятно что за твит обозначал. :) 
nick = turtle' time = 25 16:11:35 Да, похоже на пещерки. 
nick = turtle' time = 25 16:11:44 И, похоже, тоже придётся имплементить a* 
nick = swizard time = 25 16:12:17 мы его уже имплементили, у меня код сохранился :) 
nick = turtle' time = 25 16:13:5 У меня тоже. Но он, вроде, глючил. :) 
nick = grepz time = 25 16:15:35 Получается идеальная стратегия, сожрать все пилюли, как можно больше привидений, фруктов и закончить уровень, чтобы получить множитель. pathfinding much? 
nick = turtle' time = 25 16:17:22 Надо бы ещё к фруктам подойти к моменту появления. Планирование. 
nick = swizard time = 25 16:17:23 да, там ещё в заданное количество тиков надо уложиться 
nick = turtle' time = 25 16:18:0 По истечению тиков жизн уменьшается? 
nick = turtle' time = 25 16:25:32 GHost CPU (GHC) 
nick = turtle' time = 25 16:25:36 Позабавило. :) 
nick = grepz time = 25 16:25:43 Так, получается ещё интерпретатор псевдо ассемблера + CPU emulator 
nick = swizard time = 25 16:25:46 лол, чтоб получить карту, надо реверс-инжинирить дамп памяти микроконтроллера 
nick = swizard time = 25 16:25:57 не просто интерпретатор :) 
nick = turtle' time = 25 16:26:12 Я ещё не дочитал до туда. 
nick = grepz time = 25 16:26:13 ну да 
nick = sectoid time = 25 16:35:37 пакман это, да 
nick = turtle' time = 25 16:36:19 Навороченный какой-то пакман. Пока не дочитал куда эти программы совать и т.д. 
nick = sectoid time = 25 16:36:27 спека большая 
nick = sectoid time = 25 16:36:30 я еще читаю 
nick = sectoid time = 25 16:36:32 но пока нравится 
nick = sectoid time = 25 16:36:51 не особо нравится только что опять ботов писать( но CPU и реверс-часть очень нравится 
nick = turtle' time = 25 16:36:55 Ну относительно несложная и относительно масштабная. 
nick = swizard time = 25 16:37:13 походу там про ботов процентов 10 сложности всей задачи 
nick = grepz time = 25 16:37:19 Она алгоритмически вроде несложная, а вот объём большой получается 
nick = swizard time = 25 16:37:32 вы ещё до реверс-инжиниринга лисп-машины по ассемблеру не дочитали, наверно :) 
nick = turtle' time = 25 16:37:47 Я ещё нет. :) 
nick = turtle' time = 25 16:37:59 Но что-то уже такое началось. 
nick = swizard time = 25 16:38:45 блин я пока не представляю как люди собираются соло участвовать в этом icfpc 
nick = swizard time = 25 16:38:53 там работы реально на неделю 
nick = grepz time = 25 16:38:57 угу 
nick = turtle' time = 25 16:39:0 В этом да. 
nick = turtle' time = 25 16:44:2 Я уже читать устал. :) 
nick = grepz time = 25 16:44:18 The environment is more complex than the two stack structures. Rather than a contiguous stack, it consists of a chain of environment frames. :/ 
nick = sectoid time = 25 16:44:41 ыыыы 
nick = turtle' time = 25 16:51:48 Придётся компилятор что ли писать? 
nick = turtle' time = 25 16:52:7 Дочитал. Голова вспухла слегонца. :) 
nick = grepz time = 25 16:53:9 У меня пока местами каша, перечитываю мутные моменты 
nick = turtle' time = 25 16:53:33 Что-то я там скорборда не увидел. 
nick = turtle' time = 25 16:53:35 И проверки. 
nick = turtle' time = 25 16:53:43 Т.е. придётся почти вслепую, если правильно понял. 
nick = swizard time = 25 16:55:12 From this it follows that each invocation of the AI before a move was allowed to run up to 3072 * 10^3 instructions. 
nick = swizard time = 25 16:55:17 вот оно и 3072 
nick = turtle' time = 25 16:56:17 Да. 
nick = turtle' time = 25 16:56:48 http://icfpcontest.org/reference.html 
nick = turtle' time = 25 16:56:52 А вот, заработало. 
nick = turtle' time = 25 16:57:12 Ну хоть не в слепую. :) 
nick = swizard time = 25 17:0:57 давайте попробуем подытожить, что нам удалось понять из задания, хотя бы в самом общем 
nick = grepz time = 25 17:1:10 Касательно AI, я так понял что это функция(шаг стейт машины), которой приходит состояние мира, он высчитывает из этого новое состояние, возвращает и так по кругу? 
nick = turtle' time = 25 17:1:39 Что я понял, надо нам засабмитить программу для лямбдамена. 
nick = swizard time = 25 17:1:51 правильно ли я понял, что пока (lightning round) решением является листинг кода для лисп-машины (GCC), который управляет пакманом? 
nick = swizard time = 25 17:2:1 а для гоустов писать программки пока не надо? 
nick = turtle' time = 25 17:2:19 Да я вот не понимаю, для готов вообще нужно будет? 
nick = swizard time = 25 17:2:19 grepz: да, я это тоже дак понял 
nick = turtle' time = 25 17:2:28 аааа. 
nick = turtle' time = 25 17:2:41 Ну да. Лайтнинг от нелайтнинга отличается только тем, что дуэли не будет. 
nick = turtle' time = 25 17:2:48 Соответственно да. 
nick = turtle' time = 25 17:2:55 Ещё раз почитаю. 
nick = turtle' time = 25 17:3:12 For the lightning round it is your Lambda-Man versus ghosts supplied by the judges and in mazes supplied by the judges. 
nick = turtle' time = 25 17:3:19 Собственно. 
nick = grepz time = 25 17:3:22 госты будут предоставлены судьями, а наша реализация должна касаться только l-man'а 
nick = swizard time = 25 17:3:49 итого, ghc сегодня можно вообще не трогать, правильно? 
nick = swizard time = 25 17:3:54 только gcc? 
nick = grepz time = 25 17:3:55 получается так 
nick = grepz time = 25 17:4:47 Надо теперь как-то gcc на задачи побить. 
nick = swizard time = 25 17:5:10 следовательно, дотстаточно будет написать АИ на обычном лиспе, транслятор в промежуточный лисп (по спеке), и компилятор промежуточного лиспа в асм gcc? 
nick = turtle' time = 25 17:5:43 Про фулл раунд ещё толком ничего не сказано, говорят, опубликуют позже. А пока да, получается, нужно только gcc. 
nick = turtle' time = 25 17:6:8 Ну типа того, в целом, да. 
nick = turtle' time = 25 17:7:20 Нам бы ещё надо спеку сделать для промежуточного лиспа. :) 
nick = swizard time = 25 17:8:40 ну вот как-то так: All program data structures have to be represented using combinations of pairs and integers (and sometimes closures). 
nick = turtle' time = 25 17:10:49 Я так понял, GC они как-то сами реализуют? Нам трогать его не надо? 
nick = turtle' time = 25 17:13:24 А что, память для них общая? Только регистры указывают на участки разных стеков? 
nick = grepz time = 25 17:14:20 насколько я понял инструкции определяют с какой памятью работать 
nick = grepz time = 25 17:15:8 Three of the registers point into special data structures in memory:<br /><br />    Data stack<br />    Control stack<br />    Environment frame chain<br /><br />The remainder of the memory is dedicated to the data heap. 
nick = turtle' time = 25 17:15:14 Так общая или нет? Похоже, общая. 
nick = turtle' time = 25 17:15:21 А участки стека как-то лимитированы? 
nick = grepz time = 25 17:16:14 да, получается адреса логически разделены, про лимиты ищу 
nick = grepz time = 25 17:18:51 про RAM вижу ограничение: 10 million CONS cells to be used by the Lambda-Man AI in the heap. 
nick = sectoid time = 25 17:19:38 какие вы шустрые.  
nick = turtle' time = 25 17:20:11 Так то heap. 
nick = swizard time = 25 17:21:5 ща я минут через 5 закоммичу intermediate-desc.lisp, где попробую подытожить всё, что я понял про спеку встроенного лиспа 
nick = sectoid time = 25 17:22:59 predefined ghost'ов тоже кудысь закоммитить бы 
nick = turtle' time = 25 17:23:49 А предефинед гхосты уже есть? 
nick = sectoid time = 25 17:24:2 есть примеры из доки 
nick = turtle' time = 25 17:24:12 А, ну понятно. 
nick = sectoid time = 25 17:24:20 miner.ghc, flipper.ghc, fickle.ghc 
nick = sectoid time = 25 17:24:34 я еще вкуриваю лиспоспеку 
nick = turtle' time = 25 17:24:47 Да, спека та ещё. 
nick = sectoid time = 25 17:25:2 turtle': а чего тебя 2 ? :) 
nick = turtle' time = 25 17:25:26 Один неактивный же. :) 
nick = turtle' time = 25 17:26:47 А, тегами он проверяет, чтобы нельзя было сложить бананы с обезьянами. 
nick = turtle' time = 25 17:26:53 Точнее, консы с интами. 
nick = turtle' time = 25 17:31:4 Инты 64 битные. 
nick = turtle' time = 25 17:31:12 32. 
nick = turtle' time = 25 17:31:15 Извиняюсь. 
nick = turtle' time = 25 17:31:17 4-байтные. 
nick = turtle' time = 25 17:31:22 Т.е. 32битные. 
nick = turtle' time = 25 17:31:32 + там теговые биты, но нам на это пофиг. 
nick = turtle' time = 25 17:32:11 Причём 32 бита это не только на положительные, но и на отрицательные. 
nick = sectoid time = 25 17:32:51 теговые биты входят в эти 32 или нет? 
nick = turtle' time = 25 17:33:6 Нет. 
nick = turtle' time = 25 17:33:20 Конкретно мы про эти теговые биты вообщ не знаем. 
nick = turtle' time = 25 17:33:24 Как пользователи. 
nick = turtle' time = 25 17:33:40 Т.е. на самом деле они более 32 битов, но оперировать мы можем 32-битными числами. 
nick = sectoid time = 25 17:34:35 ага, нашел уже) 
nick = swizard time = 25 17:37:42 пытаюсь спеку запротоколировать на лисп: https://bitbucket.org/skobochka/icfpc-2014/src/7960b1f1bd9af74ca26290b82865d82ec4bb5ad2/internal-lisp-desc.lisp?at=master 
nick = grepz time = 25 17:37:54 Правильно ли я понимаю, что если мы сделаем LDC 10, LDC 20, у нас в дата стэке будет одно за другим два значения: 20, 10. И если потом сделаем CONS, то мы создадим cons ячейку (20 . 10) и передадим указатель на эту ячейку в data stack reg? 
nick = sectoid time = 25 17:39:18 если передадим == push, то да, именно так 
nick = turtle' time = 25 17:40:3 Зачем пуш? CONS уже пропушит. 
nick = turtle' time = 25 17:40:10 http://icfpcontest.org/lman.html 
nick = sectoid time = 25 17:40:50 ну я об этом и говорю 
nick = turtle' time = 25 17:41:15 А, ну ладно. 
nick = sectoid time = 25 17:43:11 conditional call (sel) -- это прекрасно 
nick = turtle' time = 25 17:43:14 swizard: ну как-то так, наверное, начинается. 
nick = grepz time = 25 17:45:34 lambdaman-vitality это числовое значение, 0 - нет fright mode, N - столько то тиков осталось? 
nick = swizard time = 25 17:46:9 да 
nick = swizard time = 25 17:46:34 тиков power-pill 
nick = grepz time = 25 17:46:39 ага 
nick = swizard time = 25 17:48:1 так, но это я типы там перечислил, теперь надо понять, какой там синтаксис разрешён 
nick = swizard time = 25 17:48:18 я понял пока только про целые числа, cons, и lambda для замыканий 
nick = turtle' time = 25 17:48:27 Ну да. 
nick = swizard time = 25 17:48:33 нужен, как минимум ведь, if 
nick = turtle' time = 25 17:48:37 Вроде больше ничего нет. 
nick = turtle' time = 25 17:48:46 Для ифов инструкции есть. 
nick = turtle' time = 25 17:48:53 conditional branch. 
nick = grepz time = 25 17:48:58 да, исполнение инструкциями 
nick = swizard time = 25 17:49:37 просто я хочу зафиксировать синтаксис intermediate lisp, чтобы можно было из него начать компилятор в gcc ваять 
nick = sectoid time = 25 17:50:26 иф есть, он sel зовется. только как я понял работает как call 
nick = grepz time = 25 17:51:52 отойду на 5 мин 
nick = sectoid time = 25 17:52:0 а, трушный if зовется TSEL 
nick = swizard time = 25 17:52:10 это типа инструкции уже  
nick = swizard time = 25 17:52:49 я просто хочу определиться с ast на sexp, чтобы можно было компилятор через какой-нибудь паттерн-матчинг (cl-match) транслировать в асм 
nick = swizard time = 25 17:53:33 можно на самом деле ввести команды list и tuple, чтобы не морочится с консами 
nick = turtle' time = 25 17:53:51 Можно, да. 
nick = turtle' time = 25 17:53:58 Консы как-то геморно выглядят. 
nick = swizard time = 25 17:54:7 типа (tuple ghost-vitality location direction) вместо (cons ghost-vitality (cons location (cons direction 0))) 
nick = turtle' time = 25 17:54:23 Ага. 
nick = turtle' time = 25 17:54:30 Идиоматичнее, наверное, list. :) 
nick = turtle' time = 25 17:54:36 Но это неважно. 
nick = swizard time = 25 17:54:55 а там есть list уже, как (cons … (cons … (cons … 0 ))) 
nick = swizard time = 25 17:55:8 типа tuple, с последним элементом 0 
nick = swizard time = 25 17:55:31 ими карта кодируется, кстати 
nick = turtle' time = 25 17:55:44 Что-т не заметил. Но логично, да. 
nick = swizard time = 25 17:56:34 хотя не знаю, может, и не нужно, лучше напрямую консы использовать, это же промежуточный лисп — из него надо будет как асм порождать, так и обратно считывать (в стейтах, например) 
nick = turtle' time = 25 17:57:7 В принципе, можно пока без изысков. 
nick = turtle' time = 25 17:57:13 А удобства потом добавить. 
nick = turtle' time = 25 18:1:50 А что, карта только ботам доступна? 
nick = swizard time = 25 18:2:15 нет, она в world-state есть 
nick = grepz time = 25 18:3:2 Давайте может зафиксируем что и в каком виде мы должны заимплементить на lightning round 
nick = turtle' time = 25 18:4:17 А этим стейтом кто его инициализирует? 
nick = turtle' time = 25 18:5:12 Вижу. 
nick = swizard time = 25 18:5:29 давайте зафиксируем 
nick = swizard time = 25 18:6:8 есть минимальные вещи, без которых решение бессмысленно: это intermediate lisp и его компилятор в gcc 
nick = swizard time = 25 18:6:31 AI тут даже сам по себе не так нужен, можно простейшую логику какую-то написать сразу на intermediate lisp 
nick = swizard time = 25 18:6:43 чтобы хоть как-то работало в lightning round 
nick = turtle' time = 25 18:6:59 Ну, логику можно и руками написать. 
nick = turtle' time = 25 18:7:8 Тут смысл, думаю, как раз в интермедиейт лиспе. 
nick = swizard time = 25 18:7:16 ага, я это и имел в виду 
nick = turtle' time = 25 18:7:17 Чтобы можно было перепробовать несколько вариантов. 
nick = sectoid time = 25 18:8:37 все, довкуривал наконец( 
nick = swizard time = 25 18:8:47 следовательно, 1. нам нужно придумать синтаксис intermediate lisp,  
nick = swizard time = 25 18:9:1 2. спрограммировать простейший транслятор 
nick = sectoid time = 25 18:9:17 3. спрограммировать простейший AI 
nick = swizard time = 25 18:9:44 боюсь, что все фишки gcc мы заимплементить не успеем (вроде tail call extension), но хоть что-то можно изобразить 
nick = sectoid time = 25 18:9:58 если разделится, то может и успеем 
nick = sectoid time = 25 18:10:27 я готов поиграться с транслятором. подозреваю что там все не так просто (оптимизации будут решать) 
nick = swizard time = 25 18:10:59 окей, давайте тогда сейчас прикинем черновой вариант синтаксиса, вроде это должно быть быстро 
nick = swizard time = 25 18:11:3 предлагаю начать с конца :) 
nick = swizard time = 25 18:11:24 в разделе examples есть local.gcc и goto.gcc 
nick = sectoid time = 25 18:11:29 ага 
nick = swizard time = 25 18:11:40 давайте прикинем, как должна выглядеть программа на intermediate lisp для них 
nick = grepz time = 25 18:12:35 константы это только int? 
nick = swizard time = 25 18:12:39 вроде да 
nick = sectoid time = 25 18:12:45 да, только int 
nick = sectoid time = 25 18:12:56 собсно тут вообще ничего кроме cons, int и closure не бывает 
nick = swizard time = 25 18:13:8 по-моему, программа должна быть что-то вроде: (let ((x 21)) (+ x x)) 
nick = sectoid time = 25 18:13:12 свиз, ты хочешь писать AI сразу на intermediate lisp? 
nick = swizard time = 25 18:13:30 поначалу да, что-нибудь совсем простое 
nick = turtle' time = 25 18:13:31 Ну давайте прикидывать как будет выглядеть интерлисп. 
nick = sectoid time = 25 18:13:36 никаму не кажется что минимальный scheme как раз оно? 
nick = sectoid time = 25 18:13:39 никому* 
nick = turtle' time = 25 18:13:50 Нам надо ещё минимальнее, наверное. :) 
nick = sectoid time = 25 18:14:7 let, lambda, if, call? 
nick = sectoid time = 25 18:14:8 что еще? 
nick = sectoid time = 25 18:14:16 арифметика 
nick = swizard time = 25 18:14:25 вот я и предлагаю прикинуть, по екзамплам 
nick = sectoid time = 25 18:14:26 cons, car/cdr 
nick = swizard time = 25 18:14:42 проверьте, плз, правильно ли я понял, что local.gcc — это (let ((x 21)) (+ x x)) 
nick = turtle' time = 25 18:14:44 Арифметика нужна будет с вмещение до 32 бит. 
nick = sectoid time = 25 18:15:6 я пойду выкурю сигарету и придумаю лисп-аналоги для примеров 
nick = grepz time = 25 18:17:21 да, вроде всё так судя по спекам 
nick = swizard time = 25 18:18:22 не совсем походу, метка body откуда-то должна взяться 
nick = grepz time = 25 18:18:27 правда может проще (define x 21) (define (func x) (+ x x))   
nick = turtle' time = 25 18:18:35 Ну по симулятору совпадает. 
nick = turtle' time = 25 18:18:44 Метка это просто метка. 
nick = grepz time = 25 18:18:47 собственно потом (call func x) или что-то в этом роде 
nick = turtle' time = 25 18:18:56 Туда у нас (+ x x) - это и есть body. 
nick = grepz time = 25 18:19:6 сложнее транслировать имхо 
nick = grepz time = 25 18:19:18 когда явно указываешь будет проще 
nick = swizard time = 25 18:19:53 тогда вообще ((define (body x)<br />     (+ x x))<br /> 21) 
nick = turtle' time = 25 18:20:12 Ну если смотреть с позиции стековой машины. 
nick = turtle' time = 25 18:20:16 Как бы да. 
nick = swizard time = 25 18:20:16 давайте сюда сразу тогда https://bitbucket.org/skobochka/icfpc-2014/src/7659ff72facc179a514971b3dfc5c3f656e39a71/gcc/examples/?at=master 
nick = grepz time = 25 18:20:20 вот, что-то в этом роде как-раз 
nick = turtle' time = 25 18:21:2 ИМХО, первый вариант был удачнее. 
nick = turtle' time = 25 18:21:17 Получается, после летов мы делаем енвайронмент и далее продолжаем. 
nick = swizard time = 25 18:21:32 let — это синтаксический сахар для lambda :) 
nick = turtle' time = 25 18:21:33 Т.е. леты - это LDC, потом LDF на внутрь. 
nick = turtle' time = 25 18:21:46 Ну так то да. 
nick = turtle' time = 25 18:21:52 Можно и так, конечно. 
nick = swizard time = 25 18:21:57 потом можно будет макросом навернуть 
nick = grepz time = 25 18:22:0 угу 
nick = swizard time = 25 18:22:1 если нужно будет 
nick = turtle' time = 25 18:22:3 Т.е. так и есть. 
nick = swizard time = 25 18:22:46 давайте goto.lisp напишем? 
nick = grepz time = 25 18:23:28 dum это же local scope фактически? 
nick = sectoid time = 25 18:23:45 define == lambda? 
nick = sectoid time = 25 18:23:54 а, он именованый 
nick = sectoid time = 25 18:23:55 ыыы 
nick = swizard time = 25 18:24:4 dum — похоже 
nick = swizard time = 25 18:24:19 бтв, turtle, а у тебя на сервере лог конфы сохраняется? 
nick = swizard time = 25 18:24:27 похоже, ichat лог обрезает :( 
nick = sectoid time = 25 18:24:51 у меня есть лог с<br /><br />[14:31:39] &lt;grepz&gt; one moment 
nick = turtle' time = 25 18:25:4 Не уверен. Точнее, не знаю что он там делает. 
nick = turtle' time = 25 18:25:11 НО у меня на компе сохраняется. 
nick = swizard time = 25 18:25:27 понятно, ладно, попозже тогда в psi переползу 
nick = grepz time = 25 18:25:51 так, а RAP как транслировать, есть идеи? 
nick = sectoid time = 25 18:26:38 могу лог сбросить в реп если надо 
nick = sectoid time = 25 18:26:46 у меня непонятки с AP - call function<br /> 
nick = swizard time = 25 18:27:18 если я правильно понял, rap загружает в стек адреса глобальных функций для перехода 
nick = swizard time = 25 18:27:21 или нет? 
nick = turtle' time = 25 18:27:29 AP просто берёт адрес и вызывает, сдампив с датастека в енвайронмент. 
nick = sectoid time = 25 18:28:10 turtle': а что там означает вот этот пункт:<br />set the frame's parent to be the environment frame pointer<br />            from the CLOSURE cell;<br /> 
nick = sectoid time = 25 18:28:38 я забыл английский, или он намекает что в CLOSURE cell есть environment frame pointer? 
nick = turtle' time = 25 18:28:46 Ну да. 
nick = turtle' time = 25 18:29:7 В local.gcc, собственно, перед AP делается LDF. 
nick = sectoid time = 25 18:29:12 угу 
nick = sectoid time = 25 18:29:14 /me пошел перечитывать спеку 
nick = turtle' time = 25 18:29:21 LDF создаёт клозуру с адресом и текущим енвайронментом. 
nick = sectoid time = 25 18:29:30 все, понял 
nick = grepz time = 25 18:30:19 аа, то есть RAP зацикливает вызов в части cell'а? 
nick = swizard time = 25 18:30:47 goto.lisp — https://bitbucket.org/skobochka/icfpc-2014/src/bb2cdb8d87511175ec7dfc0df68d2fc90e292326/gcc/examples/goto.lisp?at=master как-то так? 
nick = turtle' time = 25 18:32:43 Вроде похоже. 
nick = grepz time = 25 18:34:25 а как понять что здесь нужно делать dum? 
nick = swizard time = 25 18:34:54 видимо, по тому, что здесь 2 top-level функции 
nick = grepz time = 25 18:35:33 ага, начинает доходить 
nick = sectoid time = 25 18:35:39   DUM  2        ; 2 top-level declarations<br /> 
nick = sectoid time = 25 18:35:43 там так и написано 
nick = sectoid time = 25 18:36:9 логично в принципе 
nick = swizard time = 25 18:36:20 но вообще вопрос правильный, видимо, лучше тогда так делать: https://bitbucket.org/skobochka/icfpc-2014/src/af9167d7f4fdc12c372c86b3cbaf1b2d842d08ae/gcc/examples/goto.lisp?at=master 
nick = grepz time = 25 18:36:47 ага-ага 
nick = swizard time = 25 18:36:52 только main нужно вызвать 
nick = grepz time = 25 18:37:15 таким образом в первом примере мы скоуп не создаём, во втором создаём 
nick = swizard time = 25 18:38:13 мне кажется, нужно всегда создавать scope 
nick = swizard time = 25 18:38:20 чтобы код унифицировать 
nick = grepz time = 25 18:38:44 можно разворачивать наверх, но ты прав, это усложнит 
nick = grepz time = 25 18:39:12 правда тогда первый пример 1 к 1 не транслируется в gcc 
nick = turtle' time = 25 18:39:30 Почему? 
nick = swizard time = 25 18:39:40 потому что scope создаётся 
nick = turtle' time = 25 18:39:44 Вроде бы же как раз создаётся отдельный скоуп. 
nick = turtle' time = 25 18:39:50 Так надо же создавать. 
nick = grepz time = 25 18:40:3 в их примере создания нету 
nick = turtle' time = 25 18:40:17 А LDF? 
nick = swizard time = 25 18:40:35 я думаю, top-level scope можно будет отдельным проходом убирать просто 
nick = turtle' time = 25 18:40:37 Хотя, как рассматривать, да. 
nick = grepz time = 25 18:40:38 это просто дефайн функции 
nick = sectoid time = 25 18:40:49 это просто уже оптимизации 
nick = grepz time = 25 18:40:51 да, пожалуй 
nick = turtle' time = 25 18:40:52 Ну в LDF скоуп текущий идёт. 
nick = turtle' time = 25 18:40:58 Да, наверное, не создаётся. 
nick = grepz time = 25 18:41:20 ну вобщем да, топлевел просто режется 
nick = sectoid time = 25 18:42:2 сча, там где-то было про требования пустого скопа 
nick = sectoid time = 25 18:42:3 момент 
nick = swizard time = 25 18:42:9 итого, правильно ли я понял, что мы решили: 1. всегда делаем корень из define; 2. все внутренние define считаются и оборачиваются в dum/rap; 3. и так рекурсивно 
nick = grepz time = 25 18:42:23 получается так 
nick = sectoid time = 25 18:42:28 во 
nick = sectoid time = 25 18:42:31 у RAP'а 
nick = sectoid time = 25 18:42:39 Synopsis: pop a pointer to a CLOSURE cell off the data stack;<br />          the current environment frame pointer must point to an empty<br />            frame of size $n;<br /> 
nick = swizard time = 25 18:43:1 а этот empty frame разве не через dum создаётся? 
nick = sectoid time = 25 18:43:24 как раз через него. просто пояснение почему его нет в 1 примере  
nick = grepz time = 25 18:43:25 он как раз через dum и должен быть реализован 
nick = swizard time = 25 18:43:59 в 1 примере, насколько мы поняли, там top-level scope просто режется 
nick = swizard time = 25 18:44:4 за ненадобностью 
nick = turtle' time = 25 18:44:15 Получается, так. 
nick = turtle' time = 25 18:44:22 Если создадим, ничего страшного не будет. 
nick = turtle' time = 25 18:44:31 Хотя, это опять смотреть надо. :) 
nick = turtle' time = 25 18:44:42 Может, насоздаёт он там их, что не влезем в какие-то рамки. 
nick = turtle' time = 25 18:44:59 Пока предлагаю оптимизациями не заниматься. 
nick = swizard time = 25 18:45:31 давайте я пока в icfpc-2014/gcc попробую создать рыбу для компилятора 
nick = swizard time = 25 18:45:39 если нет возражений 
nick = grepz time = 25 18:45:57 Просто для себя ещё кое-что уложить по полочкам, как орги проверять будут предоставленные решения? Я эту часть как-то пропустил. :) 
nick = swizard time = 25 18:46:23 если я правильно понял, орги будут запускать код в имеющемся у них эмуляторе 
nick = sectoid time = 25 18:46:30 может я слоупок, но пока не вкуриваю отличия RAP от AP.  
nick = sectoid time = 25 18:46:39 возражений пока нет 
nick = swizard time = 25 18:46:45 rap — это recursive ap :) 
nick = grepz time = 25 18:47:0 rap просто опять на стек адрес вызова пихает как я понимаю 
nick = swizard time = 25 18:47:12 ну типа flet и labels  
nick = grepz time = 25 18:47:15 вобщем да, вроде пока логично получается 
nick = sectoid time = 25 18:47:49 swizard: я видел название. в семантику вникаю 
nick = sectoid time = 25 18:48:21 аааааааа 
nick = sectoid time = 25 18:48:24 все, вкурил))) 
nick = grepz time = 25 18:48:58 Меня сейчас больше беспокоит TRAP - recursive environment tail-call function 
nick = grepz time = 25 18:49:5 но мы пока можем на него и забить 
nick = sectoid time = 25 18:49:59 дык там все просто 
nick = sectoid time = 25 18:50:10 такой себе goto с общим стартовым скопом 
nick = sectoid time = 25 18:50:27 собсно все tail call extensions - возможность делать эффективные циклы 
nick = sectoid time = 25 18:51:24 интересно, почему Pascal extensions таки Pascal? потому, что империативное деструктивное присваивание? 
nick = turtle' time = 25 18:52:58 ТАк, я пока передислоцируюсь. 
nick = sectoid time = 25 18:55:36 спеку обновили 
nick = swizard time = 25 18:56:12 хуже стало :) 
nick = sectoid time = 25 18:56:21 еще не видел diff 
nick = grepz time = 25 18:56:40 ахха: https://github.com/icfpcontest2014/icfpcontest2014.github.io/commits/source 
nick = sectoid time = 25 18:57:22 Clarify that there may be up to 256 ghosts (maximum).<br /> 
nick = sectoid time = 25 18:57:23 jvu 
nick = sectoid time = 25 18:57:25 omg 
nick = sectoid time = 25 19:1:11 я, наверное, передислоцируюсь домой. и ворвусь дальше 
nick = grepz time = 25 19:1:22 я пока почитаю про cl-match 
nick = swizard time = 25 19:1:53 dl-match походу не нужен, мы только s-выражения матчим, имхо достаточно if-match из набора metatilities 
nick = grepz time = 25 19:2:4 ок 
nick = swizard time = 25 19:2:50 наверно, вот как-то так можно будет попробовать: Задача про ip-диапазоны: cуперкомпиляция условий &lt;http://swizard.livejournal.com/177506.html&gt; 
nick = grepz time = 25 19:4:17 читаю 
nick = swizard time = 25 19:4:48 если что, я не настаиваю на этом методе, просто первое, что пришло в голову 
nick = sectoid time = 25 19:5:8 полистаю на базе у себя 
nick = sectoid time = 25 19:5:46 ребят, как вы думаете: а зачем нам расписали подноготную микроконтроллеров управляющих гостами? 
nick = swizard time = 25 19:6:13 думаю, что после lightning round нам нужно будет писать АИ для них :) 
nick = sectoid time = 25 19:6:29 т.е. добавят инструкцию для прошивания мозгов и гостам?) 
nick = grepz time = 25 19:6:34 да, я думаю они следующие на очереди 
nick = sectoid time = 25 19:6:47 будет весело 
nick = sectoid time = 25 19:7:0 все, я покатился. надеюсь не убьюсь на радостях) 
nick = grepz time = 25 19:7:7 :) 
nick = swizard time = 25 19:7:9 аккуратней =) 
nick = sectoid time = 25 19:7:24 пятница, пробки( надеюсь стида не закипит 
nick = grepz time = 25 19:9:45 вкуриваю, логично подход выглядит 
nick = swizard time = 25 19:31:26 а посмотрите плз https://bitbucket.org/skobochka/icfpc-2014/src/a6fbfc2f1d1a68ef79eb949fc8499e01d154b0e9/gcc/compiler.lisp?at=master 
nick = swizard time = 25 19:31:45 это скелет пока, идея там такая:  
nick = swizard time = 25 19:32:3 GCC&gt; (translate '(define (body x) 1))<br />((:LABEL BODY) ((:LDC 1)) (:RTN))<br /> 
nick = grepz time = 25 19:32:46 смотрю 
nick = swizard time = 25 19:33:37 там со стейтами надо переделать, конечно, он нужен рекурсивный для определения AP/RAP 
nick = swizard time = 25 19:33:52 ну в любом случае это пока набросок 
nick = grepz time = 25 19:42:59 идея вроде понятна, тут ещё cons нужен, тогда можно будет формы раскрывать 
nick = swizard time = 25 19:43:22 да, правильно 
nick = swizard time = 25 19:43:52 я пока щас пытаюсь изобразить environment, чтобы правильно генерировать LD 
nick = grepz time = 25 19:45:16 ок, я пока освоюсь, попробую поэксперементировать со спекой 
nick = swizard time = 25 19:45:47 а я правильно понимаю, что «LD 0 0» загружает первую переменную из текущего списка биндингов функции, а «LD 1 0» — из биндингов уровня выше? 
nick = sectoid time = 25 19:46:21 да 
nick = sectoid time = 25 19:46:36 похоже параметры передаются через environment 
nick = grepz time = 25 19:46:42 ага 
nick = sectoid time = 25 19:46:56 еще интересный момент: у нас есть еще один undocumented параметр AI'шке 
nick = sectoid time = 25 19:47:12 он там явно не просто так 
nick = swizard time = 25 19:47:23 ок, тогда если мы встречаем атом X, и это не интежер, то мы смотрим в локальный фрейм, если он там есть, то LD 0 0, а если нет, смотрим выше, и тд 
nick = swizard time = 25 19:47:50 ща попробую что-нибудь придумать в этом месте 
nick = sectoid time = 25 19:56:7 label - как я понял нам надо самим будет расчитывать смещения? 
nick = swizard time = 25 19:59:36 наверно да 
nick = sectoid time = 25 19:59:51 судя по спеке - да 
nick = swizard time = 25 20:0:21 я там попробовал имплементировать environment и сложение, получается как-то так: 
nick = swizard time = 25 20:0:38 GCC&gt; (translate '(define (body x) (+ x 1)))<br />((:LABEL BODY) (:LD 0 0) (:LDC 1) (:ADD) (:RTN))<br /> 
nick = swizard time = 25 20:0:53 GCC&gt; (translate '(define (f x) (define (g y) (+ x y))))<br />((:LABEL F) (:LABEL G) (:LD 1 0) (:LD 0 0) (:ADD) (:RTN) (:RTN))<br /> 
nick = turtle time = 25 20:0:58 Смещение там простое. Тупо по команде. 
nick = sectoid time = 25 20:1:34 угу 
nick = turtle time = 25 20:2:28 С енвайронментами я не до конца вкурил. 
nick = turtle time = 25 20:2:44 Там берут текущий, по нему находят корневой и уже из него тащат значения. 
nick = swizard time = 25 20:3:20 там идея такая: окружение — это список фреймов, фрейм — это список биндингов  
nick = swizard time = 25 20:3:47 соответственно, ищем сначала биндинг в текущем фрейме, если его нет, двигаемся дальше к родительскому 
nick = swizard time = 25 20:4:8 каждый define создаёт свой фрейм с биндингами 
nick = turtle time = 25 20:4:44 Ну я также идею понял. Но по спеке как-то странно. 
nick = turtle time = 25 20:4:54 Там же не ищется биндинг во фрейме. 
nick = turtle time = 25 20:4:58 Там тупо из корневого тащится. 
nick = turtle time = 25 20:5:21 Глаза вытекают от новой спеки. 
nick = swizard time = 25 20:5:33 я по псевдокоду писал: 
nick = swizard time = 25 20:5:41   $fp := %e<br />  while $n &gt; 0 do            ; follow chain of frames to get n'th frame<br />  begin<br />    $fp := FRAME_PARENT($fp)<br />    $n := $n-1<br />  end<br />  $v := FRAME_VALUE($fp, $i) ; i'th element of frame<br />  %s := PUSH($v,%s)          ; push onto the data stack<br />  %c := %c+1<br />N 
nick = swizard time = 25 20:5:47 блин :) 
nick = swizard time = 25 20:5:53 ну суть там та же  
nick = turtle time = 25 20:6:26 Это что за операция? 
nick = swizard time = 25 20:6:33 LD, просто сам LD тащит из конкретного фрейма конкретное значение 
nick = swizard time = 25 20:6:41 а мне его как раз сгенерировать надо 
nick = swizard time = 25 20:6:58 тоесть мне надо найти из какого фрейма надо взять какое по счёту значение 
nick = turtle time = 25 20:7:2 А, в такой раскраске не признал. :) 
nick = turtle time = 25 20:7:30 Ну суть втом, что пока фрейм не совсем парентовый, выбирается фрейм парентовый. Итого корневой. А уже из него берутся значения. 
nick = turtle time = 25 20:8:12 А нет, туплю, кажись. 
nick = swizard time = 25 20:8:32 ну вот как-то так, если упрощённо:  
nick = turtle time = 25 20:8:32 Да. Туплю. Он просто же по цепочке берёт. 
nick = swizard time = 25 20:8:36 GCC&gt; (translate '(define (f x) x))<br />((:LABEL F) (:LD 0 0) (:RTN)) 
nick = swizard time = 25 20:9:11 (f x) создаёт нулевой фрейм, записывает туда факт, что x забиндена 
nick = swizard time = 25 20:9:33 и когда я рекурсивно транслирую запись «x», я её должен поискать во фреймах снизу вверх 
nick = turtle time = 25 20:9:41 Так не получится. 
nick = swizard time = 25 20:9:42 чтобы циферки в LD правильно расставить 
nick = swizard time = 25 20:9:45 почему? 
nick = turtle time = 25 20:9:55 Тебе надо фрейм создать. 
nick = turtle time = 25 20:10:15 Хотя, его выше уровнем должны создать. 
nick = turtle time = 25 20:11:26 Да, нормально должно быть. 
nick = swizard time = 25 20:13:8 короче, надо щас подумать как с функциями быть 
nick = turtle time = 25 20:13:38 Ага. Тут то получается, глобального скоупа нет. 
nick = swizard time = 25 20:14:36 нужен, видимо, какой-то отдельный энвайрмент для символов функций 
nick = turtle time = 25 20:14:40 Фреймы вложенные. По идее, можно смотреть и сохранять какие переменные к какому фрейму идут. 
nick = sectoid time = 25 20:14:47 ну, если есть top-level формы (кроме main) - тогда творить енвайрмент верхнего уровня 
nick = turtle time = 25 20:14:56 И далее уже подставлять из известного. 
nick = turtle time = 25 20:15:21 У нас нет энвайронмента верхнего уровня. 
nick = swizard time = 25 20:16:0 допустим, вот такая форма: (define (f g) (g 1)) 
nick = turtle time = 25 20:16:20 Все енвайронменты создаются перед вызовом. 
nick = swizard time = 25 20:16:26 по-идее, если в верхнем фрейме есть такой биндинг, можно его смело вызывать 
nick = swizard time = 25 20:16:33 а если нет? 
nick = swizard time = 25 20:16:39 как в примере с go/to 
nick = turtle time = 25 20:16:47 Ну да. А если нет, то на этапе компиляции нужно с этим определиться есть или нет. 
nick = sectoid time = 25 20:16:57 в примере go/to у нас такой себе labels, как ты уже говорил 
nick = swizard time = 25 20:17:15 правильно, но я не понимаю пока, как его реализовать :) 
nick = turtle time = 25 20:17:26 Ааа. :) 
nick = swizard time = 25 20:17:49 может, ну его вообще :)) делать рекурсию будем по-старинке, через fixed-point operator? :) 
nick = turtle time = 25 20:18:8 Ну вот у тебя frame что содержит? 
nick = swizard time = 25 20:18:25 просто список символов — переменных 
nick = sectoid time = 25 20:18:26 не, ну его 
nick = sectoid time = 25 20:18:30 у нас лимиты 
nick = sectoid time = 25 20:18:37 и компилировать надо макс. эффективно 
nick = swizard time = 25 20:18:41 допустим, добавить туда proc-name, и будет биндинг для функции 
nick = grepz time = 25 20:19:0 лимиты довольно свободные, по крайней мере по памяти 
nick = turtle time = 25 20:19:16 По gcc лимиты большие. 
nick = turtle time = 25 20:19:30 Нам бы для начала скомпилировать чтобы работало. :) 
nick = swizard time = 25 20:19:45 а как labels сделать непонятно — надо перед трансляцией сначала видимо прогнать «на черновую» все под-формы у define и собрать в отдельное место все метки функций внутри 
nick = sectoid time = 25 20:19:55 а по коду лимиты есть? 
nick = swizard time = 25 20:19:57 и это отдельное место уже передавать дальше 
nick = sectoid time = 25 20:19:57 /me пошел рыть 
nick = grepz time = 25 20:20:13 да, первый прогон, собирать инфу, а потом уже транслировать 
nick = turtle time = 25 20:20:18 Ну у нас на самом деле ограниченное количество того, что будет создавать новые фреймы. 
nick = turtle time = 25 20:20:42 И в этих местах у нас есть список переменных, которые они в фрейме держат. 
nick = turtle time = 25 20:21:9 По коду лимитов нет. 
nick = sectoid time = 25 20:21:15 вообще нет лимитов? 
nick = turtle time = 25 20:21:15 Не помню, во всяком случае. 
nick = sectoid time = 25 20:21:19 по коду 
nick = turtle time = 25 20:21:28 По коду gcc? 
nick = sectoid time = 25 20:21:32 да 
nick = swizard time = 25 20:21:38 ладно, давайте тогда я попробую сейчас что-то изобразить с функциями-labels, а пока можно параллельно закодировать остальные инструкции, если кто желает :) 
nick = swizard time = 25 20:21:53 всякое сравнение и тд, по образцу арифметических операций 
nick = turtle time = 25 20:22:0 Там написано, что охренненное количество памяти. Один кусок - стек по коду, другой - стек по данным, третий - управляющий, остальное хип. 
nick = swizard time = 25 20:22:13 тока надо отбранчеваться нам видимо, и потом помержиться  
nick = sectoid time = 25 20:22:30 наверное надо подумать кто чем будет заниматься? 
nick = grepz time = 25 20:23:28 я уже вроде разобрался как с этим работать, могу всякие операции поимплементить 
nick = swizard time = 25 20:23:29 из независимых задач у нас ещё написание примитивного AI на intermediate lisp и транслятор асма порождённого после gcc::translate 
nick = grepz time = 25 20:23:31 их там не так много 
nick = swizard time = 25 20:23:43 grepz: окей, давай 
nick = sectoid time = 25 20:23:45 и еще поковырять скрытый параметр 
nick = sectoid time = 25 20:23:55 я ничерта не понимаю в AI 
nick = grepz time = 25 20:24:0 тогда создаю бранч и начинаю 
nick = swizard time = 25 20:24:19 я тоже отбранчуюсь 
nick = turtle time = 25 20:25:0 Мы с sectoid пока курим спеку. :) 
nick = grepz time = 25 20:25:12 AI пока можно даже без всяких замут вроде пасфиндинга делать 
nick = turtle time = 25 20:25:12 Давай вопросами и мыслями меняться пока они пишут. 
nick = grepz time = 25 20:25:15 просто обход 
nick = sectoid time = 25 20:27:11 мне не дают покоя пока 2 момента:<br />1. недокументированый параметр у main в gcc<br />2. appendix 3-11 который описывает взаимодействие cpu/co-processor и который якобы отстутвует 
nick = turtle time = 25 20:28:12 Ну... :) Пока тоже не могу сказать ничего по этому вопросу. 
nick = sectoid time = 25 20:28:15 а, еще есть 3. покрыть транслятор(ы) тестами (очень пригодится при написании оптимизаций) 
nick = sectoid time = 25 20:28:32 еще есть 4. (но это на основное время) трансляторы для ghc 
nick = turtle time = 25 20:28:50 ghc там регистровая машина, конечно. 
nick = turtle time = 25 20:29:10 Но тоже, в целом, норм. И да, вопрос - транслятор это будет или интерпретатор? 
nick = sectoid time = 25 20:29:25 а вот кто его знает 
nick = sectoid time = 25 20:29:43 но судя по всему - будет возможность как-то &quot;промывать мозги&quot; призракам 
nick = turtle time = 25 20:29:55 Нам бы ещё читалку данных. 
nick = sectoid time = 25 20:30:6 которых? 
nick = turtle time = 25 20:30:27 Которые на вход бота подаются. Кстати, в каком виде то? 
nick = sectoid time = 25 20:31:30 в спеке есть же 
nick = sectoid time = 25 20:32:5 а, еще задачка: <br />1. написать на IL (intemediate lisp) какие-то типично-полезные функции для работы со стейтом мира 
nick = turtle time = 25 20:32:56 Ну я спеку тогда недопонял, наверное. :) Как всё это передаётся боту? 
nick = turtle time = 25 20:33:19 Обычными консами? 
nick = sectoid time = 25 20:34:8 да 
nick = turtle time = 25 20:34:22 А cons у нас будет куда-то в кучу смотреть? 
nick = sectoid time = 25 20:34:28 раздел:<br />Lambda-Man AI interface 
nick = sectoid time = 25 20:34:43 прилетает стейт мира 
nick = turtle time = 25 20:34:43 Да, его и смотрю. 
nick = sectoid time = 25 20:34:55 который есть тупль (цепь консов) 
nick = sectoid time = 25 20:35:0 с кучей инфы 
nick = swizard time = 25 20:35:27 я в файлике internal-lisp-desc.lisp эти типы суммировал 
nick = sectoid time = 25 20:35:31 ага 
nick = sectoid time = 25 20:35:32 для них можно написать аксессоры 
nick = sectoid time = 25 20:35:35 на ILisp 
nick = turtle time = 25 20:35:40 Угу. 
nick = sectoid time = 25 20:35:48 чтобы использовать их в :<br />1. AI<br />2. тестах для транслятора 
nick = sectoid time = 25 20:38:7 закинул рулесы в виде текста в реп 
nick = sectoid time = 25 20:38:19 периодически буду обновлять - так будет хорошо видны изменения 
nick = sectoid time = 25 20:38:22 lynx -dump 'http://icfpcontest.org/specification.html' &gt; RULES 
nick = turtle time = 25 20:39:42 &quot;<br />The encoding of the AI state is private. The host should pass the current<br />AI state on each step but not otherwise inspect it.&quot; 
nick = turtle time = 25 20:39:48 Прикольно, а если поинспектить? 
nick = turtle time = 25 20:40:1 Есть же трасировка, вроде бы. 
nick = swizard time = 25 20:40:53 да не, это же наш ai state :) 
nick = swizard time = 25 20:41:0 хост — это эмулятор оргов 
nick = swizard time = 25 20:41:21 они просто будут получать то, что мы им дадим, и без изменений возвращать обратно 
nick = turtle time = 25 20:41:25 Так я и говорю, поинспектить оргов. :) 
nick = swizard time = 25 20:41:49 но это же просто форма, а не код 
nick = turtle time = 25 20:41:58 Ну да. 
nick = sectoid time = 25 20:42:25 я вот инспектю 
nick = grepz time = 25 20:46:5 пока не очень понимаю как кондишены делать, там же абсолютные адреса, так? 
nick = turtle time = 25 20:48:14 Да. 
nick = turtle time = 25 20:48:20 Просто прыгать по ним. 
nick = turtle time = 25 20:48:36 Хотя, смотря как делать. 
nick = swizard time = 25 20:48:46 может, сделать не по адресу прыжок, а по метке? 
nick = turtle time = 25 20:48:56 Если внутри ветки ифа будет скоуп, то можно и не так. 
nick = swizard time = 25 20:48:57 а потом уже в процессе окончательной генерации кода пересчитать метки  
nick = turtle time = 25 20:49:1 Ну нам нужно по метке. 
nick = turtle time = 25 20:49:9 Просто нужно адрес метки будет вычислять. 
nick = grepz time = 25 20:49:12 вариант 
nick = grepz time = 25 20:49:22 потом уже подставить адреса 
nick = grepz time = 25 20:49:26 чтобы не запариваться 
nick = sectoid time = 25 20:50:49 http://pastebin.com/YruRbpxg 
nick = sectoid time = 25 20:50:59 1й трейс - карта<br />2й - undocumented 
nick = turtle time = 25 20:53:24 Пока его в нормальный вид не приведёшь, фиг прочитаешь. :) 
nick = sectoid time = 25 20:53:48 eue 
nick = sectoid time = 25 20:53:49 угу 
nick = sectoid time = 25 20:53:51 занимаюсь 
nick = sectoid time = 25 20:58:19 undocumented - код программы ghost'ов в виде list'а 
nick = sectoid time = 25 20:58:43 могу попробовать отреверсить кодировку 
nick = sectoid time = 25 20:58:52 если это нужно. может нам ее и так дадут? 
nick = sectoid time = 25 21:5:25 разобрался с кодировкой 
nick = swizard time = 25 21:13:41 так, блин, там же стек, тоесть для функций аргументы в него нужно в обратном порядке складывать 
nick = swizard time = 25 21:13:48 забыл это учесть 
nick = sectoid time = 25 21:17:32 тест 
nick = swizard time = 25 21:17:53 блин, что-то я чуток подзапутался в этих скоупах… есть два случая: а) (define (f x) (define (g y) (+ x y)) (g 1)) и б) (define (outer x) (define (inner-a y) (+ x y)) (define (inner-b y) (inner-a y)) (inner-b 1)) 
nick = swizard time = 25 21:18:18 в первом случае достаточно LDF метка + AP, а для второго нужен DUM+RAP? 
nick = swizard time = 25 21:18:20 правильно? 
nick = swizard time = 25 21:18:59 тоесть все локальные дефайны видны напрямую на этом же уровне функции? 
nick = grepz time = 25 21:19:11 да, по идее 
nick = swizard time = 25 21:19:47 а кто нам мешает вообще всё через RAP делать? :) только ограничение на количество опкодов? 
nick = turtle time = 25 21:19:50 Тест пассед. 
nick = sectoid time = 25 21:19:54 по идее там надо бы вкорячить flet/labels 
nick = sectoid time = 25 21:20:4 чтот не так у нас с конфой, меня выкинуло 
nick = sectoid time = 25 21:20:14 вы получали, что я расшифровал undocumented? 
nick = swizard time = 25 21:20:38 последнее сообщение было про «разобрался с кодировкой» 
nick = grepz time = 25 21:20:44 гм, что-то ты меня задумал... если предположить что мы нигде ранее не ошиблись, то вобщем да 
nick = sectoid time = 25 21:20:49 угу 
nick = grepz time = 25 21:20:55 можем всё через rap 
nick = sectoid time = 25 21:21:13 можем. но мне кажется что ap там тоже не просто так 
nick = turtle time = 25 21:21:37 AP и RAP несколько разные. 
nick = turtle time = 25 21:21:46 Хотя, DUM + RAP, наверное, разницу сгладит. 
nick = sectoid time = 25 21:22:11 а давайте подумаем: может стоит ввести flet/labels? 
nick = turtle time = 25 21:22:26 the current environment frame pointer must point to an empty<br />            frame of size $n; 
nick = sectoid time = 25 21:22:28 или нафигачим потом эвристику? 
nick = turtle time = 25 21:22:30 Вот это для RAP. 
nick = turtle time = 25 21:22:49 &quot;set the frame's parent to be the environment frame pointer<br />            from the CLOSURE cell;&quot; 
nick = turtle time = 25 21:22:52 Это для AP. 
nick = swizard time = 25 21:23:13 да не, flet/labels избыточен, мы же и так по коду видим, где вызов по адресу, а где по указателю 
nick = turtle time = 25 21:23:24 А разница между flet/labels, если просто вложенные дефайны сделать? 
nick = swizard time = 25 21:23:27 ну тоесть не по коду, а по биндингам 
nick = turtle time = 25 21:23:37 Т.е. они уже есть. 
nick = swizard time = 25 21:23:46 просто я не очень понял, почему бы всё тупо по указателям не звать  
nick = turtle time = 25 21:24:25 Ну хз. МОжет, оптимизации. 
nick = turtle time = 25 21:24:36 Или сначала сделали AP, потом нужно стало RAP. 
nick = turtle time = 25 21:24:39 Так и осталось. 
nick = turtle time = 25 21:24:46 Не знаю. Боюсь предполагать. 
nick = swizard time = 25 21:26:28 ок, щас ещё немного поразмышляю и попробую что-нибудь изобразить 
nick = swizard time = 25 21:27:59 можно попробовать совсем простую логику: если в принципе есть какие-то декларации внутри функции, то перед всеми вызовами использовать dum/rap, а если нет, то просто ld/ap   
nick = swizard time = 25 21:28:52 просто иначе там не совсем тривиально получается — надо ещё на этапе трансляции функции понять, есть ли рекурсивные вызовы внутри саб-функций  
nick = swizard time = 25 21:29:17 и, соответственно, нужен ли dum/rap 
nick = swizard time = 25 21:29:38 а так просто всегда его рисовать, вне зависимости от того, нужен он там или нет 
nick = swizard time = 25 21:29:56 или я ошибаюсь? 
nick = turtle time = 25 21:29:57 Можно пока так попробовать. 
nick = turtle time = 25 21:30:5 Я сам не могу пока вкурить разницу. 
nick = grepz time = 25 21:32:46 а вот такой вопрос, мы в трансляторе проверки должны делать на предмет, например если cdr действительно cons cell подают или нет? 
nick = swizard time = 25 21:33:7 я думаю, нет :) 
nick = sectoid time = 25 21:33:9 а как мы можем это проверить? 
nick = sectoid time = 25 21:33:14 разве что вывод типа писать 
nick = swizard time = 25 21:33:23 будем считать, что IL всегда генерируется корректный 
nick = grepz time = 25 21:33:29 можем, просто это надо анализировать пришедший ast 
nick = grepz time = 25 21:33:31 ок 
nick = turtle time = 25 21:33:34 Ну там, на самом деле либо LDF/AP, либо DUM/LDF/RAP 
nick = turtle time = 25 21:34:3 В целом, погонял на симуляторе. 
nick = turtle time = 25 21:34:13 Разницы не увидел на придуманных примерах. 
nick = turtle time = 25 21:34:16 Они простые, конечно. 
nick = swizard time = 25 21:36:20 а что за симулятор? 
nick = swizard time = 25 21:36:28 что-то я прослоупочил 
nick = turtle time = 25 21:36:41 http://icfpcontest.org/lman.html 
nick = swizard time = 25 21:37:14 о класс 
nick = swizard time = 25 21:37:34 ладно, я щас пока через rap всё делаю, в любом случае, хотя бы будут работающие функции 
nick = turtle time = 25 21:38:18 Я тоже думаю, что пока так пойдёт. 
nick = turtle time = 25 21:38:26 Если не будем влазить - дотюним. 
nick = sectoid time = 25 21:38:38 тесты делать будем? 
nick = swizard time = 25 21:39:0 было бы хорошо, если не лень :) 
nick = grepz time = 25 21:39:13 я думаю что надо 
nick = grepz time = 25 21:39:23 а то потом ошибки искать... 
nick = sectoid time = 25 21:39:45 особенно когда начнем впиливать эвристики 
nick = turtle time = 25 21:40:42 Если начнём. :) 
nick = swizard time = 25 21:41:14 я только не понял, а как результаты выполнения функций на стек кладутся? 
nick = swizard time = 25 21:41:29 а, всё вроде понял 
nick = sectoid time = 25 21:41:48 там звучало, что результатов может быть несколько 
nick = sectoid time = 25 21:42:28 ищу цитату 
nick = turtle time = 25 21:43:3 Там не совсем про это было с несколькими. 
nick = sectoid time = 25 21:43:57 а про что? 
nick = sectoid time = 25 21:44:4 цитаты не нашел 
nick = turtle time = 25 21:44:15 А кладутся просто операцией. Вроде вручную. 
nick = grepz time = 25 21:44:20 (translate '(&gt;= (car (cons 1 2)) 3)) -&gt; ((:LDC 1) (:LDC 2) (:CONS) (:CAR) (:LDC 3) (:CGTE)) нигде не ошибся? 
nick = turtle time = 25 21:44:22 Из енвайронмента или константой. 
nick = swizard time = 25 21:44:53 ошибся порядком закладывания в стек, как и я :) 
nick = grepz time = 25 21:45:2 ой, точно 
nick = turtle time = 25 21:45:16 Ага, как раз полез смотреть спеку, чтобы убедиться. :) 
nick = sectoid time = 25 21:45:43 /me убег на 20 минут 
nick = turtle time = 25 21:47:7 Да, на стек кладутся просто по выполнению LD, LDC, LDF, CONS. 
nick = turtle time = 25 21:47:24 А, CGTE и ему подобные тоже на стек ложат. 
nick = grepz time = 25 21:47:32 да 
nick = turtle time = 25 21:47:37 Короче, инструкции сами кладут на стек. 
nick = turtle time = 25 21:47:51 Ну и LDx для того, чтобы самому положить. 
nick = grepz time = 25 21:49:35 я тут просидел некоторое время с sel, но пока не выходит ёжик. надо подумать будет как обсчёт смещения в конце сделать. 
nick = swizard time = 25 21:50:6 окей, ты тогда, может, ветку свою пока в мастер вмержи?  
nick = turtle time = 25 21:50:17 Да там обсчёт то не нужно делать. 
nick = swizard time = 25 21:50:18 мне ещё минут 10-15 нужно на доделать функции 
nick = turtle time = 25 21:50:21 В целом то. 
nick = grepz time = 25 21:50:23 ок 
nick = turtle time = 25 21:50:34 Все команды, которые получаются, они занимают 1. 
nick = turtle time = 25 21:50:52 Хотя, надо с транслейта получить, а потом уже номера расставить. 
nick = turtle time = 25 21:51:14 Ты сейчас как получаешь без обсчитанных меток? 
nick = grepz time = 25 21:52:34 Ну схема я так понимаю должна быть такая: собираются все лейблы, потом мы знаем что мейн это нулевой адрес и в порядке задания лейблов наращиваем адреса, заменяя токены на адреса или я не прав? 
nick = turtle time = 25 21:53:37 Ну тут в два прохода, наверное, должно. 
nick = swizard time = 25 21:53:38 ну да, я думаю, достаточно пройтись один раз по получившемуся списку со счётчиком, складывая лейблы в словарь рядом, и второй раз — пересчитать метки в прыжках 
nick = turtle time = 25 21:54:2 Первый транслейт выдает с лейблами, потом по мнемокоду с лейблами меняем на мнемокод с числами. 
nick = swizard time = 25 21:54:3 там же и вниз и наверх прыгать можно 
nick = turtle time = 25 21:54:35 Да, поэтому второй проход нужен будет. 
nick = grepz time = 25 21:54:39 ладно, я сейчас буквально на 5 мин отойду, выложу опсы(там кстати совсем немного) и попробую сделать так. 
nick = turtle time = 25 21:54:58 Кстати, такой момент с этими адресами. 
nick = turtle time = 25 21:55:32 Там же идёт по порядку. Если мы зашли в одну ветку, то прыгаем на неё, а потом нужно в конце перепрыгнуть ту ветку, в которую не надо заходить. 
nick = turtle time = 25 21:55:53 Иначе он два действия выполнит. :) 
nick = grepz time = 25 22:5:54 Я не мёрджил пока ничего, запушил forms-ops на репу 
nick = grepz time = 25 22:9:24 http://pastebin.com/YruRbpxg а вот эта ссылка она откуда? 
nick = grepz time = 25 22:10:14 всмысле сами данные 
nick = turtle time = 25 22:10:27 Это сектоид дебагом в симуляторе вывел. 
nick = grepz time = 25 22:10:36 понял 
nick = sectoid time = 25 22:13:54 я вернулся 
nick = sectoid time = 25 22:14:45 grepz: я расшифровал что делает параметр undocumented. в него приходят закодированые программы гостов.  
nick = grepz time = 25 22:15:14 интересно, дадут ли нам кодировку. :) 
nick = sectoid time = 25 22:15:26 ну хз. она там тривиальная 
nick = sectoid time = 25 22:15:30 у меня появляется ощущение что надо сделать трансляцию нашего IL и в CL тоже. чтобы отлаживаться. и весь основной код писать на IL 
nick = sectoid time = 25 22:15:49 ибо чует мое сердце - неспроста там этот undocumented 
nick = sectoid time = 25 22:17:41 swizard: что скажешь насчет добавления 2го таргета трансляции? 
nick = swizard time = 25 22:18:52 да я не против, IL в CL можно чуть ли не через eval вызвать после минимальных модификаций :) 
nick = sectoid time = 25 22:19:20 давай может тогда в translate закинем параметр? 
nick = sectoid time = 25 22:19:36 прост не хочу счас править, чтобы конфликтов не нагрести 
nick = swizard time = 25 22:21:2 да я думаю можно отдельную функцию написать, в отдельном пакаже 
nick = swizard time = 25 22:21:11 там же код разный совсем получается 
nick = sectoid time = 25 22:26:12 ок, счас что-то буду соображать 
nick = swizard time = 25 22:27:54 ну короче я примерно понял, почему нельзя всё через RAP сделать 
nick = swizard time = 25 22:28:6 потому что ему нельзя параметром 0 передать 
nick = swizard time = 25 22:28:20 типа DUM 0 / RAP 0 
nick = swizard time = 25 22:28:34 ладно, ща исправим быстренько 
nick = sectoid time = 25 22:28:40 нельзя? точно? 
nick = grepz time = 25 22:28:42 :) 
nick = swizard time = 25 22:29:3 судя по псевдокоду в спеке нельзя 
nick = sectoid time = 25 22:29:24 референс на ура сожрал 
nick = sectoid time = 25 22:29:28 DUM 0 
nick = swizard time = 25 22:29:38 хм, возможно тогда я и ошибаюсь 
nick = turtle time = 25 22:29:57 Референ сожрал. Правда, фрейм нулевой создался, конечно. 
nick = sectoid time = 25 22:30:4 ну и ладно 
nick = turtle time = 25 22:30:9 Может, референс кривой? :) 
nick = sectoid time = 25 22:30:10 если создался нулевой - то лано 
nick = sectoid time = 25 22:30:23 а вот RAP 0 ругается. но мот вызываю. неверно. дайте минимальный 
nick = sectoid time = 25 22:30:28 если под рукой есть 
nick = turtle time = 25 22:30:51 По спеке тоже нет таких ограничений. 
nick = turtle time = 25 22:30:57 DUM 0<br />LDF 4<br />RAP 0<br />STOP<br />RTN 
nick = turtle time = 25 22:31:0 Вот это жрёт. 
nick = turtle time = 25 22:32:19 В общем, не увидел я в спеке, что там должно быть больше 0 параметры для этих инструкций. 
nick = sectoid time = 25 22:32:22 ага 
nick = sectoid time = 25 22:32:34 можно задать вопрос в ирке 
nick = sectoid time = 25 22:34:14 спросил в ирке 
nick = turtle time = 25 22:34:50 Вижу. ) 
nick = turtle time = 25 22:35:24 Почему ты написал, что невозможно использовать DUM 0, RAP 0 по спеке? Там то ограничений тоже нет. 
nick = swizard time = 25 22:36:23 ошибся, извиняюсь 
nick = turtle time = 25 22:37:34 Для гостов можно заимплементить обычный вейвлет на цель.  И при гостах чем больше, тем, думаю, будет результативнее. 
nick = turtle time = 25 22:37:50 Хотя, смотреть надо по карте. 
nick = sectoid time = 25 22:41:25 да, в спеке нет что $n &gt; 0 
nick = sectoid time = 25 22:41:30 я поспешил спрашивать 
nick = turtle time = 25 22:46:25 swizard: https://bitbucket.org/skobochka/icfpc-2014/src/a6a265c58ff3bf821d46a472f4c8345632ae92e8/gcc/examples/always-down.lisp?at=master 
nick = turtle time = 25 22:46:50 Если я правильно понял, как-то так должен пример выглядеть, которые робота всегда вниз гонит. 
nick = turtle time = 25 22:47:12 Хотя, тут надо с нашими скоупами согласоваться. 
nick = sectoid time = 25 22:48:48 доп правило &quot;линковки&quot;: тело функции main идет всегда по адресу 0 
nick = turtle time = 25 22:49:15 У нас там многопроходный? 
nick = turtle time = 25 22:49:47 Или оно просто будет вложено в main? 
nick = sectoid time = 25 22:49:54 ну, у нас 2 фазы трансляции: il-&gt;sexp, sexp -&gt; text. в каком-то месте мы должны еще заменять label на оффсеты. 
nick = turtle time = 25 22:50:25 Ну тут сначала просто с синтаксисом надо определиться. 
nick = turtle time = 25 22:52:37 swizard: тогда так https://bitbucket.org/skobochka/icfpc-2014/src/861c45a3edb2cad137c09ad253c81b080b839462/gcc/examples/always-down.lisp?at=master 
nick = grepz time = 25 22:55:40 ближе к 5 уже у меня, голова ватная совсем. Я наверное чуток посплю, а то сильно торможу. Хистори как-то можно запросить у сервака? А то уезжает. Или может на битбакете issues оставить, чтобы сразу мог как проснусь включиться? 
nick = turtle time = 25 22:56:10 Ты запушил всё, что мог? 
nick = turtle time = 25 22:56:23 Если запушил, спокойной ночи. :) 
nick = grepz time = 25 22:56:37 да, я там простые опсы сделал. Надо решить будет с адресацией, тогда оставшееся можно будет доделать 
nick = grepz time = 25 22:56:54 ладно, всем продуктивной ночи 
nick = sectoid time = 25 22:56:57 ночи, grepz 
nick = swizard time = 25 22:57:31 спокойной ночи 
nick = swizard time = 25 22:57:52 блин там ад конечно с этими функциями, но вроде, наконец, что-то стало вырисовываться 
nick = swizard time = 25 22:58:9 есть шанс сделать в ближайшее время 
nick = sectoid time = 25 22:58:23 еще эвристика нужна 
nick = sectoid time = 25 22:58:29 в смысле АИ 
nick = sectoid time = 25 23:16:10 свиз, ты используешь какой :metatilities ? 
nick = swizard time = 25 23:16:31 да чёрт его знает, который quicklisp приносит 
nick = sectoid time = 25 23:17:42 (translate '(define (main initial-state undocumented)<br />              (define (step-function ai-state world-state)<br />                (cons (+ ai-state 1) :down))<br />                  (cons 42 step-function)))<br /> 
nick = sectoid time = 25 23:17:51 (DEFINE (MAIN INITIAL-STATE UNDOCUMENTED)<br /> (DEFINE (STEP-FUNCTION AI-STATE WORLD-STATE)<br />  (CONS (+ AI-STATE 1) :DOWN))<br /> (CONS 42 STEP-FUNCTION)) fell through ETYPECASE expression.<br />Wanted one of (ATOM INTEGER).<br />   [Condition of type SB-KERNEL:CASE-FAILURE]<br /> 
nick = sectoid time = 25 23:18:15 какого-то дьявола проваливается до translate-atom 
nick = turtle time = 25 23:18:34 Ну на :down, наверное, падает. 
nick = sectoid time = 25 23:19:20 неа. define 
nick = sectoid time = 25 23:19:33   0: (SB-KERNEL:CASE-FAILURE ETYPECASE (DEFINE (MAIN INITIAL-STATE UNDOCUMENTED) (DEFINE (STEP-FUNCTION AI-STATE WORLD-STATE) (CONS # :DOWN)) (CONS 42 STEP-FUNCTION)) (ATOM INTEGER))<br />  1: (TRANSLATE-ATOM (DEFINE (MAIN INITIAL-STATE UNDOCUMENTED) (DEFINE (STEP-FUNCTION AI-STATE WORLD-STATE) (CONS # :DOWN)) (CONS 42 STEP-FUNCTION)) NIL)<br />      Locals:<br />        SB-DEBUG::ARG-0 = (DEFINE (MAIN INITIAL-STATE UNDOCUMENTED) (DEFINE (STEP-FUNCTION AI-STATE WORLD-STATE) (CONS (+ AI-STATE 1) :DOWN)) (CONS 42 STEP-FUNCTION))<br />        SB-DEBUG::ARG-1 = NIL<br />  2: (TRANSLATE-WALKER (DEFINE (MAIN INITIAL-STATE UNDOCUMENTED) (DEFINE (STEP-FUNCTION AI-STATE WORLD-STATE) (CONS # :DOWN)) (CONS 42 STEP-FUNCTION)) NIL)<br /> 
nick = swizard time = 25 23:20:28 не ну такой код он не умеет транслировать ещё, вы что :) 
nick = turtle time = 25 23:20:44 Поторопились мы. :) 
nick = swizard time = 25 23:20:47 я как раз вызовы функций доделываю, а консы у grepz должны быть готовы  
nick = swizard time = 25 23:20:53 надо ещё смержить будет 
nick = sectoid time = 25 23:21:11 у меня он даже define не транслирует 
nick = sectoid time = 25 23:21:18 лан, сам отлаживать буду 
nick = swizard time = 25 23:21:40 а что за версия? я там просто уже переписал много чего 
nick = turtle time = 25 23:22:8 Нам, наверное, надо какое-то ядро реализовать на этом ассемблере, остальное выразить через ядро. 
nick = swizard time = 25 23:22:54 да, мы больше чем надо не программируем :) 
nick = swizard time = 25 23:23:3 просто без вызовов функций там совсем беда 
nick = turtle time = 25 23:23:10 Ну это основное. :) 
nick = swizard time = 25 23:23:34 ща вспомнил — в sicp в конце как раз компилятор писали, со всеми этими scope’ами и letrec-ами 
nick = swizard time = 25 23:23:46 ща если не осилю опять, надо будет освежить память 
nick = sectoid time = 25 23:24:2 кто-то кроме свиза юзал metatilities? 
nick = turtle time = 25 23:24:6 Да, там такое было. 
nick = turtle time = 25 23:24:20 А что у тебя за проблемы с метатилитисами? 
nick = sectoid time = 25 23:25:4 тут или приват? 
nick = sectoid time = 25 23:25:41 все, понял беду 
nick = sectoid time = 25 23:25:50 оно не может вложеные функции 
nick = sectoid time = 25 23:25:52 паттерн кривой 
nick = sectoid time = 25 23:30:3 дока на if-match есть? 
nick = grepz time = 25 23:30:6 Звук джабера разбудил, думаю дело в том, что текущая версия парсера не умеет такое: (translate '((+ 1 x) (+ 2 x))), надо расширить, чтобы парсер комбинировал выражения на одном уровне. 
nick = swizard time = 25 23:30:50 а гляньте бранч labels-et-all, я там это всё ориентировочно починил 
nick = swizard time = 25 23:31:1 но сам код в целом в этом бранче нерабочий правда :) 
nick = sectoid time = 25 23:34:53 счас гляну 
nick = swizard time = 25 23:37:58 я щас завёл другую экспериментальную ветку, в которой всё нафиг переделал :) 
nick = swizard time = 25 23:38:14 как вы думаете, имеет ли вообще смысл позволять несколько форм типа progn 
nick = sectoid time = 25 23:38:29 где именно? 
nick = swizard time = 25 23:38:35 проблема в том, что каждая форма что-то кладёт на стек 
nick = sectoid time = 25 23:38:37 мысль о progn меня тоже только что посещала 
nick = turtle time = 25 23:38:40 Почему бы нет? 
nick = turtle time = 25 23:38:47 Теоретически, стек безразмерный. 
nick = swizard time = 25 23:38:50 типа (define (x) (+ 1 2) (+ 3 4) (+ x 2)) 
nick = sectoid time = 25 23:39:2 ну норм 
nick = swizard time = 25 23:39:10 просто у нас ведь нет побочных эффектов, зачем там вообще несколько форм? 
nick = sectoid time = 25 23:39:14 implicit progn туда 
nick = swizard time = 25 23:39:15 результат-то последний нужен 
nick = turtle time = 25 23:39:16 А что, прямого прыжка нет в gcc? 
nick = sectoid time = 25 23:39:24 есть через tailcall 
nick = sectoid time = 25 23:39:27 как я понял 
nick = sectoid time = 25 23:39:31 или tsel 
nick = swizard time = 25 23:39:33 в gcc есть, а в лиспе он зачем? 
nick = sectoid time = 25 23:39:57 свиз, можно оставить progn, и сделать оптимизатор, который будет выкидывать лишнее 
nick = sectoid time = 25 23:40:10 у нас сайд-эффекты могут быть только в set, емнип 
nick = swizard time = 25 23:40:26 можно, но зачем нам вообще set? :) 
nick = swizard time = 25 23:40:38 во что его компилировать для gcc? 
nick = sectoid time = 25 23:47:51 эээ. там есть соотв. операция 
nick = sectoid time = 25 23:47:58 раздел &quot;Pascal extensions&quot; 
nick = sectoid time = 25 23:48:18 CL-TARGET&gt; (translate '(define (main initial-state undocumented)<br />                        (define (step-function ai-state world-state)<br />                         (cons (+ ai-state 1) :down))<br />                        (cons 42 step-function)))<br />=&gt;<br />(DEFUN GCC/MAIN (INITIAL-STATE UNDOCUMENTED)<br />  (DEFUN GCC/STEP-FUNCTION (AI-STATE WORLD-STATE) (CONS (+ AI-STATE 1) :DOWN))<br />  (CONS 42 STEP-FUNCTION))<br /><br />ну, почти оно 
nick = turtle time = 25 23:48:50 LDC 0<br />SEL 3 5<br />RTN<br />;TRUE<br />LDC 2<br />RTN<br />;FALSE<br />LDC 3<br />RTN<br />;END<br /> 
nick = turtle time = 25 23:48:56 Что-то у меня такой иф получился. 
nick = turtle time = 25 23:49:12 Иф у нас тоже будет как отдельная форма? 
nick = turtle time = 25 23:49:20 Со своим скопом? 
nick = sectoid time = 25 23:49:59 про скоп не понял 
nick = swizard time = 25 23:50:13 не, форма, но без скопа 
nick = swizard time = 25 23:50:21 у меня кстати идея 
nick = sectoid time = 25 23:50:31 commit bf1feaf93484d6744eb6d68fefc2ab54ee29f911 (refs/remotes/origin/labels-et-all)<br /><br />свиз, у тебя в паттерне <br /> (defun translate-define (proc-name proc-args proc-body environment)<br />-  `((:label ,proc-name)<br />-    ,@(translate-walker proc-body (cons proc-args environment))<br />-    (:rtn)))<br />+  (let* ((rec-bindings (reduce (lambda (bindings form)<br />+                                 (if-match (define (?proc-name . ?proc-args) ?forms) form<br /><br />опечатка. должно быть &quot;. forms?&quot; 
nick = swizard time = 25 23:50:50 давайте попробуем примитивнейшего бота накидать сразу на асме руками 
nick = swizard time = 25 23:51:0 чтобы если что хоть что-то в lightning round запостить :) 
nick = turtle time = 25 23:51:2 Насколько примитивнейшего? :) 
nick = swizard time = 25 23:51:11 ну который вниз всё время прёт 
nick = swizard time = 25 23:51:13 например 
nick = turtle time = 25 23:51:15 Куда? 
nick = swizard time = 25 23:51:31 sectoid: да, опечатка 
nick = sectoid time = 25 23:51:37 ну, мона и с этого начать, да-с 
nick = swizard time = 25 23:51:48 turtle: куда запостить? ну в форму орговскую 
nick = swizard time = 25 23:51:56 там же листинг на асме нужен 
nick = turtle time = 25 23:51:57 Куда прёт? 
nick = sectoid time = 25 23:52:15 бот прет. по карте 
nick = swizard time = 25 23:52:15 бот вниз всё время двигается 
nick = sectoid time = 25 23:52:21 можно не только вниз даже 
nick = sectoid time = 25 23:52:28 а по часовой стрелке 
nick = turtle time = 25 23:52:41 http://icfpcontest.org/game.html 
nick = turtle time = 25 23:52:45 Вот вправо двигается. 
nick = turtle time = 25 23:53:31 LDC  0<br />LDF  4<br />CONS<br />RTN<br />LDC  0<br />LDC  3<br />CONS<br />RTN<br /> 
nick = sectoid time = 25 23:53:36 угу 
nick = turtle time = 25 23:53:40 Вот, собственно говоря, с той странички. 
nick = swizard time = 25 23:54:1 ну вот если его проапгрейдить чуток :) 
nick = turtle time = 25 23:54:25 Там без анализа ситуации смысла нет апгрейдить. 
nick = sectoid time = 25 23:54:32 дело в том, что для того чтобы даже проверить есть ли дорога впереди - надо уже код иметь неслабый 
nick = turtle time = 25 23:54:34 Можно, конечно, менять направление пока не упрётся. 
nick = sectoid time = 25 23:54:36 ибо надо cons'в разматывать 
nick = sectoid time = 25 23:55:8 но в целом идея интересная 
nick = sectoid time = 25 23:55:23 можно на лиспе написать 
nick = sectoid time = 25 23:55:31 а на крайняк скомилить можно и вручную 
nick = turtle time = 25 23:56:15 LDC 1<br />SEL 3 5<br />RTN<br />;TRUE<br />LDC 2<br />JOIN<br />;FALSE<br />LDC 3<br />JOIN<br />;END<br /> 
nick = turtle time = 25 23:56:22 Вот такой иф получился. 
nick = turtle time = 25 23:56:41 Правда, его как бы вызывать придётся. 
nick = turtle time = 25 23:57:15 Если не вызывать, то тогда надо пушить единицу и также SEL'ом. 
nick = turtle time = 25 23:57:29 Ну или TSEL'ом, кстати. 
nick = turtle time = 25 23:57:52 Но хз. 
nick = sectoid time = 25 23:58:4 попробуй с TSEL'ом 
nick = turtle time = 25 23:58:10 Наверное, надо также вызывать как и любую функцию, т.е. с енвайронментом. 
nick = turtle time = 25 23:58:18 TSEL тоже ничего хорошего не даст. 
nick = turtle time = 25 23:58:27 Надо же как-то переходить дальше. 
nick = sectoid time = 25 23:58:55 А может у нас быть такое:<br />(define (main)<br />  (define foo (x)<br />    (bar x))<br />  (+ 1 2)<br />  (define bar (y)<br />    (foo y))<br />  (foo 1))<br /><br /> 
nick = sectoid time = 25 23:59:0 ? 
nick = swizard time = 26 0:0:18 ну вообще теоретически да, и непонятно как это транслировать :( я поэтому на самом деле щас в новом бранче провожу эксперимент со схемовским синтаксисом, с let и letrec 
nick = sectoid time = 26 0:0:20 иными словами: define который идет не в начале. и видимый в define'е выше 
nick = swizard time = 26 0:0:33 чтобы более-менее однозначный код был 
nick = sectoid time = 26 0:0:36 вот это наверное более правильный подход, свиз 
nick = sectoid time = 26 0:0:50 и проще будет транслировать его в CL 
nick = sectoid time = 26 0:0:54 для отладки 
nick = swizard time = 26 0:0:59 ага 
nick = swizard time = 26 0:1:8 просто с оригинальным вариантом я реально закопался 
nick = sectoid time = 26 0:1:15 а можешь откоммитится ? 
nick = sectoid time = 26 0:1:21 чтобы я CL-вариант тоже подкрутил 
nick = turtle time = 26 0:1:28 LDC 1<br />SEL 4 6<br />LDC 1<br />TSEL 8 8<br />;TRUE<br />LDC 2<br />JOIN<br />;FALSE<br />LDC 3<br />JOIN<br />;END<br />RTN 
nick = swizard time = 26 0:1:33 ща минут 10 ещё, допишу до работоспособности 
nick = turtle time = 26 0:1:39 Вот такой получился иф. :) 
nick = sectoid time = 26 0:1:41 оок 
nick = swizard time = 26 0:1:41 ветка будет let-letrec-test 
nick = turtle time = 26 0:1:57 Жуть, а не иф. 
nick = sectoid time = 26 0:2:32 счас взгляну на спеку. скади, turtle, ты какого хочешь поведения добится? conditional call'а или тупо jumpа? 
nick = sectoid time = 26 0:2:33 хм 
nick = sectoid time = 26 0:2:35 ХМ 
nick = turtle time = 26 0:3:15 Я уже добился обычного джампа. 
nick = turtle time = 26 0:3:22 Ну после сравнений, конечно. 
nick = sectoid time = 26 0:6:22 нормальный if 
nick = turtle time = 26 0:6:55 В общем, в бранче sel лежит. 
nick = swizard time = 26 0:18:52 положил бранч let-letrec-test — сам letrec я пока не доделал, но предлагаю посмотреть на примеры, переписанные через let/letrec 
nick = swizard time = 26 0:18:56 такое вот у меня предложение 
nick = sectoid time = 26 0:19:32 счас гляну 
nick = sectoid time = 26 0:24:45 допишу только хелпер 
nick = sectoid time = 26 0:30:11 GCC&gt; (translate '(list 1 2 3))<br /><br />((:LDC 0) (:LDC 3) (:CONS) (:LDC 2) (:CONS) (:LDC 1) (:CONS))<br />GCC&gt; (translate '(tuple 1 2 3))<br /><br />((:LDC 3) (:LDC 2) (:CONS) (:LDC 1) (:CONS))<br /> 
nick = sectoid time = 26 0:30:15 верно вроде? 
nick = swizard time = 26 0:30:41 ага похоже! 
nick = sectoid time = 26 0:30:56 хелперы 
nick = turtle time = 26 0:33:44 Я допетрил фишку с undocumented. 
nick = sectoid time = 26 0:34:20 ну? 
nick = sectoid time = 26 0:34:22 GCC&gt; (translate '(let ((body (lambda (x) (+ x x))))  (body 21)))<br />((:LDC 21) (:LD 0 0) (:AP 1) (:LABEL BODY) (:LD 0 0) (:LD 0 0) (:ADD) (:RTN))<br /> 
nick = turtle time = 26 0:34:36 Ты говоришь, там код для гостов. 
nick = sectoid time = 26 0:34:37 свиз, мне кажется, или тут не верный порядок? 
nick = sectoid time = 26 0:34:45 туртл. ты жжошь) 
nick = turtle time = 26 0:34:56 А что не так? :) 
nick = sectoid time = 26 0:35:7 [21:14:45] &lt;sectoid&gt; grepz: я расшифровал что делает параметр undocumented. в него приходят закодированые программы гостов. <br /> 
nick = turtle time = 26 0:35:19 Ну да. 
nick = turtle time = 26 0:35:25 Я смысл этого допетрил. 
nick = turtle time = 26 0:35:30 ЗАчем так сделано. 
nick = sectoid time = 26 0:35:44 ну, зачем?) 
nick = turtle time = 26 0:35:53 Т.е. нужно будет нашим лямбда-меном читать программы гостов, предсказывать их поведение и выигрывать на этом. 
nick = sectoid time = 26 0:35:55 чтобы пытаться понять насколько они умные? 
nick = sectoid time = 26 0:35:59 ага 
nick = turtle time = 26 0:36:6 Чтобы пытаться понять где они пройдут. 
nick = turtle time = 26 0:36:25 Тем более, что там где-то минуту на инициализацию дают. 
nick = sectoid time = 26 0:36:27 я подумал вот еще что: если там нет int 1/int 2 -- они не знают где мы 
nick = turtle time = 26 0:36:29 Зачем так много? 
nick = turtle time = 26 0:36:52 Т.е. лябда-мен может прогнать у себя в башке варианты и выбрать один из лучших. 
nick = sectoid time = 26 0:36:57 ага 
nick = turtle time = 26 0:37:16 Т.е. эмулятор машины мы будем писать внтури IL. 
nick = turtle time = 26 0:38:5 Причём разработка гостов - бонус. Мне так кажется. 
nick = sectoid time = 26 0:38:33 угу 
nick = sectoid time = 26 0:38:44 потому я набрасывал работу с ghc в рамках IL 
nick = sectoid time = 26 0:39:5 и хочу таки иметь транслятор IL в CL, чтобы нормально отлаживаться 
nick = turtle time = 26 0:40:5 Ну это на сейчас, наверное, не так нужно. 
nick = sectoid time = 26 0:40:12 swizard: там что-то не так с вызовом. или мы сначала где-то должны еще заполнять таблицу символов? 
nick = swizard time = 26 0:40:44 а ты какой вызов имеешь в виду? 
nick = swizard time = 26 0:40:48 я гляну щас 
nick = swizard time = 26 0:41:17 local.lisp вроде 1:1 транслируется к local.gcc 
nick = swizard time = 26 0:41:39 c goto.lisp там щас похитрее, я ввожу хелперную функцию 
nick = sectoid time = 26 0:46:25 не 1 в 1 
nick = swizard time = 26 0:46:36 а где косяк? 
nick = sectoid time = 26 0:46:42   LDC  21<br />  LDF  body     ; load body<br />  AP   1        ; call body with 1 variable in a new frame<br />  RTN<br />body:<br />  LD   0 0      ; var x<br />  LD   0 0      ; var x<br />  ADD<br />  RTN<br /><br />и <br />((:LDC 21) (:LD 0 0) (:AP 1) (:LABEL BODY) (:LD 0 0) (:LD 0 0) (:ADD) (:RTN)) 
nick = sectoid time = 26 0:46:55 там должен быть не LD, а LDF 
nick = swizard time = 26 0:47:9 эм, а обнови плз ветку 
nick = sectoid time = 26 0:47:13 аа 
nick = sectoid time = 26 0:47:55 обновил 
nick = sectoid time = 26 0:47:57 та же беда 
nick = sectoid time = 26 0:47:58 GCC&gt; (translate '(let ((body (lambda (x) (+ x x))))  (body 21)))<br />((:LDC 21) (:LD 0 0) (:AP 1) (:LABEL BODY) (:LD 0 0) (:LD 0 0) (:ADD) (:RTN))<br /> 
nick = sectoid time = 26 0:48:23 пардон 
nick = swizard time = 26 0:48:26 хм  
nick = swizard time = 26 0:48:28 GCC&gt; (translate '(let ((body (lambda (x) (+ x x))))  (body 21)))<br />((:LDC 21) (:LDF BODY) (:AP 1) (:RTN) (:LABEL BODY) (:LD 0 0) (:LD 0 0) (:ADD)<br /> (:RTN))<br /> 
nick = sectoid time = 26 0:48:29 мой емакс меня обидел 
nick = sectoid time = 26 0:48:33 да, это я слоупок 
nick = swizard time = 26 0:48:33 :) 
nick = sectoid time = 26 0:48:43 так очень клево 
nick = swizard time = 26 0:49:0 осталось понять, правильно ли транслируется goto.lisp 
nick = sectoid time = 26 0:49:33 уже не 1 в 1 точно 
nick = swizard time = 26 0:49:40 блин а напишите кто-нибудь генератор листинга по sexp-ам :) 
nick = swizard time = 26 0:49:57 да, 1:1 не получается без отдельной стадии оптимизации 
nick = sectoid time = 26 0:50:18 там не тот sexp скорее всего 
nick = sectoid time = 26 0:50:23 в смысле исходный lisp 
nick = sectoid time = 26 0:50:35 а может и тот 
nick = sectoid time = 26 0:50:59 а так вообще похоже очень 
nick = sectoid time = 26 0:51:10 счас схачу печаталку сорца 
nick = turtle time = 26 0:52:14 Лейблы сделали? 
nick = swizard time = 26 0:52:51 лейблы пока напрямую работают 
nick = swizard time = 26 0:53:13 в смысле, для local.gcc и goto.gcc там нет адресов 
nick = turtle time = 26 0:53:13 Просто лейблом? Без адреса? 
nick = turtle time = 26 0:53:19 А, ну ладно. 
nick = turtle time = 26 0:53:24 Я как раз занимаюсь этим. 
nick = swizard time = 26 0:55:0 блин а чего эмулятору не нравится этот код: 
nick = swizard time = 26 0:55:2   LDF main<br />  AP 0<br />  RTN<br />main:<br />  DUM 2<br />  LDF GO<br />  LDF TO<br />  LDF gzz<br />  RAP 2<br />  RTN<br />gzz:<br />  LDC 1<br />  LD 0 0<br />  AP 1<br />  RTN<br />to:<br />  LDC 1<br />  LD 0 0<br />  SUB<br />  LD 0 1<br />  AP 1<br />  RTN<br />go:<br />  LDC 1<br />  LD 0 0<br />  ADD<br />  LD 0 2<br />  AP 1<br />  RTN<br />  RTN 
nick = turtle time = 26 0:55:25 Что говорит? 
nick = turtle time = 26 0:55:29 А, так лейблы же. 
nick = turtle time = 26 0:55:38 Он их не кушает. 
nick = swizard time = 26 0:55:51 а блин 
nick = swizard time = 26 0:56:31 а как мне руками посчитать адреса для этой программы? 
nick = swizard time = 26 0:56:43 мне просто эквивалентность бы сравнить 
nick = swizard time = 26 0:57:23 1 инструкция — это один байт? 
nick = sectoid time = 26 0:57:31 GCC&gt; (pretty-print-gcc (translate '(let ((body (lambda (x) (+ x x))))  (body 21))) t)<br /><br />    LDC 21<br />    LDF BODY<br />    AP 1<br />    RTN<br />LABEL:<br />    LD 0 0<br />    LD 0 0<br />    ADD<br />    RTN<br /> 
nick = sectoid time = 26 0:57:32 так? 
nick = sectoid time = 26 0:57:41 1 инструкия - 1 шаг 
nick = swizard time = 26 0:57:45 похоже вроде 
nick = sectoid time = 26 0:57:50 а, не так 
nick = sectoid time = 26 0:57:54 ну счас поправлю 
nick = sectoid time = 26 0:57:57 могу &quot;линковщик&quot; тоже написать 
nick = sectoid time = 26 0:58:17 GCC&gt; (pretty-print-gcc (translate '(let ((body (lambda (x) (+ x x))))  (body 21))) t)<br /><br />    LDC 21<br />    LDF BODY<br />    AP 1<br />    RTN<br />BODY:<br />    LD 0 0<br />    LD 0 0<br />    ADD<br />    RTN<br /> 
nick = swizard time = 26 0:58:17 который адреса пересчитывает? а напиши :) 
nick = sectoid time = 26 0:58:18 во 
nick = turtle time = 26 0:58:30 Я написал. 
nick = sectoid time = 26 0:58:31 сча, закоммичусь тока 
nick = turtle time = 26 0:58:33 Секунду. 
nick = swizard time = 26 0:58:34 так ок 
nick = sectoid time = 26 0:58:35 линковщик? 
nick = swizard time = 26 0:58:43 давайте может попробуем ветки помержить? 
nick = swizard time = 26 0:58:53 а то бардак какой-то 
nick = sectoid time = 26 0:59:9 свиз, давай в мастер притянем твой код 
nick = sectoid time = 26 0:59:14 он самый прогрессивный вроде 
nick = turtle time = 26 0:59:38 Можно и помержить. 
nick = swizard time = 26 0:59:40 ок, только напомните мне плз как в гите мержить :) 
nick = turtle time = 26 0:59:56 Я сам не с гитом на Вы. :) 
nick = swizard time = 26 1:0:8 ладно, ща нагуглим 
nick = turtle time = 26 1:0:24 В общем, кто лучше всех умеет в гите мержить - у меня в sel реализация if и размечивание. 
nick = sectoid time = 26 1:0:35 счас смержу 
nick = turtle time = 26 1:2:9 У меня не пушнулось было, оказывается. 
nick = turtle time = 26 1:2:14 Сейчас протолкнул. 
nick = turtle time = 26 1:2:16 Имей в виду. 
nick = sectoid time = 26 1:2:22 sel смержил 
nick = sectoid time = 26 1:2:27 сча домержу 
nick = turtle time = 26 1:2:30 Последний? ) 
nick = sectoid time = 26 1:2:58 счас домержу линкер 
nick = sectoid time = 26 1:3:5 и чуть-чуть правку внесу 
nick = swizard time = 26 1:3:43 а ты let-letrec-test в мастер смержил? 
nick = sectoid time = 26 1:4:34 еще нет 
nick = sectoid time = 26 1:4:39 счас там конфликтов до жопы будет 
nick = swizard time = 26 1:4:44 это да :( 
nick = sectoid time = 26 1:4:46 счас смержу что легко - и потом let-letrec 
nick = sectoid time = 26 1:5:16 туртл, я сделал твой анлабел опциональным. чтобы по-дефолту таки выдавался вариант для людей 
nick = turtle time = 26 1:6:16 Ну, главное, чтобы была возможность для машины вариант сделать. 
nick = sectoid time = 26 1:6:28 бранч sel смержен и прибит на сервере 
nick = sectoid time = 26 1:6:31 прибей у себя 
nick = turtle time = 26 1:6:45 Зачем прибивать? Пусть живёт. 
nick = turtle time = 26 1:6:50 Прибём ещё потом. 
nick = sectoid time = 26 1:7:13 просто захламляет выхлоп 
nick = sectoid time = 26 1:7:17 мерж-коммит есть 
nick = sectoid time = 26 1:7:21 где его мержили понятно 
nick = sectoid time = 26 1:7:28 а имя - просто меточка мозолящая глаза 
nick = sectoid time = 26 1:7:33 мержу let-letrec-test 
nick = turtle time = 26 1:10:21 https://github.com/icfpcontest2014/icfpcontest2014.github.io/commit/14fd40ff1bbf03a7b81f6c80b081f527a3acd1f2 
nick = swizard time = 26 1:10:40 блин там походу какие-то паразитные :RTN добавляются иногда  
nick = swizard time = 26 1:10:52 интересно, два RTN подряд как-то могут помешать? 
nick = sectoid time = 26 1:10:55 разберемся 
nick = sectoid time = 26 1:11:1 свиз, мона я домержу? 
nick = sectoid time = 26 1:11:5 и бум мучать мастер 
nick = swizard time = 26 1:11:12 да без проблем :) 
nick = swizard time = 26 1:11:30 я просто тут дебажу асм глазами пока 
nick = turtle time = 26 1:12:13 Так они же не два подряд по факту будут, наверное. 
nick = turtle time = 26 1:12:18 Это закрывающие. 
nick = turtle time = 26 1:12:26 А так если два подряд, то исполнится только один. 
nick = swizard time = 26 1:13:2 ну ок, если сходу косяк не найдётся, то и ничего страшного 
nick = sectoid time = 26 1:13:21 (pretty-print-gcc (translate '(let ((body (lambda (x) (+ x x))))  (body 21))) t)<br /><br />    LDC 21<br />    LDF BODY<br />    AP 1<br />    RTN<br />BODY:<br />    LD 0 0<br />    LD 0 0<br />    ADD<br />    RTN<br />NIL 
nick = sectoid time = 26 1:13:22 оно? 
nick = sectoid time = 26 1:13:32 вроде оно 
nick = swizard time = 26 1:13:43 если что, следующий фронт работ — это tail call elimination :) а то циклы у нас всё порушат 
nick = turtle time = 26 1:13:43 Ты там unlable вместо unlabel написал в ифе. 
nick = sectoid time = 26 1:13:53 GCC&gt; (pretty-print-gcc (translate '(let ((body (lambda (x) (+ x x))))  (body 21))<br />                                  :unlabel t) t)<br /><br />    LDC 21<br />    LDF 4<br />    AP 1<br />    RTN<br />    LD 0 0<br />    LD 0 0<br />    ADD<br />    RTN<br />NIL<br /> 
nick = sectoid time = 26 1:13:59 да знаю, счас пофикшу 
nick = sectoid time = 26 1:14:27 ловите апдейт 
nick = sectoid time = 26 1:15:26 хм. вот сучечки. они чинят в репе, а не чинят на веб-странице? 
nick = turtle time = 26 1:15:44 А куда ты translate-if дела? 
nick = sectoid time = 26 1:16:1 там был 
nick = turtle time = 26 1:16:14 Где? 
nick = sectoid time = 26 1:16:14 потерял? 
nick = sectoid time = 26 1:16:26 опс) 
nick = sectoid time = 26 1:16:27 счас) 
nick = turtle time = 26 1:16:29 Сейчас неу. :) 
nick = sectoid time = 26 1:17:3 вот потому и нужен тест-сьют( 
nick = sectoid time = 26 1:17:47 вернул 
nick = sectoid time = 26 1:17:53 рулесы тоже обновил в репе 
nick = sectoid time = 26 1:19:37 теперь надо привести в божеский вид компилятор в CL 
nick = swizard time = 26 1:21:18 ща попробую проверить экзамплы, и потом можно будет попробовать изобразить что-нибудь с ветвлением 
nick = swizard time = 26 1:21:32 хотя бы останов рекурсии, а то мы так ничего не напрограммируем :) 
nick = turtle time = 26 1:21:47 Хе-хе. :) 
nick = swizard time = 26 1:22:2 молниеносный раунд завтра в 16 заканчивается? 
nick = sectoid time = 26 1:22:28 в 16 по москве 
nick = sectoid time = 26 1:22:36 у вас уже полвторого? 
nick = swizard time = 26 1:22:43 ага 
nick = turtle time = 26 1:22:44 Претти-принт ещё не в мастере что ли? 
nick = sectoid time = 26 1:22:48 в мастере 
nick = sectoid time = 26 1:23:6 хм 
nick = sectoid time = 26 1:23:10 я же его добавлял 
nick = swizard time = 26 1:23:26 да, чёто нету 
nick = sectoid time = 26 1:23:29 а, не запушил 
nick = sectoid time = 26 1:23:29 сча 
nick = sectoid time = 26 1:24:6 ловите 
nick = sectoid time = 26 1:25:3 я переделаю asdf-систему чтобы в корне лежала и все компоненты грузила (gcc, ghc и проч.)? 
nick = swizard time = 26 1:25:13 давай! 
nick = turtle time = 26 1:25:29 Ты в чём пишешь? Скобку лишнюю оставил. 
nick = swizard time = 26 1:25:42 хотя gcc и ghc можно отдельными asdf-ами оставить 
nick = turtle time = 26 1:25:43 В util.lisp 
nick = swizard time = 26 1:25:51 а корневой пусть их требует 
nick = turtle time = 26 1:26:16 А вот непонятно. Если будем ghc реализовывать внутри gcc, то не хотелось бы два раза одно и то же писать. 
nick = sectoid time = 26 1:26:16 в емаксе я пишу 
nick = turtle time = 26 1:26:25 У тебя paredit есть? 
nick = sectoid time = 26 1:26:26 счас сделаю 
nick = sectoid time = 26 1:26:34 нету у меня paredit'а 
nick = turtle time = 26 1:26:41 Ну тогда понятно. 
nick = swizard time = 26 1:27:9 так у ghc вроде собственный транслятор 
nick = turtle time = 26 1:27:30 Собственный это куда? 
nick = swizard time = 26 1:27:34 или ты как-то абстрагировать таргеты хочешь, а парсер IL оставить? 
nick = turtle time = 26 1:27:40 У них и архитектура другая - там регистровая машина. 
nick = sectoid time = 26 1:28:2 парсер/обработчик  ghc надо на IL писать 
nick = sectoid time = 26 1:28:10 ибо работать с ним будет изнутри ботика 
nick = turtle time = 26 1:28:11 Просто я к тому, что нам, скорее всего, придётся просчёт гостов делать на лямбда-мене в gcc. 
nick = sectoid time = 26 1:28:18 да 
nick = sectoid time = 26 1:28:19 100% 
nick = sectoid time = 26 1:28:51 я хочу обобщить наш парсер IL чуток. разделить на фронт/бек и сделать помимо .gcc еще и common lisp бэк 
nick = swizard time = 26 1:29:55 тогда это на мультиметодах проще изобразить имхо 
nick = swizard time = 26 1:30:27 диспетчеризировать по параметру backend, например, все функции translate-* 
nick = sectoid time = 26 1:31:30 так и собирался 
nick = sectoid time = 26 1:31:41 счас только заборю asdf 
nick = sectoid time = 26 1:31:53 у меня тут под него подпорки стоят для старого продакшн-проекта 
nick = swizard time = 26 1:31:55 окей, я пока поотлаживаю goto.gcc 
nick = sectoid time = 26 1:32:7 кто-ниьт желает подумать на ИИ?) 
nick = swizard time = 26 1:32:19 с одной стороны он загрузился успешно (уже победа), с другой — не работает в конце :) 
nick = swizard time = 26 1:32:56 я желаю =), но пока надо доотладить транслятор, конечно  
nick = swizard time = 26 1:41:27 запушил в мастер багфикс транслятора, теперь goto.gcc заработал в эмуляторе 
nick = swizard time = 26 1:41:58 ну класс же, ща попробуем какой-нибудь цикл изобразить 
nick = swizard time = 26 1:44:13 эм 
nick = swizard time = 26 1:44:20 а чей if? :) 
nick = turtle time = 26 1:44:27 Что-то у меня претти принт не работает. 
nick = swizard time = 26 1:44:36 гляньте я там запушил gcc/examples/simple-loop.lisp 
nick = turtle time = 26 1:44:44 Ааа. 
nick = sectoid time = 26 1:45:0 а что говорит претти? 
nick = turtle time = 26 1:45:51 Да всё уже, разобрался. Думал stream по умолчанию на stdout выводит. 
nick = swizard time = 26 1:46:20 а можно его так и проинициализировать, кстати 
nick = swizard time = 26 1:46:32 а кто if писал, признавайтесь :) 
nick = swizard time = 26 1:46:35 помощь нужна 
nick = sectoid time = 26 1:46:38 turtle: добавь значение по-умолчанию 
nick = sectoid time = 26 1:46:41 туртл писал 
nick = turtle time = 26 1:46:49 Я писал. 
nick = turtle time = 26 1:47:9 Какая помощь нужна? 
nick = swizard time = 26 1:47:22 давай попробуем отдебажить на эмуляторе simple-loop.lisp 
nick = swizard time = 26 1:47:35 он как-то работает, но, почему-то, я не вижу результата 
nick = swizard time = 26 1:47:43 я ожидаю 16 
nick = swizard time = 26 1:47:53 а получаю 0 
nick = turtle time = 26 1:48:3 Давай попробуем. 
nick = turtle time = 26 1:48:18 У тебя уже есть версия скомпиленная? 
nick = swizard time = 26 1:48:35 да, конечно, ща 
nick = sectoid time = 26 1:48:36 turtle: поправил pretty-print 
nick = swizard time = 26 1:48:50     DUM 1<br />    LDF 9<br />    LDF 5<br />    RAP 1<br />    RTN<br />    LDC 0<br />    LD 0 0<br />    AP 1<br />    RTN<br />    LDC 16<br />    LD 0 0<br />    CGTE<br />    SEL 15 17<br />    LDC 1<br />    TSEL 23 23<br />    LD 0 0<br />    JOIN<br />    LDC 1<br />    LD 0 0<br />    ADD<br />    LD 1 0<br />    AP 1<br />    JOIN<br />    RTN<br /> 
nick = turtle time = 26 1:48:50 Я тоже поправил. Ну ладно. 
nick = swizard time = 26 1:50:31 там не может быть true с false перепутано? 
nick = swizard time = 26 1:50:33 (pretty-print-gcc (translate-file #p&quot;examples/simple-loop.lisp&quot; :unlabel nil) t) 
nick = sectoid time = 26 1:51:0 может возьмете минимальный пример? 
nick = swizard time = 26 1:51:25 типа просто бранч без всего? 
nick = swizard time = 26 1:51:28 ща попробуем 
nick = turtle time = 26 1:52:7 Так не ходит он в цикле. 
nick = sectoid time = 26 1:52:21 тупо (if 1 42 24) 
nick = turtle time = 26 1:52:24 Просто бранч работал, когда я смотрел. :) 
nick = sectoid time = 26 1:52:32 может я сломал... 
nick = turtle time = 26 1:52:39 Навряд ли. 
nick = turtle time = 26 1:52:46 Я смотрю, вроде норм. 
nick = turtle time = 26 1:52:58 Там либо с условием лажа, либо одно из двух. :) 
nick = turtle time = 26 1:53:10 swizard:  а IL там для этого кода какой? 
nick = swizard time = 26 1:53:12 ну вот смотри 
nick = swizard time = 26 1:53:14 (pretty-print-gcc (translate '(let ((f (lambda (x) (if (&gt;= x 16) 100 200)))) (f 0)) :unlabel t) t) 
nick = swizard time = 26 1:53:20 эмулятор мне показывает 100 
nick = swizard time = 26 1:53:28 хотя по-идее должно быть 200 
nick = turtle time = 26 1:54:5 Может, надо смотреть &gt;=? 
nick = swizard time = 26 1:54:21 а &gt;= чей? :) 
nick = turtle time = 26 1:54:49 Он спать пошёл. :) 
nick = turtle time = 26 1:55:0 Но там все операторы одинаковые, по идее. 
nick = sectoid time = 26 1:55:16 GCC&gt; (pretty-print-gcc (translate '(if 0 42 24) :unlabel t))<br />    LDC 0<br />    SEL 4 6<br />    LDC 1<br />    TSEL 8 8<br />    LDC 42<br />    JOIN<br />    LDC 24<br />    JOIN<br /> 
nick = sectoid time = 26 1:55:53     LDC 1<br />    TSEL 8 8<br />это зойчем? 
nick = swizard time = 26 1:56:49 а я похоже понял, там все сравнения через translate-op сделаны 
nick = swizard time = 26 1:56:56 а он порядок аргументов меняет 
nick = turtle time = 26 1:57:5 Может, у них баг? 
nick = swizard time = 26 1:57:6 ща проверим 
nick = turtle time = 26 1:57:25 По спеке загружается у, затем х. Сравниваетс х &gt;= у 
nick = sectoid time = 26 1:57:49 (defun translate-if (condition-form true-form false-form environment)<br />  (let ((true-label (gensym &quot;true&quot;))<br /> 	(false-label (gensym &quot;false&quot;))<br /> 	(end-label (gensym &quot;end&quot;)))<br />    `(,@(translate-walker condition-form environment)<br /> 	(:sel ,true-label ,false-label)<br /> 	(:ldc 1)<br /> 	(:tsel ,end-label ,end-label)<br /> 	(:label ,true-label)<br />        ,@(translate-walker true-form environment)<br /> 	(:join)<br /> 	(:label ,false-label)<br />        ,@(translate-walker false-form environment)<br />        (:join)<br /> 	(:label ,end-label)))) 
nick = sectoid time = 26 1:57:59 скажи, что тут делает <br /> 	(:ldc 1)<br /> 	(:tsel ,end-label ,end-label)<br />? 
nick = turtle time = 26 1:58:7 LDC 1<br />LDC 0<br />CGTE 
nick = swizard time = 26 1:58:10 блин, перемена операторов не помогает :) 
nick = turtle time = 26 1:58:12 Это безусловный переход. 
nick = sectoid time = 26 1:58:25 а зачем он там? 
nick = turtle time = 26 1:58:38 Чтобы в конец убежать. 
nick = turtle time = 26 1:58:49 Он же с веток join'ом возвращается. 
nick = sectoid time = 26 1:59:12 а 
nick = sectoid time = 26 1:59:17 я сосунлей( 
nick = turtle time = 26 1:59:33 Похоже, симулятор у них не без грешка. Или меня глючит. 
nick = swizard time = 26 1:59:35 а не туплю 
nick = swizard time = 26 2:0:9 короче надо так 
nick = swizard time = 26 2:0:10 -    ((= ?form-a ?form-b) (translate-op :ceq ?form-a ?form-b env))<br />-    ((&gt; ?form-a ?form-b) (translate-op :cgt ?form-a ?form-b env))<br />-    ((&gt;= ?form-a ?form-b) (translate-op :cgte ?form-a ?form-b env))<br />+    ((= ?form-a ?form-b) (translate-op :ceq ?form-b ?form-a env))<br />+    ((&gt; ?form-a ?form-b) (translate-op :cgt ?form-b ?form-a env))<br />+    ((&gt;= ?form-a ?form-b) (translate-op :cgte ?form-b ?form-a env)) 
nick = swizard time = 26 2:0:15 запушил 
nick = turtle time = 26 2:0:16 CGTE если смотреть на симуляторе, то пере вызовом 0 наверху. Это у. Т.е. у=0, х=1 
nick = turtle time = 26 2:0:28 А, ну да, тогда правильно возвращает 1. 
nick = swizard time = 26 2:0:31 ща проверим цикл 
nick = swizard time = 26 2:1:1 whoohoo 
nick = swizard time = 26 2:1:3 работает :) 
nick = sectoid time = 26 2:1:6 хехехе 
nick = swizard time = 26 2:1:19 ну всё, можно сделать перерыв на пожрать =) 
nick = turtle time = 26 2:1:32 Мини победа. :) 
nick = sectoid time = 26 2:1:36 потому надо звать их не a/b, а lhs/rhs 
nick = sectoid time = 26 2:1:43 ну или l r ;) 
nick = sectoid time = 26 2:1:47 приятного) 
nick = turtle time = 26 2:1:54 Приятного, да. 
nick = swizard time = 26 2:2:14 а кто там тесты грозился написать? :) надо бы списки и туплы проверить, что работают 
nick = swizard time = 26 2:2:22 и можно к ai приступать  
nick = swizard time = 26 2:2:27 без TCO пока 
nick = swizard time = 26 2:2:33 ээ 
nick = swizard time = 26 2:2:39 короче без хвостовой рекурсии пока 
nick = swizard time = 26 2:2:58 но спеку про неё я щас зачитаю в процессе 
nick = sectoid time = 26 2:3:11 хвост прикрутим 
nick = sectoid time = 26 2:3:22 как вариант можно сделать будет какие-то спец-узлы в АСТ 
nick = sectoid time = 26 2:3:30 чтобы оптимизатор полновесный не писать 
nick = sectoid time = 26 2:4:25 я опять задумался, а нужен ли CL-бэкенд. может скорее нужен симулятор? 
nick = swizard time = 26 2:4:39 не ну по-сути у нас пока настолько убогий IL, что TCO можно тупо через TSEL только для циклов изобразить 
nick = turtle time = 26 2:4:43 Ты пушить будешь? 
nick = sectoid time = 26 2:4:57 turtle: кому вопрос? 
nick = turtle time = 26 2:5:1 Свизарду. 
nick = swizard time = 26 2:5:21 а сорри 
nick = swizard time = 26 2:5:27 не заметил что гит обломался 
nick = turtle time = 26 2:5:31 А то он сейчас кушать, думаю подредактировать немного унлабелинг. 
nick = turtle time = 26 2:5:45 Чтобы выводил с номером куда прыгать собирается. 
nick = turtle time = 26 2:5:51 С комментом. 
nick = sectoid time = 26 2:6:7 надо добавить узлов вида: (trace something) 
nick = swizard time = 26 2:6:7 готово 
nick = sectoid time = 26 2:6:10 и (break) 
nick = swizard time = 26 2:6:30 брейк не нужен, можно прямо в асм воткнуть инструкцию DBG в эмуляторе 
nick = swizard time = 26 2:6:35 хотя может и нужен 
nick = swizard time = 26 2:6:49 ладно, я brb пока 
nick = turtle time = 26 2:12:4 Как будем библиотечный код оформлять? 
nick = turtle time = 26 2:12:45 Надо бы макросню какую-нибудь забубенить. 
nick = turtle time = 26 2:12:55 По идее, and будет выражаться через mul. 
nick = turtle time = 26 2:13:16 Но если вызовом функции сфигачим, то получим больше кода.  Хотя, можно и так, наверное. 
nick = sectoid time = 26 2:13:41 дык defmacro аще наш друг и соратник 
nick = sectoid time = 26 2:26:30 https://bitbucket.org/skobochka/icfpc-2014/commits/86d6c791130a856a393ab7182fbdd2c1cf35d05f?at=master 
nick = swizard time = 26 2:34:9 вернулся  
nick = swizard time = 26 2:34:14 как тут дела :) 
nick = sectoid time = 26 2:34:40 отделяю бэкенд от фронтенда, пилю cl-бэкенд 
nick = turtle time = 26 2:34:50 В раздуьмях. Сектоид там бранч создал и фигачит бэкенды и фронтенды. :) 
nick = swizard time = 26 2:34:54 а этой чей коммит в util.lisp: 
nick = swizard time = 26 2:34:55 ; caught STYLE-WARNING:<br />;   &amp;OPTIONAL and &amp;KEY found in the same lambda list: (GCC &amp;OPTIONAL<br />;                                                      (STREAM *STANDARD-OUTPUT*)<br />;                                                      &amp;KEY (MINIMIZE NIL))<br /> 
nick = swizard time = 26 2:35:8 поправить? 
nick = sectoid time = 26 2:35:12 поправь 
nick = sectoid time = 26 2:35:26 сектоид в раздумьях: а не делает ли он пургу? 
nick = turtle time = 26 2:35:55 Мой коммит был. 
nick = swizard time = 26 2:36:11 я вот что думаю 
nick = turtle time = 26 2:36:19 swizard: у тебя там функции не хранятся как переменные? 
nick = turtle time = 26 2:36:27 Что? 
nick = swizard time = 26 2:36:45 раз у нас как-то заработал IL, то можно потихоньку начинать писать бота — это тоже задача та ещё 
nick = swizard time = 26 2:36:59 например, вычитать из карты нужную клетку 
nick = sectoid time = 26 2:37:8 это хелперы 
nick = turtle time = 26 2:37:12 Надо подумать как сделать библиотечные функции. 
nick = turtle time = 26 2:37:19 Где их будем держать, как подгружать. 
nick = sectoid time = 26 2:37:32 можно сделать их макрами, можно сделать функциями 
nick = sectoid time = 26 2:37:36 что нам больше нравится? 
nick = swizard time = 26 2:37:41 ну на IL никак не сделать, там щас строго (let/letrec ((proc (lambda (… 
nick = swizard time = 26 2:38:0 лучше функциями на IL, конечно :) 
nick = sectoid time = 26 2:38:5 ессно на IL 
nick = swizard time = 26 2:38:7 ассемблер короче будет 
nick = sectoid time = 26 2:38:8 но вопрос как 
nick = sectoid time = 26 2:38:14 можно макрами 
nick = sectoid time = 26 2:38:19 и будет такой себе шитый код 
nick = sectoid time = 26 2:38:26 шустрый и огромный 
nick = swizard time = 26 2:39:22 да, но что-то мне подсказывает, что опкоды экономить нужно :) 
nick = sectoid time = 26 2:39:29 угу 
nick = swizard time = 26 2:39:32 ладно давайте тогда так сделаем 
nick = swizard time = 26 2:39:55 я ща пойду прогуляюсь пока минут на двадцать, а то чёто вся туша уже болит в одном положении сидеть 
nick = swizard time = 26 2:40:7 а потом приду и попробую мини-бота на IL сделать 
nick = sectoid time = 26 2:40:27 давай. может ходящего по кругу? 
nick = swizard time = 26 2:40:58 не, это ничем не лучше ходящего до упора вправо :) 
nick = swizard time = 26 2:41:8 хотя бы минимального, чтобы на препятствия смотрел 
nick = turtle time = 26 2:41:8 Нам бы always-down.lisp для начала научиться компилировать. 
nick = turtle time = 26 2:41:15 Он как раз почти такой. 
nick = swizard time = 26 2:41:58 always-down вообще не вопрос, его только переписать на let/letrec надо 
nick = swizard time = 26 2:42:0 ща сделаю 
nick = sectoid time = 26 2:42:8 а чего нам там не хватает? 
nick = swizard time = 26 2:42:25 там вложенные define, мы же от них отказались 
nick = sectoid time = 26 2:45:30 (eval (translate-cl '(if (+ 1 2) 42 24))) 
nick = sectoid time = 26 2:45:35 42<br /> 
nick = sectoid time = 26 2:45:48 cl-бэкенд это чудесно 
nick = swizard time = 26 2:45:58 а функции? 
nick = sectoid time = 26 2:46:8 он тривиален выходит%) 
nick = sectoid time = 26 2:46:13 счас доделаю - пушну 
nick = swizard time = 26 2:48:38 а почему при :unlabel nil у меня лейблы всё равно закомментированы? :) 
nick = turtle time = 26 2:49:34 Недоработка. :) 
nick = turtle time = 26 2:49:43 Ну там всё равно на них, закомментированы или нет. 
nick = swizard time = 26 2:51:50 я запушил always-down.lisp, теперь его можно скомпилировать 
nick = swizard time = 26 2:51:56 вроде эмулятор жрёт 
nick = turtle time = 26 2:52:59 Мда, код, конечно... 
nick = sectoid time = 26 2:53:22 а у нас let/letrec жрет только лямбды? 
nick = turtle time = 26 2:53:51  Trace output<br />lambdaman program (initialisation function) returned wrong result type<br />lambdaman program (initialisation function) returned wrong result type<br />lambdaman program (step function) faulted IllegalAddr<br />lambdaman program (step function) faulted IllegalAddr 
nick = turtle time = 26 2:53:54 Пичаль. :) 
nick = swizard time = 26 2:54:15 да, let/letrec только лямбды 
nick = sectoid time = 26 2:54:24 недоработка?) или мы так и хотим? 
nick = turtle time = 26 2:54:39 Так не (init) то, наверное, а просто init? 
nick = swizard time = 26 2:54:51 по-сути, можно добавить и переменные, но это не горит, пока можно биндинги функциями делать 
nick = turtle time = 26 2:54:58 Даже, наверное, просто лямбду вернуть. 
nick = swizard time = 26 2:55:17 для эмулятора скорее (init 0 0) 
nick = swizard time = 26 2:55:30 ему же добавить переменных надо 
nick = turtle time = 26 2:55:45 Нам же надо функцию вернуть. 
nick = turtle time = 26 2:55:51 Т.е. CLOSURE. 
nick = sectoid time = 26 2:56:29 по идее let/letrec должен делать скоуп и биндить то, что ему дали 
nick = swizard time = 26 2:56:29 не, в always-down.gcc там конс возвращают 
nick = sectoid time = 26 2:56:42 а что уже пришло - то rhs должен решать 
nick = turtle time = 26 2:56:52 А, ну конс. Но в одном из консов - closure. 
nick = swizard time = 26 2:56:59 ну так и происходит 
nick = turtle time = 26 2:57:12 Да нет же ж. 
nick = swizard time = 26 2:57:15 step — это функция 
nick = turtle time = 26 2:57:58 init - тоже функция. 
nick = turtle time = 26 2:58:5 Как в гите отревертить файл? 
nick = sectoid time = 26 2:58:12 отревертить на что? 
nick = sectoid time = 26 2:58:14 на HEAD? 
nick = turtle time = 26 2:58:55 Да, отревертил уже. 
nick = sectoid time = 26 2:59:0 top-level у нас:<br />(lambda (world-state ghost-prog)<br />   ...<br />   (cons ai-state step-fn)) 
nick = sectoid time = 26 2:59:16 turtle: ты емакс юзаешь? 
nick = turtle time = 26 2:59:26 Да, емакс. 
nick = sectoid time = 26 2:59:40 советую попробовать magit 
nick = sectoid time = 26 2:59:48 самая удобная морда к гиту, из всех что я видел 
nick = turtle time = 26 2:59:54 Да я как-то редко с гитом. 
nick = swizard time = 26 3:0:9 так, вот такое порождает правильный код с одним багом: 
nick = swizard time = 26 3:0:10 (letrec ((step (lambda (ai-state world-state)<br />                 (cons (+ ai-state 1) 2))))<br />  (let ((init (lambda (initial-state unknown)<br />                (cons 42 step))))<br />    (init 0 0)))<br /> 
nick = swizard time = 26 3:0:36 там перепутан номер фрейма для ld почему-то для функции step 
nick = turtle time = 26 3:0:56 Ну баг багом, но возращать должен то он функцию main. 
nick = swizard time = 26 3:1:3 если руками изменить LD 2 0 на LD 1 0, то всё ок… ща попробую пофиксить 
nick = swizard time = 26 3:1:19 а он её и возвращает, просто это не main, а init 
nick = turtle time = 26 3:1:20 For LAMBDAMAN, main is a function with two arguments: 
nick = swizard time = 26 3:1:30 смотри 
nick = turtle time = 26 3:1:34 Ну init, main, да. 
nick = swizard time = 26 3:1:41 он не должен возвращать функцию main 
nick = sectoid time = 26 3:1:56 ребят, мне доделывать common lisp backend или счас лучше вам помочь? 
nick = turtle time = 26 3:1:59 А, понял. 
nick = swizard time = 26 3:2:4 весь код должен быть такой, чтобы к нему орги добавили LDC 0, LDC 0 допустим, и оно заработало 
nick = swizard time = 26 3:2:21 тоесть  положить на стек initial-state unknown 
nick = swizard time = 26 3:2:30 и пустить интерпретацию 
nick = sectoid time = 26 3:3:30 а он разве со стека берет? 
nick = swizard time = 26 3:3:34 а давайте прикинем, что нам нужно вообще сделать до lightning round 
nick = swizard time = 26 3:3:37 да со стека 
nick = swizard time = 26 3:3:45 можешь глянуть always-down.gcc 
nick = swizard time = 26 3:4:15 там LDF init / RAP 
nick = sectoid time = 26 3:4:16 счас, закоммичусь в бранч и наверное помогу вам 
nick = sectoid time = 26 3:5:5 пушнул бранч 
nick = sectoid time = 26 3:5:13 там Броукен, его пока не мержить 
nick = sectoid time = 26 3:6:6 да, ему и правда приходит в стеке... 
nick = sectoid time = 26 3:8:9 а может и нет... 
nick = sectoid time = 26 3:8:13 нифига 
nick = sectoid time = 26 3:8:45 ему приходит в LD 0 0/LD 0 1 
nick = sectoid time = 26 3:9:2 я их дампал, когда реверсил что приходит в undocumented 
nick = swizard time = 26 3:9:26 но это же инструкции, которые кладут содержимое двух переменных на стек :) 
nick = swizard time = 26 3:9:33 так что всё правильно вроде 
nick = sectoid time = 26 3:10:53 свиз, я имею в виду, что для того, чтобы сдампать 1 и 2 параметр в трейс я сделал в начале кода бота вот такое:<br />LD 0 0<br />DBUG<br />LD 0 1<br />DBUG 
nick = sectoid time = 26 3:11:5 т.е. я загрузил параметры из энва на стек 
nick = sectoid time = 26 3:11:8 чтобы сдампать 
nick = sectoid time = 26 3:11:29 т.е. система инициализации AI передает их таки фреймом 
nick = swizard time = 26 3:11:57 а как тогда будет работать оригинальный always-down.gcc? 
nick = swizard time = 26 3:12:13 он явно ждёт значения на стеке 
nick = sectoid time = 26 3:12:15 а он их просто игнорирует) 
nick = sectoid time = 26 3:12:40 он ничего не ждет на стеке, кстате 
nick = sectoid time = 26 3:12:41   DUM  2        ; 2 top-level declarations<br />  LDC  2        ; declare constant down<br />  LDF  step     ; declare function step <br />  LDF  init     ; init function<br />  RAP  2        ; load declarations into environment and run init<br /> 
nick = sectoid time = 26 3:12:51 DUM 2 - созда пустой фрейм на 2 значения 
nick = sectoid time = 26 3:13:52 init != main 
nick = swizard time = 26 3:14:15 ну окей, а как тогда правильно 
nick = sectoid time = 26 3:14:17 main == адрес 0. т.е. весь always-down.gcc и есть тело main 
nick = sectoid time = 26 3:14:27 смотри 
nick = sectoid time = 26 3:14:35 ai.gcc грузится в память 
nick = sectoid time = 26 3:14:37 начиная с 0 
nick = sectoid time = 26 3:14:50 дальше взводится 0 энвайрмент - 2 значениями 
nick = sectoid time = 26 3:14:55 и управление передается на адрес 0 
nick = sectoid time = 26 3:15:17 в примере always-down.gcc он на эти параметры (в 0 энвайрменте) просто забивает 
nick = swizard time = 26 3:16:24 тоесть, чтобы получить initial-world-state мне надо что? LD 0 0 ? 
nick = sectoid time = 26 3:16:28 нам нужен еще какой-то top-level form в IL 
nick = sectoid time = 26 3:16:40 LD 0 0, да 
nick = sectoid time = 26 3:16:51 чтобы получить ghost-progs -- LD 0 1 
nick = swizard time = 26 3:18:38 ага, и, соответственно, после DUM 2 адреса тоже сдвинутся на 2 
nick = swizard time = 26 3:18:40 хм 
nick = sectoid time = 26 3:19:10 ну, после DUM 2, надо брять уже LD 1 0 и LD 1 1 
nick = swizard time = 26 3:19:11 ок можно внести это в топлевел 
nick = sectoid time = 26 3:19:17 (translate '(lambda (x y)<br />              (+ x y)) :unlabel nil) 
nick = sectoid time = 26 3:19:24 нам вот такое бы уметь транслировать 
nick = sectoid time = 26 3:19:33 получать то самое глядское тело лямбды 
nick = sectoid time = 26 3:19:49 вот только во что... 
nick = sectoid time = 26 3:19:59 собсно такая конструкция просто меняет скоуп 
nick = sectoid time = 26 3:20:9 говорит транслятору что надо иначе выполнять разрешение имен 
nick = swizard time = 26 3:20:11 да оно уже умеет транслироваться, в принципе-то 
nick = swizard time = 26 3:20:19 ладно, ща я попробую это организовать 
nick = sectoid time = 26 3:20:22 надо вынести в translate-walker 
nick = sectoid time = 26 3:22:21 получается у нас let/letrec должен именовать переменные, а lambda собсно творить кложуры 
nick = sectoid time = 26 3:22:23 по-моему так) 
nick = sectoid time = 26 3:23:34 у нас в IL у if else-value обязательное? 
nick = sectoid time = 26 3:23:47 в смысле мы точно хотим сделать его обязательным? 
nick = swizard time = 26 3:24:20 не знаю, надо смотреть, как оно транслируется в асм 
nick = sectoid time = 26 3:24:48 я как раз хочу предложить более короткую asm-форму 
nick = sectoid time = 26 3:24:54 через TSEL 
nick = sectoid time = 26 3:28:48 чтот я уже туплю... 
nick = swizard time = 26 3:29:30 я запушил новый вариант always-down.lisp и вариант с toplevel form 
nick = swizard time = 26 3:29:54 теоретически, должно получиться что надо, если в env уже лежат два параметра для main 
nick = turtle time = 26 3:30:17 &quot;у нас в IL у if else-value обязательное?&quot; - это про что? 
nick = swizard time = 26 3:30:25 ладно, окей, тогда предлагаю на этом моменте сделать паузу на сон, например :) 
nick = turtle time = 26 3:30:31 Не вижу пуша. 
nick = sectoid time = 26 3:30:38 похоже счас у нас (if cond then else) 
nick = turtle time = 26 3:30:43 Да. 
nick = sectoid time = 26 3:30:45 может (if cond then &amp;optional else)? 
nick = sectoid time = 26 3:30:53 тогда мона оптимизнуть неплохо через tsel 
nick = turtle time = 26 3:31:1 МОжно так. в транслейт просто форму добавить. 
nick = swizard time = 26 3:31:9 теперь пуш должен пройти 
nick = sectoid time = 26 3:34:33 возможно действительно стоит поспать 
nick = turtle time = 26 3:34:34 Мда. 
nick = turtle time = 26 3:34:40 Нафига LD 0 0 в начале? 
nick = sectoid time = 26 3:34:49 не знаю) 
nick = turtle time = 26 3:34:52 Да, надо бы поспать. Пусть grepz с утра разбирается. :) 
nick = swizard time = 26 3:34:56 обновись ещё раз :) 
nick = swizard time = 26 3:35:16 LD 0 0 / LD 0 1 я сделал только для top-level lambda 
nick = swizard time = 26 3:35:23 типа это main 
nick = turtle time = 26 3:35:28 Всё равно. 
nick = turtle time = 26 3:35:36 Та оно же для программы не нужно. 
nick = sectoid time = 26 3:36:6 свиз 
nick = sectoid time = 26 3:36:9 не надо паддить 
nick = sectoid time = 26 3:36:20 надо было просто дать возможность делать lambda - top-leve 
nick = turtle time = 26 3:36:21 Короче, не работает. 
nick = sectoid time = 26 3:36:21 l 
nick = swizard time = 26 3:36:34 ну я вроде так и сделал? 
nick = swizard time = 26 3:36:49 последний самый пуш 
nick = sectoid time = 26 3:37:27 GCC&gt; (translate '(lambda (x y)<br />              (+ x x)) :unlabel nil)<br />((:LD 0 0) (:LD 0 0) (:ADD) (:RTN))<br /> 
nick = sectoid time = 26 3:37:37 вот так должно быть 
nick = turtle time = 26 3:37:52 Да не должно так быть, имхо. 
nick = sectoid time = 26 3:37:52 паддить вообще ничего не надо) 
nick = sectoid time = 26 3:38:0 почему не должно? 
nick = turtle time = 26 3:38:3 LDC  0<br />LDF  4<br />CONS<br />RTN<br />LDC  0<br />LDC  1<br />CONS<br />RTN<br /> 
nick = swizard time = 26 3:38:8 окей, убрал 
nick = turtle time = 26 3:38:9 Вот, например, простейший бот. 
nick = sectoid time = 26 3:38:17 это что? 
nick = turtle time = 26 3:38:19 Аналог always-down по фунционалу. 
nick = sectoid time = 26 3:38:24 и? 
nick = sectoid time = 26 3:38:31 у него (lambda () ...) 
nick = turtle time = 26 3:38:53 Я к тому, что он при старте из фрейма ничего не читает и не должен. 
nick = sectoid time = 26 3:38:56 ((:LDC 2) (:LDC 1) (:ADD) (:RTN)) 
nick = sectoid time = 26 3:39:16 ну, если его не интересует world-state/ghost-state - не должен 
nick = sectoid time = 26 3:39:42 а если интересуют - таки должен почитать. ибо эти параметры в main приходят в 0 фрейме 
nick = swizard time = 26 3:39:51 а щас правильно, глянь? 
nick = turtle time = 26 3:40:2 Нет, неправильно. 
nick = turtle time = 26 3:40:7 Или ты ещё коммитил? 
nick = sectoid time = 26 3:40:16 ага, оно 
nick = swizard time = 26 3:40:19 в мастер закоммитил 
nick = sectoid time = 26 3:40:24 счас все как надо 
nick = turtle time = 26 3:40:27 Нет, неправильно. 
nick = turtle time = 26 3:40:32 Оно не работает просто. 
nick = turtle time = 26 3:40:37 Ну, начало нормальное. 
nick = sectoid time = 26 3:40:40 что именно не работает? 
nick = swizard time = 26 3:40:41 где не работает? 
nick = turtle time = 26 3:40:57 LD 1 1 отваливается сразу же. 
nick = swizard time = 26 3:41:16 ну правильно, там же ничего не лежит при старте эмулятора 
nick = swizard time = 26 3:41:29 предполагается, что там должен быть undocumented параметр 
nick = sectoid time = 26 3:41:36 turtle ты на каком эмуляторе пробуешь? 
nick = swizard time = 26 3:41:44 по крайней мере, sectoid так говорит :) 
nick = turtle time = 26 3:41:45 http://icfpcontest.org/game.html 
nick = sectoid time = 26 3:41:56 да, на этом надо 
nick = turtle time = 26 3:41:57 Нет, норм сейчас. 
nick = sectoid time = 26 3:42:0 счас проверю 
nick = turtle time = 26 3:42:2 Вдиать, что-то не то копировал. 
nick = sectoid time = 26 3:43:1 работает 
nick = sectoid time = 26 3:43:6 все мы походу устали 
nick = sectoid time = 26 3:43:11 swizard герой дня)  
nick = swizard time = 26 3:43:18 хех 
nick = swizard time = 26 3:43:27 ладно, пошли спать 
nick = swizard time = 26 3:43:41 напишите кто-нибудь grepz вкрадце на чём мы остановились :) 
nick = turtle time = 26 3:43:43 Да, точняк. 
nick = sectoid time = 26 3:43:45 так-с, нам по сути остается попробовать написать простой AI на этом лиспе и собрать его корректно в GCC 
nick = turtle time = 26 3:44:0 Нам надо ещё стандартную библиотеку к нему наклепать. 
nick = turtle time = 26 3:44:9 Которые будут улучшать и облегчать жизнь. 
nick = sectoid time = 26 3:44:11 я бы начал с тупо перебирающего R, D, L, U направления 
nick = sectoid time = 26 3:44:16 да, нужна библиотека 
nick = sectoid time = 26 3:44:34 хм. может счас выдавлю из себя еще каркас для ее создания 
nick = sectoid time = 26 3:44:45 мысль: макра вроде defun/gcc 
nick = sectoid time = 26 3:44:55 которая пихает AST в какой-нить список 
nick = sectoid time = 26 3:45:17 и потом когда мы делаем парс - допиливаем библиотечные функции к основному AST (линкуем либу, гыгы) 
nick = swizard time = 26 3:45:46 оформи тогда эту идею в репо, где-нибудь в TODO, может, grepz сделает 
nick = sectoid time = 26 3:45:46 перед фазой unlabel 
nick = sectoid time = 26 3:46:4 счас если после сигареты не буду чувствовать сил - так и сделаю 
nick = sectoid time = 26 3:46:12 а у кого пишутся логи конфы? 
nick = swizard time = 26 3:46:21 не знаю, у меня все похерились :) 
nick = sectoid time = 26 3:46:21 может лог в реп закоммитить? 
nick = sectoid time = 26 3:46:30 по кр. мере прошедших суток 
nick = swizard time = 26 3:46:40 у Азамата вроде полный лог на машине 
nick = turtle time = 26 3:46:49 Да, полный. 
nick = sectoid time = 26 3:46:54 можешь его в реп 
nick = swizard time = 26 3:46:56 закоммитишь? 
nick = sectoid time = 26 3:47:0 в какую-нить директорию log/ 
nick = sectoid time = 26 3:47:9 пригодится для репорта) 
nick = turtle time = 26 3:47:9 Ага. 
nick = swizard time = 26 3:47:17 отлично, спасибо 
nick = swizard time = 26 3:47:28 ладно, до завтра  
nick = swizard time = 26 3:47:37 я надеюсь часам к 10 — 11 встать 
nick = sectoid time = 26 3:48:12 аналогично, но по киеву 
nick = sectoid time = 26 3:48:40 и эта. когда закончится военная заворушка, хочу всех напоить пивом) 
nick = swizard time = 26 3:49:8 обязательно :) 
nick = swizard time = 26 3:49:27 всё. я убрёл 
nick = turtle time = 26 3:49:47 Я тоже упал. Логи закоммитил. Но они в таком формате, xml-ном. :) 
nick = sectoid time = 26 4:9:6 2 grepz: я добавил простую систему управления библиотечными функциями (см. https://bitbucket.org/skobochka/icfpc-2014/commits/3ba6f95b145baf761545f1a2300d19921274c344) 
nick = sectoid time = 26 4:10:9 надо сделать набор helper'функций для:<br />1. разбора состояния мира (карта, здоровье и т.п.)<br />2. для разбора состояния ЛМ и призраков<br /><br />эти хелперы нам очень пригодятся когда будем писать AI 
nick = sectoid time = 26 4:10:19 ну и стоит подумать над алгоритмами AI 
nick = sectoid time = 26 4:10:31 логи того что мы напридумывали-набеседовали - в репе 
nick = sectoid time = 26 4:10:43 я ушел спать, попробую встать не позже 10-11 по киеву 
nick = grepz time = 26 10:31:37 Я тут параллельно на работе, но вроде вкурил всё что вы за вчера сделали, одного непонимаю, почему при трансляции letrec зачем оно помимо задания самой функции ещё и её вызов делает(LDF)? 
nick = turtle time = 26 11:54:38 &quot;The program for Lambda-Man´s AI was limited to 1048576 instructions.&quot; 
nick = turtle time = 26 11:54:43 Начались ограничения. 
nick = grepz time = 26 11:59:25 стоило ожидать 
nick = grepz time = 26 12:6:7 у нас рекурсивные вызовы делать же нельзя? 
nick = turtle time = 26 12:7:58 Вроде без всяких оптимзаций можно. 
nick = grepz time = 26 12:8:24 непохоже, но может я где-то косячу 
nick = grepz time = 26 12:8:38 не убирает лейбл внутри вызова функции 
nick = grepz time = 26 12:13:18 я там выложил расшифровку состояния мира: world-state.sample и l-man.lisp, где стаб для управления человечком 
nick = swizard time = 26 12:15:56 привет всем 
nick = grepz time = 26 12:16:2 Привет 
nick = turtle time = 26 12:16:5 Привет. 
nick = swizard time = 26 12:17:23 ща я быстро позавтракаю, почитаю коммиты пока 
nick = turtle time = 26 12:18:40 Да там их нет. Я сам минут 15-20 назад проснулся. 
nick = grepz time = 26 12:18:42 С утра какой-то глюк в их симуляторе был, спейсы в псевдоассемблере не воспринимал, сейчас починили уже 
nick = swizard time = 26 12:20:4 надо знаете чего, накидать хелперы для работы со списками  
nick = swizard time = 26 12:20:17 хотя бы размер карты узнать 
nick = swizard time = 26 12:21:4 а по-возможности и клетку получить по её координате 
nick = swizard time = 26 12:22:10 тогда можно написать функцию типа call-with-env, которая будет вызывать коллбек с 4 параметрами — клетками справа/вверху/лева/внизу 
nick = swizard time = 26 12:22:53 рекурсивные вызовы должны работать, я вчера проверял — можно глянуть gcc/examples/simple-loop.lisp 
nick = grepz time = 26 12:23:12 ок, значит я где-то накасячил 
nick = swizard time = 26 12:24:4 а что будет, кстати, если cdr ячейки сравнить с «0», а там cons? 
nick = swizard time = 26 12:24:13 в смысле, как конец списка искать? 
nick = grepz time = 26 12:24:37 должно ноль наверное вернуть - пустой список 
nick = grepz time = 26 12:24:51 The empty list is encoded as the integer 0. 
nick = grepz time = 26 12:25:45 затем и нужна инструкция ATOM(integerp) 
nick = grepz time = 26 12:25:52 чтобы не сравнивать список с интами 
nick = grepz time = 26 12:25:54 я так думаю 
nick = swizard time = 26 12:27:38 во точно, атом 
nick = swizard time = 26 12:27:53 сделаете кто-нибудь? :) 
nick = grepz time = 26 12:28:26 у нас уже был вроде 
nick = grepz time = 26 12:28:38 я сейчас проверю как это работает 
nick = grepz time = 26 12:28:41 найду размеры карты 
nick = swizard time = 26 12:30:31 давай! 
nick = grepz time = 26 12:36:4 progn у нас нет? 
nick = swizard time = 26 12:36:27 неа, а зачем он тебе понадобился, кстати? 
nick = swizard time = 26 12:36:38 мы вчера думали над его целесообразностью 
nick = swizard time = 26 12:37:9 вроде бы решили, что без побочных эффектов он не нужен 
nick = turtle time = 26 12:37:16 deflib/gcc move - что там за число 11? 
nick = grepz time = 26 12:37:19 если подумать, то можно вобщем и без него, всё верно 
nick = grepz time = 26 12:37:36 11 - координата 
nick = grepz time = 26 12:37:46 л-ман туда-сюда будет дёргаться 
nick = grepz time = 26 12:38:0 так как в одном случае у него условие выполяется, в другом нет, просто как пример 
nick = turtle time = 26 12:38:20 Нам бы эти 3, 1 перевести в нормальный читаемый вариант. :) 
nick = turtle time = 26 12:38:35 Что у нас с топлевел енвайронментом? 
nick = grepz time = 26 12:39:10 надо, я сейчас отпинаюсь от работы смогу что-то более-менее нормально запилить.<br />Проверил нахождение размера карты через cdr и integerp - всё как говорилось, работает 
nick = swizard time = 26 12:39:26 turtle: 3 1 без проблем вообще, добавь в translate-walker паттерны типа :down :left :right :bottom 
nick = turtle time = 26 12:39:49 Кстати, да, можно вообще туда их захардкодить. 
nick = grepz time = 26 12:39:52 там ещё вы убрали условие из translate-op, я его опять ввёл, чтобы сущности не плодить, когда оп с 1 параметром, второй просто не подставляется. 
nick = grepz time = 26 12:40:25 иначе cdr/car/integerp работать не будут 
nick = swizard time = 26 12:40:53 ну мы не то, чтобы его убрали, видимо, при мерже у sectoid’a бранчей в мастер что-то потерялось 
nick = grepz time = 26 12:41:26 ясно, а то я сегодня вдуплял долго почему у меня выражение валилось с ошибкой, пока по косточкам до car не добрался. :) 
nick = swizard time = 26 12:42:16 да блин, тесты надо написать, но никто не хочет :) 
nick = swizard time = 26 12:42:29 grepz, п 
nick = swizard time = 26 12:42:44 а ты закоммитил хелпер по размерам харты? 
nick = grepz time = 26 12:43:21 не, пока не комитил, я на работе зависаю, так что отвлекаться приходится 
nick = swizard time = 26 12:43:32 окей 
nick = swizard time = 26 12:43:52 ладно, надо бы что-то спрограммировать бы до 16 часов 
nick = swizard time = 26 12:44:42 а такой вопрос: карта всегда окружена стеной? 
nick = swizard time = 26 12:44:52 как в эмуляторе игры? 
nick = swizard time = 26 12:45:20 в смысле, можно ли смело заглядывать в ( x - 1 ), ( y - 1 ), или надо проверять, что x и y не нуль? 
nick = grepz time = 26 12:45:30 я так понимаю что да 
nick = turtle time = 26 12:46:6 Написано, что да. 
nick = turtle time = 26 12:46:48 &quot;Maps are like mazes: they consist of corridors 1-square wide, without open spaces. More formally: there are no 2x2 areas consisting only of non-wall squares.<br /><br />Maps have walls around the edges.&quot; 
nick = swizard time = 26 12:52:41 надо бы ещё cond спрограммировать, а то дерево if-ов неудобно писать 
nick = turtle time = 26 12:56:47 Макросистема нужна. :) 
nick = swizard time = 26 12:57:9 да не обязательно пока, можно на уровне translate-walker добавить паттерны 
nick = swizard time = 26 12:58:59 и всякие caddr :) 
nick = turtle time = 26 13:0:29 Надо какие-нибудь босяцие макросы сделать. 
nick = swizard time = 26 13:1:25 хм, а откуда у меня там нагенерилось всяких «LDF +»  
nick = swizard time = 26 13:2:33 я там запушил gcc/examples/bumper-ai.lisp 
nick = swizard time = 26 13:2:47 как-то криво транслируется, собака 
nick = grepz time = 26 13:3:19 да, есть такое, я тоже не пойму, толи я дурак, толи лыжи не едут. 
nick = swizard time = 26 13:4:18 паттерн ((+ ?form-a ?form-b) (translate-op :add ?form-a ?form-b env)) почему-то не срабатывает, видимо, проваливается в стандартный proc-invocation 
nick = grepz time = 26 13:6:12 gcc/examples/bumper-ai.lisp ты его в мастер запушил? 
nick = swizard time = 26 13:6:57 да, попробуй ещё раз 
nick = grepz time = 26 13:7:13 во, теперь есть 
nick = swizard time = 26 13:7:15 не замечаю, что проклятый гит обламывается иногда при коммите 
nick = turtle time = 26 13:8:19 Босяцкий cond сделал. 
nick = grepz time = 26 13:8:41 минут на 15 отойду 
nick = swizard time = 26 13:10:59 нашёл проблему — скобки не так расставил =) 
nick = swizard time = 26 13:11:6 странно, почему такой эффект 
nick = swizard time = 26 13:11:8 ну да ладно 
nick = turtle time = 26 13:11:12 Ох уж этот лисп. :) 
nick = swizard time = 26 13:11:14 всё равно не работает :) 
nick = swizard time = 26 13:11:27 загружается, но tags mismatch 
nick = turtle time = 26 13:11:49 Значит, что-то не туда возвращается. 
nick = swizard time = 26 13:12:53 блин как бы всё это продебажить 
nick = turtle time = 26 13:19:38 А у нас nth есть разве? 
nick = turtle time = 26 13:19:57 А, вон ты его куда вынес. 
nick = swizard time = 26 13:20:21 я там ещё кой-чего пофиксил, но пока всё равно не работает 
nick = swizard time = 26 13:24:36 короче там всё работает кроме функции at-coords  
nick = swizard time = 26 13:24:40 тоесть, она тоже работает 
nick = swizard time = 26 13:24:52 но результат нельзя сравнить с числом, tags mismatch 
nick = swizard time = 26 13:25:7 блин а как в эмуляторе посмотреть, что она возвращает :) 
nick = grepz time = 26 13:25:14 DBUG 
nick = grepz time = 26 13:25:17 но если значение уже на стеке 
nick = grepz time = 26 13:25:41 возможно стоит dbug как ф-ию ilisp'а тоже ввести 
nick = turtle time = 26 13:26:0 Там же видн стек в эмуляторе. 
nick = turtle time = 26 13:26:4 Или нет? 
nick = swizard time = 26 13:26:5 хм а на стек оно как попадает? перед вызовом функции? 
nick = swizard time = 26 13:26:21 в http://icfpcontest.org/game.html я стека не вижу 
nick = grepz time = 26 13:26:42 после возврата из ф-ии если вызвать DBUG оно по идее должно показать значение 
nick = grepz time = 26 13:26:46 или хз вобщем 
nick = grepz time = 26 13:30:18 так, исходя из дампа данных, карта лежит в (car world-state). Если не смотреть на качество кода, то вот эта ф-ия по идее должна работать правильно:<br />(deflib/gcc map-size (map x y)<br />  (if (integerp (cdr map))<br />      (if (= x 0)<br />	  (map-size (car map) (+ 1 x) y)<br />	  (cons x y))<br />      (if (= x 0)<br />	  (map-size (cdr map) x (+ 1 y))<br />	  (map-size (cdr map) (+ x 1) y))))<br />А на выходе при попытке сделать (car result) tag mismatch. Я где-то ошибся? 
nick = swizard time = 26 13:31:8 у меня такая же фигня с картой 
nick = swizard time = 26 13:31:48 я не могу сделать даже (car (car map)) 
nick = swizard time = 26 13:32:5 tag mismatch тоже 
nick = grepz time = 26 13:32:10 очень странно 
nick = grepz time = 26 13:34:13 (deflib/gcc move (ai-state w-state)<br />  (cons 0 (car (car (car w-state))))) 
nick = grepz time = 26 13:34:19 вот такое сработало 
nick = swizard time = 26 13:34:35 да, я щас ровно такой же эксперимент сделал :) 
nick = grepz time = 26 13:34:48 а если такое же сделать в внутренней ф-ии ? 
nick = grepz time = 26 13:34:54 тогда наверное не сработает, так? 
nick = swizard time = 26 13:35:2 ща посмотрим 
nick = turtle time = 26 13:35:40 caar и cadr сделал. 
nick = swizard time = 26 13:35:56 и во внутренней функции работает 
nick = grepz time = 26 13:36:2 ага 
nick = grepz time = 26 13:36:5 тоже проверил 
nick = grepz time = 26 13:37:53 и даже через рекурсию работает 
nick = swizard time = 26 13:37:58 блин я щас сделал код чтобы если (car (car (car worls-state))) == 0, то бежать направо, иначе налево 
nick = swizard time = 26 13:38:2 побежал налево 
nick = swizard time = 26 13:38:13 что-то я там подзапутался 
nick = swizard time = 26 13:39:20 короче там какая-то проблема явно с этими списками 
nick = grepz time = 26 13:39:54 и даже такое работает: 
nick = grepz time = 26 13:39:55 (deflib/gcc test (map)<br />  (if (integerp (cdr map))<br />      2<br />      (test (cdr map))))<br /><br />(deflib/gcc move (ai-state w-state)<br />  (cons 0 (test w-state)))<br /> 
nick = grepz time = 26 13:39:59 бежит вниз 
nick = swizard time = 26 13:41:56 обана 
nick = swizard time = 26 13:42:16 оказывается, порядок аргументов не надо менять при вызове функции 
nick = grepz time = 26 13:43:9 что-то найти в доке такого не могу 
nick = swizard time = 26 13:45:41 хотя я могу ошибаться… 
nick = turtle time = 26 13:47:4 Да. 
nick = turtle time = 26 13:47:11 Самый нижни заполняется в 0. 
nick = turtle time = 26 13:47:17 Тот, что выше - дальше. 
nick = turtle time = 26 13:47:21 DUM 2<br />LDC 4<br />LDC 5<br />LDF 5<br />RAP 2<br />RTN 
nick = turtle time = 26 13:47:26 Вот вот это если посмотреть. 
nick = turtle time = 26 13:47:58 Вероятно там тоже список, поэтому он консами заполняет фрейм со стека. 
nick = turtle time = 26 13:48:5 Поэтому обратный порядок и может получиться. 
nick = swizard time = 26 13:48:23 тогда я откатываю правку 
nick = swizard time = 26 13:49:0 тогда непонятно с картой вообще 
nick = turtle time = 26 13:49:1 Ну ты в симуляторе тоже глянь, об одном и том же ли мы говорим? 
nick = grepz time = 26 13:49:36 эм, я скорее от безысходности спрашиваю, а мы вообще можем большие списки как аргументы передавать? 
nick = grepz time = 26 13:50:0 с другой стороны почему бы нет.. в мейн то он попадает 
nick = grepz time = 26 13:50:19 и те тестовые функции его карили и цдрили 
nick = turtle time = 26 13:50:21 Он же на куче просто. И там ссылка. 
nick = swizard time = 26 13:50:22 а почему нет, он же указатель просто передаёт на фрейм 
nick = grepz time = 26 13:50:40 ну да, точно 
nick = turtle time = 26 13:51:18 А что там с картой непонятно? 
nick = grepz time = 26 13:51:57 да вот собственно более-менее сложный код при работе со списками(картой) отваливается с tag mismatch 
nick = turtle time = 26 13:52:46 Нада найти где он отваливается. :) 
nick = grepz time = 26 13:53:18 ещё вопрос, cons можно из ф-ии возвращать&gt; 
nick = grepz time = 26 13:53:19 ? 
nick = swizard time = 26 13:53:31 можно, безусловно 
nick = grepz time = 26 13:53:56 гм 
nick = turtle time = 26 13:53:56 Свиз? Что за непонятки с картой? 
nick = swizard time = 26 13:54:6 короче, я локализовал проблему, но непонятно, что с ней делать 
nick = grepz time = 26 13:54:6 походу именно с cons и проблема 
nick = grepz time = 26 13:54:21 с cons - tag mismatch, без - всё хорошо 
nick = swizard time = 26 13:54:29 может, это не та проблема, но всё же 
nick = turtle time = 26 13:54:31 А что за проблема? 
nick = swizard time = 26 13:55:12 1. вот есть функция: call-with-world (lambda (map) … 
nick = swizard time = 26 13:55:29 2. я её зову так: (call-with-world (car world-state)) 
nick = swizard time = 26 13:55:42 3. внутри call-with-world всё работает 
nick = swizard time = 26 13:55:47 теперь я меняю сигнатуру 
nick = swizard time = 26 13:56:1 на call-with-world (lambda (map lman) … ) 
nick = swizard time = 26 13:56:21 и зову как (call-with-world (car world-state) (cadr world-state)) 
nick = swizard time = 26 13:56:33 tag-mismatch 
nick = swizard time = 26 13:56:42 а теперь я меняю параметры: 
nick = swizard time = 26 13:56:56 (call-with-world (cadr world-state) (car world-state)) 
nick = swizard time = 26 13:56:59 и опять работает 
nick = swizard time = 26 13:57:36 то-ли где-то косяк, то ли параметры при вызове функции надо всё-таки не реверсить 
nick = swizard time = 26 13:57:54 ща минут 10 на стенде поэкспериментирую 
nick = turtle time = 26 13:58:14 Ты смотрел в симуляторе l-mana? 
nick = turtle time = 26 13:58:20 Тот код, который я дал? 
nick = turtle time = 26 13:58:27 Там видно как параметры куда идут. 
nick = swizard time = 26 13:58:58 ща я транслятор тогда проверю 
nick = turtle time = 26 13:59:28 Там проблема в соответсвии между LD x x и вызовом. 
nick = turtle time = 26 13:59:32 Он же с фрейма читает потом. 
nick = swizard time = 26 13:59:49 не понял 
nick = turtle time = 26 14:0:52 Ну смотри. 
nick = turtle time = 26 14:0:57 Пушим в стек - 4 
nick = turtle time = 26 14:1:5 Пушим в стек 5 - (5 4). 
nick = turtle time = 26 14:1:23 Вот эта 4 её мы с фрейма забираем как LD 0 0, а 5 как LD 0 1 
nick = swizard time = 26 14:1:59 ага, вроде так и есть сейчас 
nick = swizard time = 26 14:2:52 хотя так да не так 
nick = swizard time = 26 14:2:53 (let ((proc (lambda (la lb)<br />              (+ (car la) (cdr lb)))))<br />  (proc (cons 1 10) (cons 100 1000)))<br /> 
nick = swizard time = 26 14:3:9 должно быть 1001, получилось 110 
nick = swizard time = 26 14:3:39 где-то лажа, ща погляжу 
nick = turtle time = 26 14:4:24 Ну да, по идее, не надо реверсить. 
nick = turtle time = 26 14:4:34 У тебя же после реверса меняется начало с концом. 
nick = turtle time = 26 14:4:49 Первый аргумент пропушенный в стек, его по LD 0 0 можно взять. 
nick = turtle time = 26 14:5:0 А с реверсом получается, по LD 0 0 идёт последний аргумент. 
nick = turtle time = 26 14:5:24 Хотя нет, там непонятно как у тебя назначаются. 
nick = swizard time = 26 14:5:56 так, давай ещё раз прикинем на моём примере 
nick = swizard time = 26 14:5:59 как должно быть 
nick = turtle time = 26 14:6:12 Давай. 
nick = swizard time = 26 14:6:12 (cons 1 10) — должен быть запушен последним? 
nick = swizard time = 26 14:6:20 а сначала (cons 100 1000) ? 
nick = turtle time = 26 14:6:25 Не обязательно. 
nick = turtle time = 26 14:6:35 Первый конс и должен быть запушен первым. 
nick = turtle time = 26 14:6:46 Но это зависит от того как дальше лукап делать. 
nick = swizard time = 26 14:6:55 ну да, вот я и определяюсь 
nick = turtle time = 26 14:7:7 Ну допустим, что (cons 1 10) должен быть запушен первым. 
nick = turtle time = 26 14:7:24 Если он будет запушен первым, то его надо дальше брать как LD 0 0 
nick = swizard time = 26 14:8:5 понятно, а у меня LD 0 1 
nick = swizard time = 26 14:8:9 ща погляжу 
nick = swizard time = 26 14:8:28 блин и в консе прямой порядок, ну что такое 
nick = swizard time = 26 14:8:51 давайте щас чётко определимся с порядком, и везде унифицируем, а то поломалось же всё 
nick = swizard time = 26 14:9:0 итого: фиксируем обратный порядок? 
nick = swizard time = 26 14:9:30 (f a b) -&gt; сначала push b, потом push a, внутри a — это LD 0 0, и b — LD 0 1 
nick = swizard time = 26 14:9:32 ок? 
nick = grepz time = 26 14:10:18 так 
nick = swizard time = 26 14:11:8 тогда давайте я сейчас поправлю funcall, а вы посмотрите остальные базовые функции, хорошо? 
nick = swizard time = 26 14:11:19 чтобы точно порядок был везде один и тот же 
nick = grepz time = 26 14:11:45 я только одного не пойму, если ошибка действительно в этом, почему код (cons x y) на выходе выполняется нормально, а (cons (- x 1) y)) к примеру уже ломается 
nick = grepz time = 26 14:11:57 * на выходе функции 
nick = swizard time = 26 14:12:22 ну давай я это отдельно посмотрю в эмуляторе после ремонта 
nick = grepz time = 26 14:12:26 ок 
nick = swizard time = 26 14:12:30 может, там просто другая ошибка 
nick = grepz time = 26 14:12:40 я пойду кофе в себя залью тогда 
nick = swizard time = 26 14:17:44 так, вроде пофиксил где можно 
nick = swizard time = 26 14:17:59 ща посмотрю есть ли проблема с возвращаемым cons 
nick = swizard time = 26 14:19:33 что-то там явно не так :) 
nick = swizard time = 26 14:19:35 (let ((proc (lambda (x y) (cons (- x 1) y))))<br />  (proc 10 10)) 
nick = swizard time = 26 14:19:43 результат (10, -9) 
nick = grepz time = 26 14:20:4 гм 
nick = grepz time = 26 14:20:47   $y,%s := POP(%s)<br />  $x,%s := POP(%s)<br />  if TAG($x) != TAG_INT then FAULT(TAG_MISMATCH)<br />  if TAG($y) != TAG_INT then FAULT(TAG_MISMATCH)<br />  $z := $x - $y<br />  %s := PUSH(SET_TAG(TAG_INT,$z),%s)<br />  %c := %c+1 
nick = grepz time = 26 14:20:56 получается перепутаны аргументы 
nick = swizard time = 26 14:21:28 прямо по спеке перепутаны? 
nick = grepz time = 26 14:21:58 я сейчас посмотрю как у нас, обновлю gcc 
nick = grepz time = 26 14:22:8 думаю уже поправили бы, если там была ошибка 
nick = swizard time = 26 14:22:12 давай, только pull сделай сначала 
nick = swizard time = 26 14:23:12 хм, там как-то странно 
nick = swizard time = 26 14:23:16 рассмотрим код: 
nick = swizard time = 26 14:23:25 (let ((proc (lambda (x y) (cons (- x 1) y))))<br />  (proc 10 100))<br /> 
nick = swizard time = 26 14:23:30 результат: (10, -99) 
nick = swizard time = 26 14:23:32 асм: 
nick = swizard time = 26 14:23:40     LDC 100<br />    LDC 10<br />    LDF 5<br />    AP 2<br />    RTN<br />;5:<br />    LD 0 1<br />    LDC 1<br />    LD 0 0<br />    SUB<br />    CONS<br />    RTN<br /> 
nick = swizard time = 26 14:24:1 proc — это ;5: 
nick = grepz time = 26 14:24:18 угу 
nick = swizard time = 26 14:24:18 тоесть я сначала пушу в стек LD 0 1 — это y, 100 
nick = swizard time = 26 14:24:22 потом 1 
nick = swizard time = 26 14:24:28 потом LD 0 0 — это 10 
nick = swizard time = 26 14:24:33 делаю SUB 
nick = swizard time = 26 14:24:41 разве я не должен получить 9? 
nick = swizard time = 26 14:24:47 и 100 на стеке? 
nick = grepz time = 26 14:25:1 именно, оно забирает последние переменные на стэке 
nick = grepz time = 26 14:25:8 а это как раз и будет 10 и 1 
nick = swizard time = 26 14:25:17 а откуда тогда в результате -99 ? :) 
nick = grepz time = 26 14:25:48 погодь, а если оно стек считает с конца(то бишь начала)? 
nick = turtle time = 26 14:26:11 (f a b) -&gt; сначала push b, потом push a, внутри a — это LD 0 0, и b — LD 0 1 - не так. 
nick = turtle time = 26 14:26:27 push a&lt; потом push b, внутри a - это LD 0 0. 
nick = turtle time = 26 14:26:47 А b LD 0 1. Но сначала надол a пушить. 
nick = swizard time = 26 14:26:52 короче, для конса это не там 
nick = swizard time = 26 14:26:54     LDC 100<br />    LDC 10<br />    CONS<br />    RTN 
nick = swizard time = 26 14:26:59 результат (100, 10) 
nick = turtle time = 26 14:27:35 Ну для конса и должен быть такой результат. 
nick = swizard time = 26 14:28:25 ок, тогда я для конса конкретно меняю в трансляторе порядок аргументов? 
nick = turtle time = 26 14:28:51 Погоди. 
nick = turtle time = 26 14:28:56 Я сейчас смотрию в транслятор. 
nick = swizard time = 26 14:28:58 гожу 
nick = turtle time = 26 14:29:0 И там всё ок. 
nick = turtle time = 26 14:29:12 ((:LDC 100) (:LDC 10) (:CONS)) 
nick = turtle time = 26 14:29:22 Возвращает (translate '(cons 100 10)) 
nick = turtle time = 26 14:29:25 Наоборот. 
nick = turtle time = 26 14:29:32 Т.е. так и должно быть. 
nick = swizard time = 26 14:29:47 но ты в http://icfpcontest.org/lman.html глянь 
nick = turtle time = 26 14:29:59 Я там и смотрю. 
nick = swizard time = 26 14:30:20 так 
nick = turtle time = 26 14:30:22 Так и получается. 
nick = swizard time = 26 14:30:38     LDC 100<br />    LDC 10<br />    CONS<br />    RTN 
nick = swizard time = 26 14:30:46 data stack: (100, 10) 
nick = swizard time = 26 14:30:51 а не (10, 100) 
nick = swizard time = 26 14:31:1 наоборот должно быть же 
nick = turtle time = 26 14:31:4 Так конс так и работает. 
nick = grepz time = 26 14:31:13 ну правильно, он потому что y первой забирает<br /> 
nick = grepz time = 26 14:31:30 $y,%s := POP(%s)<br />  $x,%s := POP(%s) 
nick = grepz time = 26 14:31:40 $z := ALLOC_CONS($x,$y) 
nick = swizard time = 26 14:32:14 ну тоесть надо менять порядок 
nick = swizard time = 26 14:32:15 (car (cons 10 100)) 
nick = turtle time = 26 14:32:16 Тот gcc он же эквивалент (cons 1000 10). 
nick = swizard time = 26 14:32:22 должно быть 10, получаем 100 
nick = turtle time = 26 14:32:26 Зачем? Не надо. 
nick = swizard time = 26 14:32:35 turtle :) 
nick = turtle time = 26 14:32:43  LDC 100<br /> LDC 10<br /> CONS<br /> CAR<br /> RTN 
nick = turtle time = 26 14:32:47 Получаем 100. 
nick = swizard time = 26 14:32:57 но получить-то должны 10!! 
nick = turtle time = 26 14:33:5 Почему? 
nick = grepz time = 26 14:33:8 не, и должны 100 получить 
nick = grepz time = 26 14:33:27 смотри: y = 10, x = 100, машина преобразует это в (100, 10) 
nick = turtle time = 26 14:33:29 Это cdr 10 должен получить. 
nick = grepz time = 26 14:33:32 car забирает x 
nick = swizard time = 26 14:33:45 да вы троллите чтоли меня :) 
nick = turtle time = 26 14:33:51 Ну спеку глянь. :) 
nick = grepz time = 26 14:33:55 посмотри в псевдокод cons :) 
nick = swizard time = 26 14:33:57 вот я в slime проверяю в лиспе: GCC&gt; (car (cons 10 100))<br />10<br /> 
nick = turtle time = 26 14:34:9 CONS - allocate a CONS cell<br /><br />Synopsis: pop two values off the data stack;<br />          allocate a fresh CONS cell;<br />          fill it with the two values;<br />          push the pointer to the CONS cell<br />Syntax: CONS<br />Effect:<br />  $y,%s := POP(%s)<br />  $x,%s := POP(%s)<br />  $z := ALLOC_CONS($x,$y)<br />  %s := PUSH(SET_TAG(TAG_CONS,$z),%s)<br />  %c := %c+1<br /> 
nick = grepz time = 26 14:34:25 так тут транслирует VM оргов то что мы предоставляем 
nick = swizard time = 26 14:34:42 да мало ли какой там псевдокод, это задача транслятора  
nick = swizard time = 26 14:34:53 не может быть, чтобы (car (cons 10 100)) было 100 
nick = grepz time = 26 14:35:1 то есть мы сначала положили X, потом Y на стэк, VM забрал верхнее - Y, потом X и поменял их местами 
nick = turtle time = 26 14:35:9 (car (cons 10 100))  - для нашего случая надол (car (cons 100 10)) 
nick = turtle time = 26 14:35:19 Давай по порядку. 
nick = turtle time = 26 14:35:26 Смотрим в слиме  (car (cons 100 10)) 
nick = turtle time = 26 14:35:37 Получаем 100. 
nick = swizard time = 26 14:35:47 блин, ну объясните мне, почему я не могу в трансляторе поменять местами аргументы в cons для IL :) 
nick = turtle time = 26 14:35:52 Транслируем: (translate '(car (cons 100 10))) 
nick = turtle time = 26 14:36:2 Получаем ((:LDC 100) (:LDC 10) (:CONS) (:CAR)) 
nick = turtle time = 26 14:36:6 Вбиваем в симулятор. 
nick = turtle time = 26 14:36:23 Получаем 100. 
nick = grepz time = 26 14:36:37 translate = ((:LDC 10) (:LDC 100) (:CONS) (:CAR)) 
nick = turtle time = 26 14:36:37 Поменять можешь, просто это неправильно будет. 
nick = swizard time = 26 14:36:46 а, всё, разобрался 
nick = grepz time = 26 14:36:48 ну да, получается мы должны менять местами значения 
nick = turtle time = 26 14:36:55 У мееня текущий транслятор 100 сначала делает. 
nick = grepz time = 26 14:37:5 (cons 100 10), даёт то что выше, а должно быть наоборот 
nick = swizard time = 26 14:37:7 давайте все вместе сейчас синхронизируем репо, и ещё раз обсудим 
nick = turtle time = 26 14:37:16 Да, после компиляции по другому работает. 6) 
nick = swizard time = 26 14:37:18 а то у нас разный код 
nick = swizard time = 26 14:37:25 короче 
nick = grepz time = 26 14:37:31 :) 
nick = turtle time = 26 14:37:54 А, потому что там обобщённый код для всех операций. 
nick = grepz time = 26 14:38:12 им всё-таки надо было предусмотреть более развёрнутый дебаг. Реально легко запутаться. 
nick = swizard time = 26 14:38:14 короче так: там теперь сам translate-op меняет порядок операции 
nick = turtle time = 26 14:38:30 :) 
nick = turtle time = 26 14:38:34 Надо глянуть, кстати. 
nick = swizard time = 26 14:38:50 давайте сделаем так: пусть translate-op всегда поддерживает прямой порядок 
nick = swizard time = 26 14:39:5 а если надо менять, поменяем в его вызове из translate-walker 
nick = grepz time = 26 14:39:18 да, пожалуй так будет лучше 
nick = turtle time = 26 14:39:45 Да, надо так. 
nick = turtle time = 26 14:39:56 Потому что для SUB другой порядок нужен. 
nick = turtle time = 26 14:40:1 И div тоже. 
nick = swizard time = 26 14:40:2 ща закоммичу 
nick = grepz time = 26 14:40:26 нет, правда, я совсем не удивлён, что LamCo обонкротились :) 
nick = turtle time = 26 14:40:45 :) 
nick = swizard time = 26 14:41:2 так, погодите, а для кого вообще нужен прямой порядок? 
nick = turtle time = 26 14:41:8 Кто-то тесты вчера продвигал яро. :) 
nick = grepz time = 26 14:41:18 было дело. :) 
nick = swizard time = 26 14:41:22 я щас спеку наискосок проглядел — везде   $y,%s := POP(%s)<br />  $x,%s := POP(%s)<br /> 
nick = turtle time = 26 14:41:24 Надо был с них начать. 
nick = turtle time = 26 14:41:53 Только вот SUB - $x - $y. 
nick = turtle time = 26 14:42:21 А CONS - ALLOC_CONS($x,$y) 
nick = grepz time = 26 14:42:21 да, для деления и вычитания 
nick = grepz time = 26 14:42:44 но деления нет, потому только вычитания, все остальные операции коммутативны 
nick = turtle time = 26 14:42:45 Хотя. Сейчас у меня минус тоже неправильно работоал. 
nick = turtle time = 26 14:43:23 Ты протолкнул свои изменения? 
nick = turtle time = 26 14:43:26 Или правишь пока? 
nick = swizard time = 26 14:43:50 правлю пока — я опять с порядком запутался :( 
nick = turtle time = 26 14:44:19 Ну... 
nick = turtle time = 26 14:45:0 Делай прямой порядко. 
nick = turtle time = 26 14:45:5 Первый, потом второй. 
nick = turtle time = 26 14:45:12 И не ошибёшься, думаю. 
nick = grepz time = 26 14:45:58 1.15 осталось, не успеваем 
nick = swizard time = 26 14:46:26 протолкнул 
nick = swizard time = 26 14:46:41 проверьте, пожалуйста, все операции в эмуляторе 
nick = grepz time = 26 14:46:49 ок 
nick = grepz time = 26 14:49:56 арифметику, car/cdr проверил, всё хорошо 
nick = swizard time = 26 14:50:18 надо ещё сравнения и условия 
nick = turtle time = 26 14:50:55 Я тоже посмотрел, нормально. 
nick = turtle time = 26 14:50:58 Сравнения проверил. 
nick = turtle time = 26 14:51:11 Условия if проверял вчера. :) 
nick = grepz time = 26 14:51:21 тоже проверил 
nick = swizard time = 26 14:51:23 но вот такой тест опять не работает: 
nick = grepz time = 26 14:51:24 всё работает 
nick = swizard time = 26 14:51:24 (let ((proc (lambda (la lb)<br />              (- (car la) (cdr lb)))))<br />  (proc (cons 1 10) (cons 100 1000)))<br /> 
nick = turtle time = 26 14:51:24 Сейчас when и cond гляну. 
nick = swizard time = 26 14:53:36 да блин что ж такое-то 
nick = swizard time = 26 14:53:43 (let ((proc (lambda (la lb) (car la))))<br />  (proc (cons 1 10) (cons 100 1000)))<br /> 
nick = swizard time = 26 14:53:48 почему там 100 
nick = swizard time = 26 14:53:55     LDC 100<br />    LDC 1000<br />    CONS<br />    LDC 1<br />    LDC 10<br />    CONS<br />    LDF 9<br />    AP 2<br />    RTN<br />;9:<br />    LD 0 0<br />    CAR<br />    RTN<br /> 
nick = swizard time = 26 14:54:14 LD 0 0 в ;9: — это же последний конс?! 
nick = turtle time = 26 14:54:26 Нет, первый. 
nick = swizard time = 26 14:54:49 точно? 
nick = turtle time = 26 14:54:56 Да, точно. 
nick = grepz time = 26 14:55:41 90 получается 
nick = grepz time = 26 14:56:8 как так то 
nick = turtle time = 26 14:56:32 А -999 должно. 
nick = turtle time = 26 14:57:5 А потому что создались они не в том порядке. 
nick = grepz time = 26 14:57:5 а если поменять порядок аргументов то всё правильно :) 
nick = grepz time = 26 14:57:14     LDC 100<br />    LDC 1000<br />    CONS<br />    LDC 1<br />    LDC 10<br />    CONS<br />    LDF 9<br />    AP 2<br />    RTN<br />;9:<br />    LD 0 1<br />    CAR<br />    LD 0 0<br />    CDR<br />    SUB<br />DBUG 
nick = turtle time = 26 14:57:28 LDC 1<br />LDC 10<br />CONS<br />LDC 100<br />LDC 1000<br />CONS<br />LDF 9<br />AP 2<br />RTN<br />;9:<br />LD 0 0<br />CAR<br />LD 0 1<br />CDR<br />SUB<br />RTN 
nick = turtle time = 26 14:57:31 Вот так должно быть. 
nick = grepz time = 26 14:57:36 нет 
nick = grepz time = 26 14:57:38 наоборот 
nick = swizard time = 26 14:57:40 закоммитил правку, теперь надо глянуть 
nick = turtle time = 26 14:58:18 Ну либо так. 
nick = turtle time = 26 14:58:24 Если созддавать в таком порядке. 
nick = grepz time = 26 14:58:25 во, так правильно 
nick = turtle time = 26 14:59:0 Ну тут надо проверить. 
nick = turtle time = 26 14:59:8 Вот почему они изначально создаются с тем порядком? 
nick = turtle time = 26 14:59:21 Если просто определиться, то уже норм должно быть. 
nick = swizard time = 26 15:0:24 мде, не подойдёт такой фикс 
nick = turtle time = 26 15:0:26 Аааа. Сейчас можем запутаться. :) 
nick = swizard time = 26 15:0:33 уже запутались :) 
nick = turtle time = 26 15:1:7 У нас в translate-op надо порядок создания определить. 
nick = grepz time = 26 15:1:13 надо вобщем отдельно порядок для аргументов при новом фрейме делать и когда нового фрейма нет или я не прав? 
nick = turtle time = 26 15:1:15 У нас сейчас там наоборот. 
nick = turtle time = 26 15:2:35 ДА нет. 
nick = swizard time = 26 15:2:36 блин, надо тесты, конечно 
nick = turtle time = 26 15:2:38 Нормально. 
nick = swizard time = 26 15:2:49 я щас там экспериментирую — что-то старое ломается 
nick = turtle time = 26 15:2:53 Для минуса смотрю. 
nick = turtle time = 26 15:3:4 Где-то в lambda, скорее всего. Сейчас гляну. 
nick = turtle time = 26 15:4:26 Да там тоже вроде всё нормально. 
nick = turtle time = 26 15:5:32 В proc беда с текущим кодом. 
nick = turtle time = 26 15:5:39 GCC&gt; (translate '(ff 1 2))<br /> 
nick = turtle time = 26 15:5:48 Выдает: ((:LDC 2) (:LDC 1) (:LDF FF) (:AP 2)) 
nick = turtle time = 26 15:5:57 А Должен LDC 1 сначала поставить. 
nick = swizard time = 26 15:6:20 почему, мы же вроде решили обратный порядок для функций? 
nick = turtle time = 26 15:6:47 Ну где-то решили, где-то не решили. 
nick = turtle time = 26 15:6:54 lambda, например, другой пордяок. 
nick = turtle time = 26 15:7:29 По мне так только в proc сейчас надо прямой порядок поставить и всё. 
nick = swizard time = 26 15:8:34 запушил, давайте всё проверять 
nick = grepz time = 26 15:9:47 функция определения размера карты вот сейчас вот начала правильно работать 
nick = grepz time = 26 15:10:22 сейчас все остальные операции проверю 
nick = swizard time = 26 15:12:3 зато у меня перестал работать (car lman) и (cdr lman) :( 
nick = grepz time = 26 15:12:51 у меня зато теперь всё работает 
nick = grepz time = 26 15:12:52 :) 
nick = grepz time = 26 15:13:27 (deflib/gcc map-size (map x y)<br />  (if (integerp (cdr map))<br />      (if (= x 0)<br />	  (map-size (car map) (+ 1 x) y)<br />	  (cons x (+ y 1)))<br />      (if (= x 0)<br />	  (map-size (cdr map) x (+ 1 y))<br />	  (map-size (cdr map) (+ 1 x) y))))<br /><br />(deflib/gcc move (ai-state w-state)<br />  (if (= (cdr (map-size (car w-state) 0 0)) 22)<br />      (cons ai-state :left)<br />      (cons ai-state :rigth))) 
nick = swizard time = 26 15:14:42 класс 
nick = swizard time = 26 15:14:48 45 минут ещё :) 
nick = grepz time = 26 15:14:52 %) 
nick = swizard time = 26 15:15:12 блин почему координаты пакмана ломаются у меня 
nick = swizard time = 26 15:15:17 даже карта уже заработала 
nick = grepz time = 26 15:15:33 координы ловишь как (car (cdr l)))? 
nick = grepz time = 26 15:15:57 где l =  (car (cdr w-state))) 
nick = swizard time = 26 15:16:8 хм, нет похоже :) 
nick = swizard time = 26 15:16:10 ща 
nick = swizard time = 26 15:17:50 еее!! 
nick = swizard time = 26 15:18:6 пакман уже зигзагом пробежался =) 
nick = swizard time = 26 15:18:11 ща закоммичу ai 
nick = grepz time = 26 15:18:15 давай 
nick = turtle time = 26 15:18:51 Крут. :) 
nick = grepz time = 26 15:19:24 да вообще монстр 
nick = swizard time = 26 15:19:33 bumper-ai.lisp 
nick = grepz time = 26 15:19:44 нету 
nick = swizard time = 26 15:19:46 у меня он убегает в левый угол и застревает там 
nick = swizard time = 26 15:19:53 да блин 
nick = swizard time = 26 15:19:54 ща 
nick = swizard time = 26 15:20:22 ушло 
nick = swizard time = 26 15:20:58 так щас попробую чуть проапгрейдить, чтобы он своё предыдущее направление сохранял в ai-state и старался не бежать назад 
nick = turtle time = 26 15:22:6 Как мы теперь ии компилируем? 
nick = swizard time = 26 15:22:21 ну я его просто через translate-file 
nick = grepz time = 26 15:22:51 может перетащим на build-ai-core 
nick = grepz time = 26 15:23:2 чтобы на функции уже разбивать 
nick = swizard time = 26 15:23:9 давай после lightning division :/ 
nick = grepz time = 26 15:23:13 ок 
nick = grepz time = 26 15:23:39 много времени с порядком провозились конечно 
nick = swizard time = 26 15:23:51 35 минут осталось, вряд ли уже успеем A* сделать на IL, конечно, но, может, хоть что-то 
nick = grepz time = 26 15:24:12 если хотя бы бегать будет и на поворотах менять направление, уже класс 
nick = swizard time = 26 15:25:17 блин а у нас нету логических «and», «or» и тд? 
nick = grepz time = 26 15:25:31 нет 
nick = grepz time = 26 15:25:36 только вложенными when 
nick = grepz time = 26 15:25:41 в условия 
nick = swizard time = 26 15:25:47 давайте мож сделаем 
nick = grepz time = 26 15:26:49 может пока на when, чтобы не огрести багов? 
nick = swizard time = 26 15:27:44 ок, но блин код утраивается 
nick = swizard time = 26 15:28:26 условие (and (= x ox) (= y ox)) в лапшу превращается если там есть обе ветки true и false 
nick = grepz time = 26 15:28:36 мдя 
nick = turtle time = 26 15:30:19 А где там утраивается? 
nick = swizard time = 26 15:30:32                                               (let ((can-walk (lambda (x y)<br />                                                                (if (= x (car ai-state))<br />                                                                    (if (= y (cdr ai-state))<br />                                                                        0<br />                                                                        (at-coords x y))<br />                                                                    (at-coords x y)))))<br /> 
nick = swizard time = 26 15:30:40 ну фиг с ним пока 
nick = swizard time = 26 15:35:12 блин всё равно быстро застревает 
nick = turtle time = 26 15:35:14 Кстати, транслирует он его как-то странно. 
nick = swizard time = 26 15:35:23 глянте код кто-нибудь bumper-ai 
nick = turtle time = 26 15:36:11 Ты там расставь :up, :down и т.д. 
nick = turtle time = 26 15:36:16 А то непонятно. :) 
nick = swizard time = 26 15:37:57 расставил 
nick = swizard time = 26 15:38:6 тока перестало работать, но не из-за этого :) 
nick = turtle time = 26 15:39:31 У тебя начинается иф lf = 0, и даалее. 
nick = turtle time = 26 15:39:39 И когда тоже куда-то не пришло, опять в lf. 
nick = turtle time = 26 15:39:44 Т.е. заведомов тупик. 
nick = turtle time = 26 15:39:54 Хотя. 
nick = turtle time = 26 15:40:2 Там уже точно тупик полный. 
nick = swizard time = 26 15:44:24 я запушил examples/experiment.lisp 
nick = swizard time = 26 15:44:34 он рабочий, но там какая-то лажа 
nick = swizard time = 26 15:45:3 если все вызовы для аргументов lman-env с at-coords заменить на can-walk, то всё перестаёт работать 
nick = turtle time = 26 15:45:19 Я пока захардкодил :wall ит.д. 
nick = swizard time = 26 15:45:29 хотя can-walk в этом варианте ничего не делает, только зовёт at-coords 
nick = swizard time = 26 15:45:56 так ладно, осталось 15 минут 
nick = swizard time = 26 15:46:6 я предлагаю закоммитить бота experiment.lisp 
nick = swizard time = 26 15:46:20 он хотя бы хоть что-то делает, а не просто в сторону бежит 
nick = turtle time = 26 15:46:25 Давайте. Хотя бы что-то будет. 
nick = swizard time = 26 15:46:34 сделаешь? 
nick = turtle time = 26 15:46:36 Да. 
nick = swizard time = 26 15:46:43 ага, спасио 
nick = swizard time = 26 15:47:0 если я сейчас за 10 минут пофикшу багу, то пересабмитим 
nick = grepz time = 26 15:47:35 А то что у нас return 2 раза зовётся ничего? 
nick = grepz time = 26 15:47:36 хотя думаю ничего 
nick = swizard time = 26 15:49:54 стоп отбой 
nick = swizard time = 26 15:50:19 запушил experiment.lisp ещё раз 
nick = swizard time = 26 15:50:22 что-то вышло 
nick = swizard time = 26 15:50:30 у меня бот аж четверть карты оббежал 
nick = swizard time = 26 15:50:55 ушёл пуш 
nick = swizard time = 26 15:51:35 посмотрите плз всё ли завелось у вас 
nick = swizard time = 26 15:53:11 короче этот вариант однозначно будет застревать в тупиках и бегать по зацикленным пещерам вокруг 
nick = swizard time = 26 15:53:24 но бектрейсинг я уже тупо не успею сделать 
nick = turtle time = 26 15:53:43 Да, работает. ) 
nick = grepz time = 26 15:54:24 работает 
nick = grepz time = 26 15:54:36 видно что бот проседает там где решение принимать надо 
nick = grepz time = 26 15:54:46 кол-во инструкций на цикл :) 
nick = swizard time = 26 15:56:42 лол он походу даже из тупиков вылазит 
nick = swizard time = 26 15:56:54 но зацикливается в кругах 
nick = grepz time = 26 15:57:22 у нас же ai-state это инт? 
nick = swizard time = 26 15:57:31 было бы щас не 3 минуты до конца, а 20 — я бы просто пройденный путь сохранял в ai-state 
nick = swizard time = 26 15:57:37 не, au-state — это что угодно 
nick = swizard time = 26 15:57:41 я щас там храню cons 
nick = grepz time = 26 15:57:42 а, ну тогда круто 
nick = turtle time = 26 15:57:57 Вроде отправил. 
nick = swizard time = 26 15:58:5 ну класс 
nick = turtle time = 26 15:58:25 Геморно публиковать, потом публиковалку напишу. Завтра. 
nick = turtle time = 26 15:58:49 Если что, имя команды - Skobochka, приватный идентификатор - skoba-2014 
nick = grepz time = 26 15:58:56 Так, я до дому почапал, где-то наверное с полчаса-час буду отсутствовать. 
nick = swizard time = 26 15:59:3 надо ща глянуть, может, scoreboard сделают после lightning division 
nick = turtle time = 26 15:59:11 Ну хз. :) 
nick = swizard time = 26 15:59:14 давай, я тоже щас минут через 15 пойду прогуляюсь 
nick = turtle time = 26 15:59:16 Хотя может быть, конечно. 
nick = turtle time = 26 15:59:19 Давай. 
nick = swizard time = 26 15:59:35 а куда делся sectoid, интересно :) 
nick = swizard time = 26 16:3:0 орги дополнительную спеку выложили: http://icfpcontest.org/spec-extra.html  
nick = swizard time = 26 16:3:52 как мы и думали, это tournament между пакманами и гоустами 
nick = swizard time = 26 16:4:2 надо программировать гоустов :) 
nick = turtle time = 26 16:4:11 Да. 
nick = turtle time = 26 16:4:15 Но это мы и знали. 
nick = turtle time = 26 16:4:54 &quot;It turns out to be an encoding of the ghost programs!&quot; 
nick = turtle time = 26 16:4:57 Удивили. :) 
nick = turtle time = 26 16:6:6 Короче, как мы и думали.ю 
nick = turtle time = 26 16:6:21 Надо доотлаживать бота и уже писать эмулятор готов на IL. 
nick = swizard time = 26 16:7:8 блин, они реально расчитывают, что кто-то напишет на IL полный эмулятор мира с гоустами и в процессе инициализации подберёт стратегию? :)  
nick = swizard time = 26 16:7:19 хотя чем чёрт не шутит, два дня же ещё 
nick = swizard time = 26 16:7:59 только я не понял, где можно гоустов поотлаживать 
nick = turtle time = 26 16:9:43 Отдельно нигде, вроде бы. 
nick = turtle time = 26 16:9:59 Но в мире они туда копипамтятся. 
nick = sectoid time = 26 16:17:46 sectoid проспал( 
nick = turtle time = 26 16:18:5 Доброе утро. :) 
nick = swizard time = 26 16:18:14 привет =) 
nick = sectoid time = 26 16:18:25 сектоид проигнорировал будильники 
nick = sectoid time = 26 16:18:42 мы успели? 
nick = swizard time = 26 16:19:6 какое-то решение ушло 
nick = swizard time = 26 16:19:18 много времени потеряли на отладке транслятора 
nick = swizard time = 26 16:19:28 тестов, конечно, просто ад как не хватает :) 
nick = turtle time = 26 16:21:9 Читал экстра спеку? 
nick = turtle time = 26 16:21:14 Всё как мы и думали. 
nick = sectoid time = 26 16:29:5 читаю логи и счас буду листать extra-spec 
nick = turtle time = 26 16:29:20 Ага. Давай. 
nick = sectoid time = 26 16:30:42 хех. я правильно отреверсил андокументед) 
nick = turtle time = 26 16:30:58 :) 
nick = sectoid time = 26 16:31:51 хехехехехе. таки не угадал с тем, как будет реализовываться режим соревнования 
nick = turtle time = 26 16:32:49 А ты как думал? 
nick = turtle time = 26 16:32:54 Вроде бы же всё как думали. 
nick = sectoid time = 26 16:33:9 ну, я думал что таки 2 пакмана будет 
nick = turtle time = 26 16:33:25 А я сразу думал, что госты против пакмана. 
nick = sectoid time = 26 16:33:28 а оказывается будем и гостов сабмитить, и лямбдмана 
nick = sectoid time = 26 16:59:44 все убрели проветрится похоже? 
nick = swizard time = 26 17:0:10 я пока здесь, но мне надо будет уйти через 15 мин 
nick = sectoid time = 26 17:2:9 я вот думаю во что счас &quot;вбрасываться&quot;? 
nick = swizard time = 26 17:3:40 если с целью принести максимум пользы, то сделать тесты для транслятора :) там ещё не все баги того. а если максимум фана, то можно либо транслятор/АИ для гоустов, либо АИ для пакмана 
nick = swizard time = 26 17:4:12 но АИ для пакмана пока затруднительно писать, пока не все баги транслятора выловлены 
nick = sectoid time = 26 17:4:24 начну с тестов транслятора. а то что-то от меня маловато пользы) 
nick = swizard time = 26 17:4:56 от тебя пока основная польза, пока все остальные разбрелись =) 
nick = sectoid time = 26 17:5:15 что там нынче в моде для тестов? я 5am юзал (или как его там) 
nick = swizard time = 26 17:6:9 честно говоря, я не знаю, я никогда тестов не пишу и страдаю =) 
nick = sectoid time = 26 17:6:31 ясненько. прикручу 5am. 
nick = turtle time = 26 17:7:49 5am, lift - нормальные. 
nick = turtle time = 26 17:8:18 Я пока and и or делаю оптимизированные. 
nick = sectoid time = 26 17:9:7 у всех asdf 3й стоит? 
nick = swizard time = 26 17:9:23 всё я отошёл минут на 40 - час 
nick = sectoid time = 26 17:13:11 ага, lift делали те же чуваки, что и utilities и metabang-bind. беру lift 
nick = sectoid time = 26 17:16:8 *metatilities 
nick = turtle time = 26 17:34:9 В обещм, and, or и not я сделал. 
nick = turtle time = 26 17:34:16 Что нам там ещё нужно будет? 
nick = sectoid time = 26 17:37:36 нам нужено покрыть этот кошмар тестами 
nick = sectoid time = 26 17:37:55 и неплохо было бы навернуть какие-нить макры на транслятор  
nick = turtle time = 26 17:38:0 Да, действительно кошмар. :) 
nick = sectoid time = 26 17:38:12 чтобы впиливать формы можно было добавлять не упатчивая транслятор 
nick = turtle time = 26 17:38:13 Макры да, круто было бы. 
nick = sectoid time = 26 17:38:19 возьмешься? 
nick = turtle time = 26 17:38:22 Я босяцке макры сделал, без defmacro. 
nick = sectoid time = 26 17:38:27 я пока колдую над тестами 
nick = turtle time = 26 17:38:32 Но там тоже, в целом, херачится. 
nick = turtle time = 26 17:38:40 Я пока гостов, наверное, посмотрю. 
nick = sectoid time = 26 17:38:45 давай, погляди 
nick = turtle time = 26 17:38:48 Я пока не представляю как там сделать нормальные макры. 
nick = turtle time = 26 17:39:4 Плюс, ещё нам надо сфигачить через build-ai-... что-то там. 
nick = sectoid time = 26 17:39:24 build-ai там тривиален 
nick = sectoid time = 26 17:39:42 он добавляет наружную лямбду, вкидывает библиотеку и подставляет основное тело 
nick = turtle time = 26 17:39:59 Сам да, но надо через него начать билдить лябдаменов. 
nick = sectoid time = 26 17:40:4 макры я бы делал по аналогии с deflib/gcc, добавив еще один проход для macroexpansion 
nick = sectoid time = 26 17:42:45 о, вот и первые баги в трансляторе) 
nick = turtle time = 26 17:43:24 :) 
nick = sectoid time = 26 17:43:35 порядок аргументов 
nick = sectoid time = 26 17:43:41 (addtest (gcc-translator-core) <br />  op-add-const-1<br />  (ensure-same (translate '(+ 1 2))<br />               '((:LDC 2) (:LDC 1) (:ADD)))) 
nick = turtle time = 26 17:43:44 Да ёлы-палы. :) 
nick = sectoid time = 26 17:43:46 я ведь верно мыслю? 
nick = turtle time = 26 17:44:10 Да нет. 
nick = turtle time = 26 17:44:16 Надос начала 1, потом 2. 
nick = sectoid time = 26 17:44:25 пилять 
nick = sectoid time = 26 17:44:29 надо просыпаться) 
nick = turtle time = 26 17:45:55 Мы сегодня с этим порядком аргументов целый день потратили. :) 
nick = sectoid time = 26 17:46:18 теперь не будем тратить 
nick = sectoid time = 26 17:46:24 доделаю тесты и не будем 
nick = turtle time = 26 17:47:19 Да, не хватало тестов, не хватало. :) Вспоминали, кто вчера предлагал, но не сделал. :) 
nick = turtle time = 26 17:47:51 У нас на госта 256 байт только. 
nick = turtle time = 26 17:47:55 Не густо, скажем так. 
nick = sectoid time = 26 17:48:5 ога 
nick = turtle time = 26 17:48:6 Т.е. гост получится явно тупее лямбдамена. 
nick = sectoid time = 26 17:48:21 и при этом регистровая машина 
nick = turtle time = 26 17:48:27 Т.е. как бы у лямбдамена преимущество однозначно. 
nick = sectoid time = 26 17:48:27 больше простор для оптимизации 
nick = sectoid time = 26 17:48:40 вспоминаем SSA и задачу распределения регистров 
nick = sectoid time = 26 17:48:57 хотя может эффективнее будет придумывать алгоритм и писать ручками на ASM'е 
nick = turtle time = 26 17:50:2 По мне так вообще госта из примеров надо взять и засабмитить. :) И не тратить на него времени. 
nick = turtle time = 26 17:50:9 Хотя, как время будет, конечно. 
nick = turtle time = 26 17:50:29 Но вместо этого сделать сверх-умного лямбдамена. 
nick = grepz time = 26 17:50:46 Привет сектоид, тесты это круто. :) 
nick = grepz time = 26 17:50:59 Сильно их сегодня не хвататло 
nick = turtle time = 26 17:52:6 Либо если писать госта, то чисто на асме, без изысков. 
nick = turtle time = 26 17:52:13 С трансляторами облажаемся, думаю. 
nick = grepz time = 26 17:53:40 я тут маленько вывод pretty-print поправил, а то непонятно какая где функция 
nick = turtle time = 26 17:57:13 &quot;The Lambda-Man who scores the highest in a match wins against the other.&quot; 
nick = turtle time = 26 17:57:21 Да, на гостах можно не концентрироваться, думаю. 
nick = grepz time = 26 17:57:41 только если уменьшить шансы конкурентам 
nick = turtle time = 26 17:57:52 Ну да. 
nick = turtle time = 26 17:57:54 &quot;Stores the first Lambda-Man’s position in registers A (x-ordinate) and B (y-ordinate). In the single Lambda-Man version of the game, the first Lambda-Man is the only Lambda-Man.&quot; 
nick = turtle time = 26 17:57:58 Как вы это перевели? 
nick = grepz time = 26 17:58:44 вобщем смысл: гост знает где лямда-мэн, а лямбда мэн в игре всего один 
nick = turtle time = 26 18:1:1 Дьявол в деталях. :) 
nick = turtle time = 26 18:1:13 Что значит &quot;first Lamda-Man&quot;? 
nick = turtle time = 26 18:1:48 И дальше есть для второго лямбдамена. 
nick = grepz time = 26 18:1:54 орги хотели сделать многоплльзовательский вариант, но я так понял отказались, так что только 1 l-man теперь 
nick = turtle time = 26 18:2:14 Да ну навряд ли такое объяснение. 
nick = sectoid time = 26 18:2:19 grepz: сорри что проспал остаток lightning'а :( не услышал будильники 
nick = sectoid time = 26 18:2:30 да и не только grepz, но и все остальные 
nick = grepz time = 26 18:2:43 Да ладно, я сам себе на работе весь день зависал, так что не особо много пользы было. :) 
nick = grepz time = 26 18:3:2 Мы сегодня часа 3 наверное на отладку убили 
nick = turtle time = 26 18:5:12 sectoid: а там программа для гостов как хранится? Обычным текстом? 
nick = grepz time = 26 18:6:12 For the full round we will stick to the “classic” version of the game where it is just a single Lambda-Man against the ghosts, but your challenge now is to write an AI for the Lambda-Man and AIs for the ghosts. Your Lambda-Man AI will play matches against ghost AIs from an opposing team. 
nick = grepz time = 26 18:6:17 так что вот 
nick = turtle time = 26 18:6:57 Да, тоже читаю. 
nick = sectoid time = 26 18:6:58 grepz: где - там? 
nick = turtle time = 26 18:7:9 Мне кажется, будет ещё расширение спецификации попозже. 
nick = sectoid time = 26 18:7:15 мне тоже так кажется 
nick = turtle time = 26 18:7:15 Может, как раз по истечении двух суток. 
nick = sectoid time = 26 18:7:17 кстати 
nick = sectoid time = 26 18:7:23 теперь есть 3 тестовые карты 
nick = sectoid time = 26 18:7:29 подольете их в реп? 
nick = turtle time = 26 18:7:49 Ща. 
nick = sectoid time = 26 18:8:2 GCC&gt; (run-tests)<br />Start: GCC-TRANSLATOR-CORE<br />#&lt;Results for GCC-TRANSLATOR-CORE [28 Successful tests]&gt;<br /> 
nick = sectoid time = 26 18:8:5 дело идет) 
nick = sectoid time = 26 18:8:22 где там у нас были особо мерзкие баги сегодня? 
nick = grepz time = 26 18:8:33 Притом для гостов получается что они циклически программы запускают, то есть если всего 1, то все 4 госта будет с ней работать, если 2, то 2x2 
nick = grepz time = 26 18:8:57 в порядке операций на арифметику, cons и передачу аргументов в функции 
nick = sectoid time = 26 18:9:21 арифметику покрыл (всю) 
nick = sectoid time = 26 18:9:29 счас захвачу консы и прочее 
nick = grepz time = 26 18:9:42 и рекурсивные вызовы, плюс условия конечно 
nick = sectoid time = 26 18:10:5 хочу макры 
nick = sectoid time = 26 18:10:34 тогда можно было бы выделить core IL language, а остальное макрами навернуть 
nick = sectoid time = 26 18:10:47 и при отлаженом минимальном core IL, остальное автоматом тоже верное 
nick = sectoid time = 26 18:11:5 ну т.е. если что - проблема точно в тексте макры 
nick = turtle time = 26 18:11:38 Эт да. 
nick = sectoid time = 26 18:12:32 ловите начальный тест-сьют 
nick = sectoid time = 26 18:12:46 счас попробую еще на test-op привинтить на gcc-систему 
nick = sectoid time = 26 18:12:52 чтобы аще бубль-гум был 
nick = grepz time = 26 18:14:54 пропаду на время 
nick = sectoid time = 26 18:15:44 эээ 
nick = sectoid time = 26 18:15:55 у нас 2 pretty-print-gcc 
nick = grepz time = 26 18:16:2 ой 
nick = grepz time = 26 18:16:4 мой косяк 
nick = grepz time = 26 18:16:12 один момент 
nick = sectoid time = 26 18:16:51 grepz: и еще вопрос: а зачем ты делаешь (let (...) (bind (...) ...)) ? bind же может работать и let/let* 
nick = sectoid time = 26 18:17:21         (let ((unlabeled (eq 'unlabeled (first form))))<br />	  (bind (((op &amp;rest args) (if unlabeled<br />				      (rest form)<br />				      form)))<br />можно же<br />        (bind ((unlabeled (eq 'unlabeled (first form)))<br />               ((op &amp;rest args) (if unlabeled<br />			      (rest form)<br />			      form)))<br /> 
nick = sectoid time = 26 18:17:26 и вложеность ниже 
nick = grepz time = 26 18:17:35 убрал лишний pretty-print 
nick = grepz time = 26 18:17:59 Вообще это ф-ия Свиза, особой проблемы не вижу, главное что работает 
nick = grepz time = 26 18:18:49 так, если больше косяков нет, то я всё-таки пропаду 
nick = sectoid time = 26 18:19:36 ок, пропадай) 
nick = sectoid time = 26 18:21:40 теперь можно запустить тесты вот так:<br />(asdf:oos 'test-op :gcc)<br /><br />либо в SLIME REPL: , test-system gcc 
nick = sectoid time = 26 18:21:57 поправка: , test-system RET gcc RET 
nick = turtle time = 26 18:22:32 Отлично. 
nick = sectoid time = 26 18:27:0 пишу тесты дальше 
nick = sectoid time = 26 18:27:12 появились проблемы с gensym'ом и label'ами 
nick = sectoid time = 26 18:27:24 там у нас uninterned symbols 
nick = turtle time = 26 18:27:40 Да. 
nick = sectoid time = 26 18:28:20 и на них ensure-same валится 
nick = sectoid time = 26 18:28:37 вот думаю что лучше: интернировать их в keywords или писать кастомный сравниватель 
nick = sectoid time = 26 18:29:3 их делал grepz? 
nick = turtle time = 26 18:29:4 Так они же всё равно разные будут. 
nick = turtle time = 26 18:29:12 Я делал, наверное. Какая функция? 
nick = sectoid time = 26 18:30:17 с разными я заборолся уже 
nick = sectoid time = 26 18:30:22 в смысле со счетчиком 
nick = turtle time = 26 18:30:39 Как ты их заборол? 
nick = sectoid time = 26 18:31:27 (addtest (gcc-translator-core)<br />  if-1<br />  (ensure-same (bind ((*gensym-counter* 0))<br />                 (translate '(if 0 1 2)))<br />               '((:LDC 0) <br />                 (:SEL :TRUE0 :FALSE1)<br />                 (:LDC 1) <br />                 (:TSEL :END2 :END2)<br />                 (:LABEL :TRUE0)<br />                 (:LDC 1) <br />                 (:JOIN) <br />                 (:LABEL :FALSE1)<br />                 (:LDC 2) <br />                 (:JOIN) <br />                 (:LABEL :END2)))) 
nick = sectoid time = 26 18:31:44 и вот так:<br />	Modified   gcc/compiler.lisp<br />diff --git a/gcc/compiler.lisp b/gcc/compiler.lisp<br />index 90f5000..22b42f6 100644<br />--- a/gcc/compiler.lisp<br />+++ b/gcc/compiler.lisp<br />@@ -218,9 +218,12 @@<br />           :from-end t :initial-value nil))<br /> <br /> (defun translate-if (condition-form true-form false-form environment)<br />-  (let ((true-label (gensym &quot;true&quot;))<br />- 	(false-label (gensym &quot;false&quot;))<br />- 	(end-label (gensym &quot;end&quot;)))<br />+  (let ((true-label (intern (symbol-name (gensym &quot;TRUE&quot;)) <br />+                            (find-package :keyword)))<br />+ 	(false-label (intern (symbol-name (gensym &quot;FALSE&quot;)) <br />+                             (find-package :keyword)))<br />+ 	(end-label (intern (symbol-name (gensym &quot;END&quot;)) <br />+                           (find-package :keyword))))<br />     `(,@(translate-walker condition-form environment)<br />  	(:sel ,true-label ,false-label)<br />  	(:ldc 1)<br /> 
nick = sectoid time = 26 18:32:15 т.е. я интернирую метки в KEYWORD 
nick = sectoid time = 26 18:32:29 можно сделать пакет для меток какой-то, чтобы не засирать KEYWORD 
nick = sectoid time = 26 18:32:35 если есть желание 
nick = sectoid time = 26 18:32:36 =) 
nick = turtle time = 26 18:32:45 Да, в целом, по фигу, думаю. 
nick = sectoid time = 26 18:32:58 тогда пусть будет пока в keyword 
nick = turtle time = 26 18:33:1 Можно просто в строку перегнать. 
nick = sectoid time = 26 18:33:17 пусть символами будут 
nick = turtle time = 26 18:34:23 В целом, макросы можно обычными макросами прикрутить. 
nick = turtle time = 26 18:34:34 Без изысков. 
nick = sectoid time = 26 18:34:47 как? у нас же не вычисляются формы, а явно транслируется AST 
nick = turtle time = 26 18:34:55 Просто нужно будет сделать macroaxpand нашей формы. 
nick = turtle time = 26 18:35:2 Ну, пример. 
nick = sectoid time = 26 18:35:2 а, ну так - да, мона 
nick = turtle time = 26 18:35:13 GCC&gt; (defmacro plus (a b) `(+ ,a ,b)) 
nick = turtle time = 26 18:35:20 GCC&gt; (translate (macroexpand '(plus 1 2))) 
nick = turtle time = 26 18:35:27 ((:LDC 1) (:LDC 2) (:ADD))   
nick = turtle time = 26 18:35:36 И макросы иметь, и не геморроиться. :) 
nick = sectoid time = 26 18:35:45 а теперь попа: (translate (macroexpand '(+ 3 (plus 1 2)))) 
nick = sectoid time = 26 18:35:54 надо рекурсивно проходить 
nick = sectoid time = 26 18:35:59 и учитывать спец. формы 
nick = sectoid time = 26 18:36:14 что по сути сводится к описаному мною выше: macroexpand pass 
nick = turtle time = 26 18:36:39 Да, тогда надо в волкере экспаншн делать. 
nick = sectoid time = 26 18:37:32 угу 
nick = sectoid time = 26 18:37:47 но наверное родные макры использовать таки стоит 
nick = sectoid time = 26 18:37:53 чтобы удобно в SLIME было их отлаживать 
nick = turtle time = 26 18:38:46 Собственно, можно в валкере на ast macroexpand сделать с тановится всё хорошо. 
nick = turtle time = 26 18:38:59 Ты тесты закночил? 
nick = sectoid time = 26 18:39:3 не все 
nick = sectoid time = 26 18:39:5 но часть уже есть 
nick = sectoid time = 26 18:39:8 пишу еще дальше 
nick = sectoid time = 26 18:39:13 там много тонких камней 
nick = turtle time = 26 18:39:42 Хотя нет, так тоже не совсем получится. 
nick = turtle time = 26 18:39:47 Учитывая родные макры. 
nick = sectoid time = 26 18:40:1 а, хм 
nick = sectoid time = 26 18:40:13 можно сделать для макр отдельный пакадж 
nick = sectoid time = 26 18:40:19 не импортящий :cl 
nick = sectoid time = 26 18:40:30 чуть менее удобно, но в целом хорошо 
nick = turtle time = 26 18:40:44 Ну macroexpand будет на это смотреть? 
nick = sectoid time = 26 18:41:14 ну мы ж тогда будем писать явно макры из пакаджа с макрами 
nick = sectoid time = 26 18:41:32 аще по-хорошему нам засунуть весь ilisp в отдельный пакадж (который без :cl будет). 
nick = sectoid time = 26 18:41:39 чтобы не было конфликтов и не тащить лишнее 
nick = turtle time = 26 18:42:13 Идея неплохая, конечно.\ 
nick = sectoid time = 26 18:42:24 но объемная по времени 
nick = sectoid time = 26 18:42:30 и пока не совсем ясны профиты 
nick = sectoid time = 26 18:42:36 потому я пока в раздумьях 
nick = turtle time = 26 18:42:42 Ага. 
nick = sectoid time = 26 18:42:59 так, cond походу бажный у нас 
nick = turtle time = 26 18:43:38 А без :cl мы defmacro то сможем сделать? 
nick = turtle time = 26 18:43:40 Что там с cond? 
nick = turtle time = 26 18:45:17 Он простой весьма. 
nick = sectoid time = 26 18:45:23 он неверный) 
nick = turtle time = 26 18:45:26 Если бажный конд, то тогда when будет бажным. 
nick = sectoid time = 26 18:45:38 какие проблемы? (cl:defmacro ...) 
nick = sectoid time = 26 18:45:49 when не бажный, а вот cond - бажный 
nick = sectoid time = 26 18:46:5 там смесь проходов 
nick = sectoid time = 26 18:46:12 в смысле что транслейтится не то) 
nick = turtle time = 26 18:46:41 Ну ка покажи. 
nick = sectoid time = 26 18:47:43 сча, может я олень просто 
nick = sectoid time = 26 18:48:33 GCC-TEST&gt; (bind ((*gensym-counter* 0))<br />                 (translate '(cond (0 1))))<br />((:LDF (WHEN 0 1)) (:AP 0))<br /> 
nick = sectoid time = 26 18:48:35 таки да 
nick = sectoid time = 26 18:48:43 это несколько странная конструкция, не находишь?;) 
nick = sectoid time = 26 18:49:0 счас закоммичу фикс 
nick = sectoid time = 26 18:49:4 только тесты допишу 
nick = turtle time = 26 18:50:40 Так то слегонца сранная, да. :) 
nick = sectoid time = 26 18:51:42 еще баг 
nick = sectoid time = 26 18:51:51 cond это таки не последовательный when 
nick = sectoid time = 26 18:52:18 а скорее (if x1 y1 (if x2 y2 (if ...)) 
nick = sectoid time = 26 18:52:30 счас поправлю 
nick = sectoid time = 26 18:52:34 все-таки макры нужны 
nick = turtle time = 26 18:52:40 Ну это то да. Но можно и последовательным считать, если не до оптимизаций . 
nick = sectoid time = 26 18:52:51 последовательно будет неверный ответ 
nick = turtle time = 26 18:53:8 Если оконечную t не считать, то вполне верный. 
nick = sectoid time = 26 18:53:12 если мы приняли 1 условие - остальные даже не проверяются 
nick = turtle time = 26 18:53:21 Ну, смотря ещё как условия там набраны. 
nick = turtle time = 26 18:53:48 Скажем так - не всегда будет неверный ответ. Зависит от документации. :) 
nick = turtle time = 26 18:53:54 Но ладно, можешь фикс сделать. 
nick = sectoid time = 26 18:54:2 (cond <br />  (x1 y1)<br />  (x2 y2)<br />  (x3 y3))<br />если у нас выполнилось x2, то x3 даже не будет проверятся 
nick = sectoid time = 26 18:54:4 счас сделаю 
nick = turtle time = 26 18:54:41 Ну да, в классическом cond так и есть. 
nick = sectoid time = 26 18:54:53 а у нас другой cond? :) 
nick = sectoid time = 26 18:54:58 не-классический?) 
nick = turtle time = 26 18:55:8 У нас его всё равно пока никто не пользовал. Какой сделаем, такой и будет. :) 
nick = sectoid time = 26 18:55:26 счас схачу классический и тесты к нему 
nick = sectoid time = 26 18:55:50 или... может таки запилим макросистему и ряд проблем уйдет сам собой?) 
nick = turtle time = 26 18:56:28 Ну тут всё равно макросистема не оптимизнёт cond до того состояния, что ручками сделаешь. 
nick = turtle time = 26 18:56:36 А так надо бы, конечно. :) 
nick = sectoid time = 26 18:57:24 макросистема позволит написать этот cond очень прозрачно) 
nick = turtle time = 26 18:57:58 Макросистема много чего позволит прозрачно написать. 
nick = turtle time = 26 18:58:24 Но при это не шибко эффективно. Если борроться за эффективность + прозрачность, много копий можно обломать, думаю. 
nick = sectoid time = 26 18:59:9 ладн 
nick = sectoid time = 26 19:0:38 а что у нас даже вырожденый случай (cond) ? по идее 0 (местный анало nil) 
nick = turtle time = 26 19:2:30 Не знаю, кстати, не думал об этом. 
nick = sectoid time = 26 19:2:54 пусть будет 0 
nick = sectoid time = 26 19:13:39 о, у нас кривой when :) 
nick = sectoid time = 26 19:14:8 ну или нестандартный) 
nick = sectoid time = 26 19:14:19 что у нас должен возвращать when, если условие не выполнилось? 
nick = sectoid time = 26 19:14:28 стандартный должен возвращать 0 
nick = turtle time = 26 19:18:56 Опять про when? :) 
nick = sectoid time = 26 19:19:0 закинул обновленный when/cond 
nick = sectoid time = 26 19:19:3 и тесты к ним 
nick = turtle time = 26 19:19:20 А, там про cond было. :) 
nick = turtle time = 26 19:19:30 Я же тебе говорил, что если cond глючный, то и when глючный. 
nick = sectoid time = 26 19:19:36 поправил оба 
nick = sectoid time = 26 19:19:54 счас буду обкладывать тестами lambda/let/letrec и вызовы функций 
nick = turtle time = 26 19:20:20 ОК. 
nick = sectoid time = 26 19:20:46 (pretty-print-gcc<br /> (build-ai-core '(let ((init (lambda (initial-state unknown)<br />                               (cons 42 move))))<br />                  (init initial-state unknown))<br />                :debug nil))<br /> 
nick = sectoid time = 26 19:20:54 тут lambda излишняя имхо 
nick = sectoid time = 26 19:21:7 сам build-ai-core оборачивает все в лямбду 
nick = turtle time = 26 19:21:32 Это ты что смотришь? 
nick = turtle time = 26 19:21:34 l-man? 
nick = sectoid time = 26 19:21:49 ага 
nick = turtle time = 26 19:21:53 Ты его не трогай пока. 
nick = sectoid time = 26 19:21:58 оок, не трогая 
nick = turtle time = 26 19:22:1 Там ничего нинтересного. 
nick = turtle time = 26 19:22:6 И на удаление, наверное. 
nick = sectoid time = 26 19:22:8 я просто глянул - решил тебе намекнуть 
nick = sectoid time = 26 19:22:19 та вообще надо код слегка реорганизовать будет 
nick = turtle time = 26 19:22:31 Там можно и не слегка. :) 
nick = sectoid time = 26 19:22:38 ибо после тестов хотелось бы впилить макры и какой-то зачаток оптимизатора 
nick = turtle time = 26 19:24:20 Я там смотрю как можно макроэкспанд обычный заюзать. 
nick = turtle time = 26 19:34:47 В отдельном пакете макры норм работают, в целом. 
nick = turtle time = 26 19:35:58 Надо теперь подумать как это всё организовать. 
nick = turtle time = 26 19:36:2 Как вызывать компиляцию и т.д. 
nick = turtle time = 26 19:36:22 Чот я выпрямить не могу, буквой Г стал. :) 
nick = turtle time = 26 19:36:27 Отдохну чутка. 
nick = sectoid time = 26 19:37:20 а у нас cons точно верно работает? 
nick = sectoid time = 26 19:38:50 ололо, неверно) 
nick = sectoid time = 26 19:39:40 а не, cons верно. list/tuple неверно) 
nick = turtle time = 26 19:44:24 cons точно верно. 
nick = turtle time = 26 20:21:58 Карты могут быть 256 на 256. 
nick = turtle time = 26 20:22:15 Самая большая длина сколько? 32? Если пустая. 
nick = sectoid time = 26 20:25:16 длина чего? 
nick = sectoid time = 26 20:25:20 или ты про level? 
nick = sectoid time = 26 20:29:25 привет, свиз 
nick = swizard time = 26 20:29:31 привет 
nick = swizard time = 26 20:29:37 как тут оно :) 
nick = sectoid time = 26 20:29:43 ничеготак 
nick = sectoid time = 26 20:29:45 немного тестов есть 
nick = sectoid time = 26 20:30:1 часть багов починил в cond/list/tuple/еще чем-то 
nick = sectoid time = 26 20:30:6 есть мысли что делать дальше 
nick = sectoid time = 26 20:32:15 и еще мне похоже надо сделать паузу 
nick = swizard time = 26 20:32:48 да не вопрос, я там пока походу локализовал неприятный баг 
nick = swizard time = 26 20:32:53 а как тесты устроены? 
nick = turtle time = 26 20:33:35 Длина пути до цели. 
nick = sectoid time = 26 20:33:58 тесты - транслируем выражение - сравниваем с эталоном 
nick = sectoid time = 26 20:34:4 эталоны выверял глазками 
nick = sectoid time = 26 20:34:10 тесты в репе, можешь глянуть 
nick = swizard time = 26 20:34:11 ага, ок, а как их вызывать? 
nick = swizard time = 26 20:34:26 я бы добавил ещё один на вложенные замыкания 
nick = swizard time = 26 20:34:32 который щас ломается как раз 
nick = swizard time = 26 20:35:44 в examples/experiment.lisp как раз код, который неправильно компилируется в gcc 
nick = sectoid time = 26 20:36:37 [17:21:40] &lt;sectoid&gt; теперь можно запустить тесты вот так:<br />(asdf:oos 'test-op :gcc)<br /><br />либо в SLIME REPL: , test-system gcc 
nick = sectoid time = 26 20:39:7 мне наверное таки надо проветриться 
nick = swizard time = 26 20:39:44 во тесты работают, класс, спасибо 
nick = swizard time = 26 20:39:57 давай, я прогулялся — стало существенно лучше :) 
nick = sectoid time = 26 20:40:23 давай расскажу вкратце состояние и мысли 
nick = sectoid time = 26 20:40:31 текстом или созвонимся все скупом? 
nick = swizard time = 26 20:40:32 давай 
nick = swizard time = 26 20:40:45 лучше текстом, чтобы подошедшие тоже могли прочитать 
nick = turtle time = 26 20:42:9 Давайте обсужать. 
nick = turtle time = 26 20:42:23 Из главного - на когд госат 256 байтов и столько же область данных. 
nick = turtle time = 26 20:42:29 Не разгуляешься. 
nick = turtle time = 26 20:42:50 Если мы насчнём транслировать в ghc, то туда надо нехилый написать оптимизатор. 
nick = turtle time = 26 20:42:53 Как мне кажется. 
nick = turtle time = 26 20:43:25 Победа считается по набранным очкам лямбдамена. Гост может только вражескому лябдамену очки подрезать. 
nick = sectoid time = 26 20:43:46 1. макросы. они очень просятся в наш ILisp. обсуждали варианты реализации, выкристаллизовалось 2 варианта:<br />  а) что-то вроде deflib/gcc, но для макр<br />  б) штатный defmacro и пакет без импорта cl (чтобы лишнее не подматывалось)<br />В обоих случаях нужен macro expansion phase. <br /><br />2. разделить package'и. как по мне, ilisp должен аще весь жить в отдельном пакете, чтобы не перемешиваться с common lisp<br />3. есть лимит на 1М инструкция в лямбда-мене. пока вроде достаточно, но уже начинает хотется оптимизатор<br />4. в гостах вообще 256 инструкций. может будем госто-проги писать руками на asm? 
nick = sectoid time = 26 20:44:39 5. нам таки нужен AI для LM 
nick = sectoid time = 26 20:44:59 /me ничерта не понимает в AI, но готов возится с компиляторами/трансляторами 
nick = swizard time = 26 20:45:19 ага, примерно понятно 
nick = swizard time = 26 20:45:25 давайте тогда так спланируем 
nick = swizard time = 26 20:46:11 самое важное — это AI для пакмана, но его очень мучительно делать без макр и бажным транслятором, поэтому эти два пункта давайте попробуем сегодня закрыть 
nick = swizard time = 26 20:46:24 разделить пакаджи — ок 
nick = swizard time = 26 20:46:52 в лимит мы пока не упираемся, но с макрами сможем, имхо :) 
nick = sectoid time = 26 20:47:6 свиз, для аи имхо важен алгоритм 
nick = sectoid time = 26 20:47:15 который можно вообще параллельно на CL вертеть 
nick = swizard time = 26 20:47:17 и да, нужен хотя бы один мембер команды, который сядет за гоустов 
nick = swizard time = 26 20:47:33 с АИ у меня есть несколько идей 
nick = swizard time = 26 20:47:55 можно их будет все попробовать в порядке возрастающей сложности 
nick = sectoid time = 26 20:48:11 у меня по AI из идей было только сканирование карты, превращение в граф путей, и дальше уже наложение на этот граф условий (тэгов) по ходу раунда 
nick = sectoid time = 26 20:48:37 можешь попробовать начать реализовывать AI на CL, при это стараясь использовать минимум хитрых форм? 
nick = sectoid time = 26 20:48:45 defmacro я тебе для IL обеспечу 
nick = swizard time = 26 20:49:19 если освоим макры и библиотеки для CL, то я бы попробовал начать с двух вещей: pathfinding (в идеале a*, но там надо думать как сеты представлять в IL), и локатор объектов на карте 
nick = sectoid time = 26 20:49:28 в идеале:<br /> написать клевый ai в пакадже lamba-man-ai, потом заменить в этом пакадже (:use :cl) на (:use :il) и радоваться 
nick = sectoid time = 26 20:49:32 вот либы я не обещаю( 
nick = turtle time = 26 20:49:35 По гостам предлагаю руками тупо сделать волновой алгоритм для пакмана. 
nick = turtle time = 26 20:49:45 Что-то ещё там городить - хз. 
nick = swizard time = 26 20:49:45 тогда можно первым этапом тупо ходить за power-cell’ами 
nick = turtle time = 26 20:49:55 Чуть позже хотел сесть за гостов. 
nick = swizard time = 26 20:49:55 да, волновой можно 
nick = sectoid time = 26 20:49:59 turtle: возьмешься его запилить? 
nick = turtle time = 26 20:50:7 Да, сяду за него чуть позже. 
nick = sectoid time = 26 20:50:24 turtle: ты хочешь его делать на каком'то il' или на asm сразу? 
nick = turtle time = 26 20:50:33 Я на асме хочу делать. 
nick = sectoid time = 26 20:50:37 о, годно 
nick = turtle time = 26 20:50:41 Но там ещё вопрос, у нас очень лимитировано памяти. 
nick = sectoid time = 26 20:50:44 еще есть секция AI, которая должна ловить паттерны в &quot;мозгах&quot; гостов 
nick = swizard time = 26 20:50:55 только не забудь разворачиваться, когда пакман таблетку съест :) 
nick = sectoid time = 26 20:50:56 самое простое: ловить &quot;слепых&quot; гостов 
nick = turtle time = 26 20:51:3 IL, боюсь, выжрет кучу инструкций и ничего не останется. :) 
nick = sectoid time = 26 20:51:31 turtle: отлично. и если делать на asm сразу, то убирается завязка на написание/!отладку! трансляторов 
nick = swizard time = 26 20:51:44 ладно, а я тогда попробую сейчас сконцентрироваться на багфиксе IL-&gt;GCC 
nick = turtle time = 26 20:51:52 Потом, что нам нужно будет потом пакману - нужно будет интерпретатор гостов делать на IL, чтобы пакман мог прикидывать. 
nick = turtle time = 26 20:51:59 Но это потом, наверное, да. 
nick = sectoid time = 26 20:52:1 в принципе можешь сконцентрироваться на AI 
nick = turtle time = 26 20:52:13 Пока для волнового алгоритма не хватет памяти для самой большой карты. 
nick = sectoid time = 26 20:52:16 я через полчасика-часик вернусь и плотно займусь ILispom 
nick = sectoid time = 26 20:52:20 ILisp'ом 
nick = turtle time = 26 20:52:24 Да и самая маленькая тоже еле влазит. 
nick = sectoid time = 26 20:52:36 я все-равно в ии мало полезен 
nick = swizard time = 26 20:52:51 а если тупо перебирать варианты с бектрекингом с минимальным лимитом? 
nick = swizard time = 26 20:52:57 для гоустов 
nick = turtle time = 26 20:53:5 А что там бектрекать? 
nick = swizard time = 26 20:53:18 ну чтобы гоуст вокруг ёлки не ходил кругами 
nick = turtle time = 26 20:53:31 Аа. 
nick = sectoid time = 26 20:53:34 /me убег на минут 30-60 
nick = turtle time = 26 20:53:58 Ну сделать, чтобы он шёл на сокращение расстояния с пакманом, пр иэтом вся карта не влазит, волновой алгоритм один в один не подойдёт. 
nick = sectoid time = 26 20:54:51 а у нас есть лимит на cpu time для госта? 
nick = swizard time = 26 20:54:55 сделай гоустам туман войны :) 
nick = swizard time = 26 20:55:6 ограничь его зону видимости допустим 32x32 
nick = sectoid time = 26 20:55:7 если нет, то может в каждом цикле сканировать карту и искать вектор движения? 
nick = swizard time = 26 20:55:17 и волновым алгоритмом 
nick = swizard time = 26 20:55:31 если пакман слишком далеко, то всё равно бестолку за ним охотится 
nick = turtle time = 26 21:15:2 Лимит на cpu time есть. 
nick = turtle time = 26 21:15:10 32 х 32 - уже до фига. 
nick = turtle time = 26 21:15:17 В память лезет только 16х16. :) 
nick = turtle time = 26 21:15:48 Я думаю, надо просто делить на большие квадратики. По ним работает волновой алгоритм. Потом по меньшему квадратику и т.д. 
nick = turtle time = 26 21:16:4 Почти как PNG когда грузится на медленных каналах. 
nick = swizard time = 26 21:16:58 ну можно попробовать 
nick = swizard time = 26 21:17:8 хотя я не очень представляю, как это на асме написать 
nick = grepz time = 26 21:17:46 А что если так: гост знает положение до пакмана, он может построить путь до него насколько хватает ресурсов(требуется посчитать), всё что дальше считается прямым путём, сделал шаг, область видимости изменилась, пересчитал путь. Плюс отслеживать уже пройденное на сколько-то ходов, чтобы в тупик не попасть.  
nick = grepz time = 26 21:18:24 Хотя там ресурсов то всего ничего 
nick = grepz time = 26 21:19:8 Или просто на изгибах коридоров выруливать в сторону пакмана 
nick = swizard time = 26 21:19:17 кстати оффтопик: тут в трансляторе IL мне пришла такая мысль: правильно ли я понимаю, что при генерации кода можно смело все последовательности (:AP ..) (:RTN) менять на (:TAP …) (:RTN) ?   
nick = swizard time = 26 21:19:58 у нас же без progn вообще все вызовы кроме аргументов функции — это tail call 
nick = swizard time = 26 21:20:25 я руками щас в тестовом асме попробовал — вроде работает 
nick = grepz time = 26 21:21:27 а LDC не помешает? 
nick = swizard time = 26 21:21:28 хотя там есть TAP, а есть TRAP … 
nick = swizard time = 26 21:21:38 а как он помешает? 
nick = grepz time = 26 21:22:33 сейчас попробую 
nick = grepz time = 26 21:30:47 вроде норм 
nick = swizard time = 26 21:33:32 попробуем имплементировать? 
nick = swizard time = 26 21:33:42 я вроде не вижу что это может сломать 
nick = grepz time = 26 21:33:58 ну я тоже руками позаменял, везде работает 
nick = grepz time = 26 21:34:4 так что наверное стоит 
nick = swizard time = 26 21:34:25 единственно, я не понял, когда надо TRAP 
nick = swizard time = 26 21:34:33 для вызовов самого себя? 
nick = grepz time = 26 21:35:52 frame pointer must point to an empty frame of size $n; в этой фразе разница 
nick = swizard time = 26 21:36:14 а, тоесть это вместо RAP 
nick = grepz time = 26 21:36:19 да 
nick = grepz time = 26 21:36:27 AP - TAP, RAP - TRAP 
nick = grepz time = 26 21:36:33 там в notes так и сказано 
nick = swizard time = 26 21:36:40 тогда RAP+RTN можно менять на TRAP-RTN :) 
nick = grepz time = 26 21:36:47 получается так 
nick = swizard time = 26 21:37:10 имплементируешь? а то я уже просто в другой ветке вожусь 
nick = grepz time = 26 21:37:25 ок 
nick = sectoid time = 26 21:39:52 /me вернулся 
nick = sectoid time = 26 21:40:10 а если хранить не 1 точку в байте, а меньше? 
nick = sectoid time = 26 21:40:17 у нас вроде есть and/or/xor/not? 
nick = sectoid time = 26 21:40:27 тогда втиснуть можно больше 
nick = grepz time = 26 21:41:57 а что-нибудь ломали? А то experiment.lisp фолтится с IllegalAddr. 
nick = grepz time = 26 21:42:20 оу, вижу 
nick = swizard time = 26 21:42:49 experiment.lisp который в мастере это как раз я код закоммитил, который криво генерируется 
nick = grepz time = 26 21:43:11 да, я уже увидел. :) 
nick = sectoid time = 26 21:45:58 есть что-то срочное по задачам? или я займусь подчисткой кода и макрами? 
nick = swizard time = 26 21:46:16 срочного пока ничего нет 
nick = sectoid time = 26 21:46:23 макры кто-то щупал? 
nick = swizard time = 26 21:46:29 я тут окончательно запутался с этими environment frames 
nick = sectoid time = 26 21:46:44 а что с ними там? 
nick = swizard time = 26 21:47:50 там какая-то фигня, я не могу понять, как правильно расчитать первый аргумент инструкции LD для вызова letrec-функции 
nick = swizard time = 26 21:48:10 фрейм каждый раз создаётся при funcall-e 
nick = swizard time = 26 21:48:42 как я могу на этапе компиляции понять, какой у меня в данной точке программы фрейм? :( 
nick = swizard time = 26 21:48:55 полный граф вызовов строить чтоли 
nick = swizard time = 26 21:51:18 или может хакерски всегда неявно добавлять к вызовам функций все letrec адреса, чтобы их можно из нулевого фрейма взять :) 
nick = swizard time = 26 21:52:28 пойду кофе намучу и подумаю 
nick = sectoid time = 26 21:54:42 хм, попробую тоже в это въехать 
nick = sectoid time = 26 21:54:56 а то мне не очень нравится наша реализация let/letrec/lambda 
nick = swizard time = 26 21:56:57 давай 
nick = turtle time = 26 22:1:10 Так по этому, как его называется, лексическому скопу. Который на этапе компиляции и виден. 
nick = turtle time = 26 22:1:31 Евала нет. 
nick = swizard time = 26 22:1:36 ну с переменными это (вроде бы) так 
nick = turtle time = 26 22:1:37 Так что всё нормально должно быть. 
nick = swizard time = 26 22:1:49 а с летрек-биндами ужё чёто нет 
nick = swizard time = 26 22:1:55 вот глянь experiment.lisp 
nick = swizard time = 26 22:2:39 по лексическому скоупу в функции f биндинг rec должен лежать по LD 1 0 
nick = swizard time = 26 22:2:47 а по-факту это LD 2 0 
nick = swizard time = 26 22:2:57 потому что мы туда попадаем через вызов g 
nick = turtle time = 26 22:3:34 Ага. И чем больше вызываем, тем дальше? 
nick = swizard time = 26 22:3:54 да 
nick = swizard time = 26 22:4:17 откуда я там пойму на этапе трансляции, через сколько функций я сюда пришёл 
nick = swizard time = 26 22:4:37 а если ещё я и разными путями сюда прийти могу, то ваще беда  
nick = turtle time = 26 22:4:47 Либо с лямбдами что-то не то. 
nick = turtle time = 26 22:5:5 Да вообще связка да, какая-то динамичная. 
nick = swizard time = 26 22:5:45 с лямбдами кривовато, конечно, но там хотя бы логика работающая под алгоритмом 
nick = sectoid time = 26 22:5:51 я тут счас пытаюсь реализовать классические CL'ные let/lambda/labels через эту извращеную лисп-машину 
nick = swizard time = 26 22:6:23 по-крайней мере, все скоупы для переменных работают 
nick = swizard time = 26 22:6:49 а с летреком засада, он в нефиксированном фрейме каждый раз находится :( 
nick = swizard time = 26 22:7:0 видимо, надо программировать какой-то хак  
nick = swizard time = 26 22:7:21 чтобы эти летреки вверх всегда передавать при вызове функций 
nick = swizard time = 26 22:7:42 чтобы всегда было понятно в каком фрейме биндинг 
nick = sectoid time = 26 22:11:3 блин, от RAP/AP/DUM башка болеть начинает( 
nick = swizard time = 26 22:11:44 а прикинь я это вчера в час ночи программировал =) 
nick = swizard time = 26 22:12:38 так, ладно, попробую все рекурсивные биндинги неявно через параметры носить 
nick = swizard time = 26 22:12:50 других идей пока что всё равно нет 
nick = sectoid time = 26 22:16:59 Верно ли что:<br /><br />(let ((x1 v1)<br />      (x2 v2)<br />      ...<br />      (xN vN))<br />  ...)<br />эквивалентно<br />(ap (lambda (x1 x2 .. xN) ...) v1 v2 ... vN)<br /><br />в то время как<br />(letrec ((x1 v1)<br />         (x2 v2)<br />         ...<br />         (xN vN))<br />  ...)<br /><br />эквивалентно<br /><br />(rap (lambda (x1 x2 .. xN) ...) v1 v2 ... vN)<br />? 
nick = sectoid time = 26 22:17:5 я пытаюсь навести красоту в голове 
nick = swizard time = 26 22:17:51 ну не совсем 
nick = sectoid time = 26 22:18:21 вкуриваю дальше 
nick = swizard time = 26 22:18:56 rap вообще нужен, насколько я понял, только в паре с dum 
nick = sectoid time = 26 22:19:2 ага 
nick = sectoid time = 26 22:19:23 потому в этой конструкции его нет, ибо dum тут деталь реализации) 
nick = sectoid time = 26 22:19:34 я пытаюсь просто заново вкурить разницу между ap/rap 
nick = swizard time = 26 22:20:30 в случае с летрек я сначала, грубо говоря, делаю фрейм через дум, складываю туда все летрек-бинды, и через rap вызываю хелперную функцию  
nick = swizard time = 26 22:20:42 сам rap просто фрейм ведь не создаёт 
nick = sectoid time = 26 22:21:10 да 
nick = sectoid time = 26 22:21:44 встает вопрос: а если бы мы положили на стек значения биндов, и потом сказали бы ap -- что бы изменилось? 
nick = sectoid time = 26 22:22:23 rap там другие манипуляции с current environment выполняет 
nick = sectoid time = 26 22:23:2 хотя вроде даже эквивалентные... 
nick = swizard time = 26 22:23:21 на самом деле вопрос любопытный, можно проверить 
nick = swizard time = 26 22:23:31 в теории ты рекурсивно функцию звать не сможешь 
nick = grepz time = 26 22:24:38 блин, я с ap-&gt;tap походу все условия поломал. что-то похоже упускаю. 
nick = sectoid time = 26 22:25:22 мучаю эмулятор 
nick = sectoid time = 26 22:26:41 аы 
nick = sectoid time = 26 22:26:44 аыыыы 
nick = sectoid time = 26 22:26:47 кажется понимаю 
nick = sectoid time = 26 22:26:50 счас надо проверить 
nick = sectoid time = 26 22:28:54 да, все дело в манипуляциях с parent frame pointer 
nick = sectoid time = 26 22:29:21 счас еще повкуриваю и смогу написать правильные let/letrec/lambda 
nick = sectoid time = 26 22:33:56 дело в dum 
nick = sectoid time = 26 22:34:4 и в особенностях работы ldf 
nick = sectoid time = 26 22:34:19 ldf проставляет указатель на контекст closure cell'а на _текущий_ фрейм 
nick = sectoid time = 26 22:35:6 заметка себе на будущее: если терм у нас внутренне полностью замкнут (т.е. нет свободных переменных) - его точно не надо rap 
nick = swizard time = 26 22:35:51 хм, я не очень понял, если честно отличия :) 
nick = turtle time = 26 22:38:27 Почему не надо? 
nick = sectoid time = 26 22:39:9 turtle: потому, что ему не нужны переменные из родительского scope 
nick = sectoid time = 26 22:39:13 или я опять запутался... 
nick = grepz time = 26 22:39:45 почему не нужны? 
nick = sectoid time = 26 22:40:5 потому, что он не имеет свободных переменных 
nick = sectoid time = 26 22:40:9 так, надо додумать 
nick = turtle time = 26 22:40:30 И что нам это даст? 
nick = turtle time = 26 22:40:43 Он же фрейм всё равно создаст. 
nick = sectoid time = 26 22:41:7 надо додумать. я похоже снова запутался:( 
nick = sectoid time = 26 22:49:56 хм. а никому эти scope'ы не напоминают region inference? 
nick = swizard time = 26 22:50:36 а что это? :) 
nick = sectoid time = 26 22:50:46 http://en.wikipedia.org/wiki/Region-based_memory_management 
nick = sectoid time = 26 23:0:21 experiment.lisp счас бажный? 
nick = swizard time = 26 23:0:33 да, но я его почти починил  
nick = sectoid time = 26 23:0:45 ты чинишь компилятор? 
nick = sectoid time = 26 23:1:2 через хак с протягиванием номера скопа? 
nick = swizard time = 26 23:1:47 да, только не номера скоупа, а прямо сами биндинги я неявными параметрами передаю в каждом функолле внутри скоупа letrec 
nick = swizard time = 26 23:2:5 вроде работает, правда пока не везде :) 
nick = swizard time = 26 23:2:10 щас допинаю, наверно 
nick = sectoid time = 26 23:2:31 ок 
nick = sectoid time = 26 23:13:3 скажешь как допинаешь? 
nick = swizard time = 26 23:13:37 ща минут 15 ещё 
nick = swizard time = 26 23:13:58 ветку env-refactoring потом смержишь в мастер, если всё ок будет? :) 
nick = sectoid time = 26 23:14:4 оок 
nick = swizard time = 26 23:14:10 а то походу только ты мержить умеешь =) 
nick = sectoid time = 26 23:15:47 я пока додумываю перераскладку этого дела и впиливание макр 
nick = sectoid time = 26 23:31:0 пытаюсь сделать транслятор таки через generic'и. чтобы можно было дополнительные pass'ы добавлять 
nick = swizard time = 26 23:45:25 блин, всё уже работает, но теперь сломалась top-level lambda :( 
nick = sectoid time = 26 23:46:53 бггг) 
nick = sectoid time = 26 23:47:0 а что выдает? 
nick = swizard time = 26 23:47:34 да там понятная проблема, в хипе ведь должны с самого начала параметры лежать initial-state + unknown 
nick = swizard time = 26 23:48:4 а я потом делаю dum, и эти параметры типа индексируются на единицу больше 
nick = swizard time = 26 23:48:26 ща попробую поиграться с порядком в неявных аргументах 
nick = sectoid time = 26 23:58:31 swizard: ты макры хочешь с destructuring lambda-list или пусть его обычный будет? 
nick = swizard time = 26 23:59:15 ну я пока не знаю… если там какая-то dsl-ка будет, то с деструктурингом удобней конечно будет 
nick = sectoid time = 26 23:59:37 я пока наивняк делаю 
nick = sectoid time = 26 23:59:49 ибо опят застопорился с generic'зацией компилятора( 
nick = sectoid time = 27 0:11:55 кто там хотел макросов? 
nick = sectoid time = 27 0:11:56 ;) 
nick = swizard time = 27 0:12:32 =) 
nick = swizard time = 27 0:13:0 блин я в печали :) 
nick = sectoid time = 27 0:13:9 чего ты в печали? 
nick = turtle time = 27 0:13:28 Что случилось? 
nick = swizard time = 27 0:14:9 походу обламывается моя идея с передачей рекурсивных биндов в неявных параметрах при вызове функций 
nick = swizard time = 27 0:14:19 как бы всё ок работает 
nick = swizard time = 27 0:14:37 но там один момент получается:  
nick = sectoid time = 27 0:14:37 а что не так тогда? 
nick = swizard time = 27 0:15:0 вот в программе бота функция инициализации возвращает state и замыкание step 
nick = sectoid time = 27 0:15:10 так 
nick = swizard time = 27 0:15:25 и привет, этот step зовётся уже вне контекста letrec, и ему явных параметров не передают :( 
nick = swizard time = 27 0:15:31 в смысле, неявных 
nick = swizard time = 27 0:16:3 короче надо подумать 
nick = sectoid time = 27 0:16:51 [23:15:25] &lt;swizard&gt; и привет, этот step зовётся уже вне контекста letrec, и ему явных параметров не передают :(<br /><br />эээ? как это не передают? 
nick = sectoid time = 27 0:16:58 step'у дают 2 параметра 
nick = sectoid time = 27 0:17:20 или ты имеешь в виду что в коде нашей программы нет вызовов step'а? 
nick = swizard time = 27 0:18:11 ну да, просто сам step в рекурсивном контексте letrec, и у меня типа хак, что ему передаётся не только 2 параметра, но и неявный третий — адрес step 
nick = swizard time = 27 0:18:30 ну или даже четвёртый — адрес nth в варианте bumper-ai 
nick = sectoid time = 27 0:18:36 бррр 
nick = sectoid time = 27 0:18:38 я запутался) 
nick = swizard time = 27 0:18:56 ну короче не бери в голову пока, может, вообще всю ветку дропнуть надо будет :) 
nick = swizard time = 27 0:19:29 чёрт, ну почти сложилось же 
nick = sectoid time = 27 0:19:30 если что - там есть уже макры в мастере 
nick = swizard time = 27 0:19:49 а как ими пользоваться? 
nick = swizard time = 27 0:20:10 бтв а гоустами никто ещё не занимался пока? :) 
nick = sectoid time = 27 0:20:38 turtle вроде занимался 
nick = sectoid time = 27 0:20:47 или нет? 
nick = turtle time = 27 0:20:58 Я занимаюсь. 
nick = turtle time = 27 0:21:13 Но я ещё только себе парсер пишу пока. 
nick = turtle time = 27 0:21:20 Чтобы нормально можно было лабелы расставлять. 
nick = swizard time = 27 0:23:18 ага, ок 
nick = swizard time = 27 0:26:0 хмм, а фрейм после DUM не дропается чтоли после RTN? 
nick = sectoid time = 27 0:26:47 должен дропаться 
nick = sectoid time = 27 0:26:56 наверное 
nick = turtle time = 27 0:27:16 Кстати, вроде в спеке уточнение было по этому поводу. 
nick = turtle time = 27 0:27:20 УЖе не помню какое. 
nick = swizard time = 27 0:27:35 походу если куда-то наружу вернуть адрес одной из функций в созданном DUM фрейме, то не дропается 
nick = sectoid time = 27 0:28:5 там что-то было насчет того, что если ссылок нет - убьется сразу, иначе - gc 
nick = sectoid time = 27 0:28:16 swizard: есть еще одна мыслишка. можно трансформировать IL -&gt; IR -&gt; GCC. В IR заменять обращения к переменным ссылками на соотв. scope и потом отдельным проходом нумеровать их 
nick = swizard time = 27 0:29:31 во The latest hardware revision optimizes the deallocation of the <br />  environment frame. If the environment has not been captured by LDF<br />  (directly or indirectly) then it can be immediately deallocated.<br />  Otherwise it is left for GC. 
nick = sectoid time = 27 0:29:56 угу 
nick = sectoid time = 27 0:30:12 я думал что на этом можно попробовать какую-то оптимизацию запупенить 
nick = sectoid time = 27 0:32:27 мне наверное надо проветрится 
nick = sectoid time = 27 0:32:34 подумаю над IL/IR 
nick = sectoid time = 27 0:32:37 и лекс. скопами 
nick = swizard time = 27 0:32:41 давай 
nick = sectoid time = 27 0:32:47 заодно променад катну 
nick = sectoid time = 27 0:33:5 свиз, если у тебя есть идеи насчет ИИ для лямбда-мена, может стоит попробовать реализовать их на CL? 
nick = sectoid time = 27 0:33:25 вынося функции/макры на которые опираешься в отдельное место в файле 
nick = swizard time = 27 0:33:30 тогда нужен эмулятор пакмана на кл :) 
nick = sectoid time = 27 0:33:43 а что там так нужно ? 
nick = sectoid time = 27 0:33:47 считал что у тебя CL 
nick = sectoid time = 27 0:33:51 тока порезаный сильно 
nick = sectoid time = 27 0:34:13 простые заглушечные костыли для отладки пишутся по идее не сложно 
nick = sectoid time = 27 0:34:29 т.е. заглушка дампа мира, состояния гхостов и т.п. 
nick = swizard time = 27 0:34:30 но проверять-то как-то надо 
nick = swizard time = 27 0:34:37 в смысле, на эмуляторе 
nick = swizard time = 27 0:34:55 так я только корректность компиляции проверю :) 
nick = sectoid time = 27 0:34:59 поиграй пока с самими алгоритмами) 
nick = sectoid time = 27 0:35:6 потом устроим debugging night ;) 
nick = swizard time = 27 0:35:25 ну посмотрим, может, так и надо сделать 
nick = sectoid time = 27 0:35:56 а я на свежем воздухе подумаю как сделать правильную работу со скопами 
nick = sectoid time = 27 0:36:2 у меня почти получилось на бумаге 
nick = swizard time = 27 0:36:25 окей 
nick = swizard time = 27 0:53:17 мда, проблема, конечно, с этими рекурсивными биндами 
nick = swizard time = 27 0:53:41 вот вижу я в коде, что происходит вызов функции 
nick = swizard time = 27 0:53:57 я могу понять, что это вызов letrec 
nick = swizard time = 27 0:54:13 я даже знаю в какой слот фрейма я положил эту функцию 
nick = swizard time = 27 0:54:25 а вот какой по номеру этот фрейм — узнать не могу  
nick = swizard time = 27 0:54:55 ваще нет идей :) 
nick = swizard time = 27 0:57:58 а не есть 
nick = turtle time = 27 0:58:45 Это хорошо. :) 
nick = swizard time = 27 1:7:3 о, первые успехи =) 
nick = swizard time = 27 1:7:14 короче, общий смысл такой  
nick = swizard time = 27 1:7:40 1. оставляем весь этот механизм с протаскиванием рекурсивных биндов в неявных параметрах 
nick = swizard time = 27 1:8:12 2. наружу никогда не возвращаем что-то изнутри скоупа letrec 
nick = swizard time = 27 1:8:49 3. вместо этого возвращаем просто результат LDF на обычную функцию 
nick = swizard time = 27 1:9:3 в этом случае нет проблем с неявными параметрами 
nick = swizard time = 27 1:9:49  ветка env-refactoring 
nick = swizard time = 27 1:9:58 я там и бота чуток переписал 
nick = swizard time = 27 2:9:15 http://newstar.rinet.ru/~goga/sicp/sicp.pdf страница 548 — наши фреймы и скоупы :) 
nick = turtle time = 27 2:10:39 В своё время я до туда не дочитал. 
nick = swizard time = 27 2:12:3 ну собственно мы так и сделали 
nick = swizard time = 27 2:12:9 как там написано 
nick = swizard time = 27 2:13:8 даже хелперы и тип окружения почти 1:1 
nick = swizard time = 27 2:13:59 так ну ладно, про летрек я там всё равно сходу найти не могу 
nick = sectoid time = 27 2:25:14 получилось? 
nick = swizard time = 27 2:25:48 ну как сказать… будем считать, что это частное решение :)  
nick = sectoid time = 27 2:26:13 у меня в голове решение есть, счас попробую превратить в код) 
nick = swizard time = 27 2:26:25 с летреком в этом месте я разобрался, но нарыл новую проблему со скоупом, на этот раз переменных 
nick = swizard time = 27 2:26:29 во давай :) 
nick = swizard time = 27 2:26:37 было бы круто домучить сегодня транслятор :) 
nick = sectoid time = 27 2:26:42 домучим 
nick = swizard time = 27 2:28:5 вот тебе тогда тест, который щас сломан: 
nick = swizard time = 27 2:28:6 (let ((f (lambda (x)<br />           (let ((g (lambda (y) (+ x y))))<br />             (let ((h (lambda (y) (g y))))<br />               (h 4))))))<br />  (f 17)) 
nick = sectoid time = 27 2:28:45 оок, счас буду ковырять 
nick = swizard time = 27 2:29:11 или вот даже более хардкорно: 
nick = swizard time = 27 2:29:12 (let ((f (lambda (x)<br />           (let ((g (lambda (y) (+ x y))))<br />             (let ((h (lambda (y) (g y))))<br />               (+ (h 4) (g 4)))))))<br />  (f 17)) 
nick = swizard time = 27 2:29:33 тут ваще диллема от которой у меня башка взрывается :) 
nick = swizard time = 27 2:30:7 может инлайнить всё к чертям собачьим 
nick = sectoid time = 27 2:30:7 а что тут не так?) 
nick = swizard time = 27 2:30:16 ну тут смотри какая беда 
nick = swizard time = 27 2:30:22 она в функции g 
nick = swizard time = 27 2:30:34 внутри неё есть обращение к переменной x 
nick = swizard time = 27 2:30:39 вот где она? :) 
nick = sectoid time = 27 2:30:48 сча, отиндентчу 
nick = swizard time = 27 2:30:56 в LD 1 0 или LD 2 0? :) 
nick = swizard time = 27 2:31:13 это зависит от того, зовём ли мы (h 4) или (g 4) 
nick = swizard time = 27 2:31:34 что компилить туда — непонятно 
nick = sectoid time = 27 2:31:37 не должно зависеть 
nick = sectoid time = 27 2:31:43 100% не должно 
nick = swizard time = 27 2:31:57 а ведь зависит 
nick = turtle time = 27 2:32:22 Известная дилема между должно/не должно и происходит. :) 
nick = swizard time = 27 2:32:26 если мы напрямую зовём g, то в кадре 0 у нас y, а в кадре 1 x 
nick = turtle time = 27 2:32:43 Что-то я тоже думаю, а не слишком ли скоупов понасоздавали? :) 
nick = swizard time = 27 2:32:52 если зовём через h, то в кадре 0 y, в кадре 1 _тоже y_, в кадре 2 уже x 
nick = sectoid time = 27 2:32:52 так 
nick = sectoid time = 27 2:33:6 не путай меня, я только разобрался) 
nick = swizard time = 27 2:33:40 ну тогда расскажи, как оно должно быть =) 
nick = swizard time = 27 2:34:1 кадр создаётся каждый раз, когда в ассемблере выполняется AP 
nick = swizard time = 27 2:34:9 так что тут ничего не поделать 
nick = swizard time = 27 2:34:18 надо с этим как-то жить 
nick = swizard time = 27 2:36:43 лукап на рантайме чтоль сделать 
nick = sectoid time = 27 2:37:14 счас что-то придумаю) 
nick = turtle time = 27 2:37:29 Ну если у нас при каждом вызове создаётся, то лукап на рантайме напрашивается, конечно. 
nick = turtle time = 27 2:37:37 Но что-то мне покоя не даёт. :) 
nick = swizard time = 27 2:38:4 давайте брейншторм устроим в это место, а то реально весь прогресс встал :) 
nick = turtle time = 27 2:38:36 А ты как лукап на рантайме хочешь сделать? 
nick = swizard time = 27 2:39:40 ну навскидку: перечислить все используемые в коде символы, и везде вообще не просто аргументы пушить / загружать, а, например, консы: (enum . value) 
nick = swizard time = 27 2:39:59 тогда можно в цикле идти наверх по кадрам, ища конкретный енум 
nick = sectoid time = 27 2:40:10 т.е. такой себе динамик скоп сделать?) 
nick = swizard time = 27 2:40:13 номер знаем, позицию знаем, номер кадра найдём 
nick = swizard time = 27 2:40:18 ну типа 
nick = swizard time = 27 2:41:22 но тут сходу сразу проблема с функцией step для бота: VM не знает ничего про конс-обёртки, поэтому будет напрямую аргументы передавать 
nick = swizard time = 27 2:46:4 вот и ST пригодится, биндинги навешивать :-/ 
nick = turtle time = 27 2:48:8 &quot;With dynamic scope, each identifier has a global stack of bindings. Introducing a local variable with name x pushes a binding onto the global x stack (which may have been empty), which is popped off when the control flow leaves the scope. Evaluating x in any context always yields the top binding. In other words, a global identifier refers to the identifier associated with the most recent environment. Note that this cannot be done at compile-time because the binding stack only exists at run-time, which is why this type of scoping is called dynamic scoping.&quot; 
nick = turtle time = 27 2:48:21 Ну получается, что вся архитектура толкает к динамик скоупу. 
nick = turtle time = 27 2:48:37 Как раз почти один к одному. 
nick = swizard time = 27 2:49:34 ага похоже 
nick = sectoid time = 27 2:49:55 господа, вы не против, если попытаюсь запилить таки свой вариант?) 
nick = sectoid time = 27 2:49:58 а то не усну же) 
nick = sectoid time = 27 2:50:0 потом 
nick = swizard time = 27 2:50:9 да делай, конечно 
nick = swizard time = 27 2:50:12 вдруг получится 
nick = swizard time = 27 2:50:26 а что там у тебя за вариант, вкрадце? 
nick = sectoid time = 27 2:52:43 мне кажется мы смешиваем создание скопа/заполнение скопа. хочу попробовать их таки разделить. может я чего-то не понимаю... 
nick = sectoid time = 27 2:53:15 сча, попробую сформулировать свою идею понятно 
nick = sectoid time = 27 2:53:57 хм 
nick = sectoid time = 27 2:54:4 кажется до меня кое-чего дошло 
nick = turtle time = 27 2:54:52 Ну а вообще, мы же можем узнать откуда мы вызвали. И оттуда расставлять. Хотя нет, расставлять не можем. 
nick = swizard time = 27 2:55:12 расставлять не можем 
nick = turtle time = 27 2:55:13 Узнать можем, а расставить уже не получится один раз, похоже. 
nick = turtle time = 27 2:55:26 Т.е. расставлять надо каждый раз разным. 
nick = swizard time = 27 2:55:36 ага, как в киллер-примере: 
nick = swizard time = 27 2:55:37 (let ((f (lambda (x)<br />           (let ((g (lambda (y) (+ x y))))<br />             (let ((h (lambda (y) (g y))))<br />               (+ (h 4) (g 4)))))))<br />  (f 17)) 
nick = swizard time = 27 2:55:56 как не расставляй LD в функции g, всё равно неправильно будет 
nick = swizard time = 27 2:56:9 потому что это число зависит от того, откуда мы вызвали 
nick = swizard time = 27 2:56:19 поэтому я пока не вижу других вариантов, кроме рантайма 
nick = swizard time = 27 2:56:45 ну или попробовать повторить мой хак с протаскиванием замыкания в неявных аргументах 
nick = turtle time = 27 2:57:4 Ну... 
nick = swizard time = 27 2:57:11 короче, глубину стека кадров мы на компиляции знать никак не можем, походу 
nick = turtle time = 27 2:57:24 По сути твой хак он всё же динамит скоуп. Поэтому всё равно динамик он. 
nick = sectoid time = 27 2:57:53 пажжите 
nick = swizard time = 27 2:57:55 не, он статик :) на компиляции всегда понятно, что искать бинд нужно в нулевом кадре 
nick = sectoid time = 27 2:58:13 сделали мы (lambda (x) (+ x y)) 
nick = swizard time = 27 2:58:16 потому что там всё продублировано, что можно 
nick = sectoid time = 27 2:58:36 тело (с LD 0 0 и LD 1 y) ушло кудысь вниз 
nick = sectoid time = 27 2:59:4 а в том месте где мы его (let ((f (lambda ..))) - у нас произошел LDF &lt;addr-of-that-lambda&gt; 
nick = sectoid time = 27 2:59:23 по идее этот LDF замкнул тело лямбды на нужный контекст 
nick = sectoid time = 27 2:59:44 соотв. в стеке лежит CLOSURE в котором никуда LD'шки не поедут 
nick = swizard time = 27 2:59:56 не, ты код в эмуляторе глянь, он короткий:  
nick = swizard time = 27 2:59:58     LDC 17<br />    LDF 4<br />    AP 1<br />    RTN<br />;(LABEL F 4):<br />    LDC 4<br />    LDF 12<br />    AP 1<br />    LDC 4<br />    LDF 17<br />    AP 1<br />    ADD<br />    RTN<br />;(LABEL H 12):<br />    LD 0 0<br />    LDF 17<br />    AP 1<br />    RTN<br />    RTN<br />;(LABEL G 17):<br />    LD 1 0<br />    LD 0 0<br />    ADD<br />    RTN<br /> 
nick = swizard time = 27 3:0:27 задача: нужно исправить строчку «LD 1 0» на правильную :) которая после label g 17 
nick = turtle time = 27 3:0:34 Кстати, у нас как-то имена криво делаются. 
nick = turtle time = 27 3:0:40 Не сыграло бы потом злую шутку. 
nick = swizard time = 27 3:0:51 какие имена? 
nick = sectoid time = 27 3:0:53 это asm - какой исходной конструкции? 
nick = swizard time = 27 3:1:4 это асм примера-убийцы 
nick = turtle time = 27 3:1:9 ;(LABEL G 17): 
nick = swizard time = 27 3:1:34 а почему криво? 
nick = sectoid time = 27 3:1:35 вот где у нас бага 
nick = sectoid time = 27 3:1:51 мы делаем LDF'ы если &quot;грузим&quot; &quot;замыкания&quot; 
nick = sectoid time = 27 3:2:12 а у нас эти CLOSURE'ы должны приходить как параметры 
nick = turtle time = 27 3:2:13 Криво потому что если совпадёт, то могут неправильными быть. 
nick = turtle time = 27 3:2:17 Адреса. 
nick = sectoid time = 27 3:2:28 счас попробую переписать твой пример в чистом LC 
nick = swizard time = 27 3:3:15 давай, но я не очень понял, правда, как их ещё грузить, кроме как через ldf 
nick = sectoid time = 27 3:3:59 &gt;как их ещё грузить<br /><br />LD 0 x ;) 
nick = sectoid time = 27 3:4:9 кто сказал что closure не может быть в env? 
nick = sectoid time = 27 3:4:12 готовый 
nick = sectoid time = 27 3:4:17 именно closure, а не адрес 
nick = sectoid time = 27 3:4:27 closure == fn addr + bound scope 
nick = swizard time = 27 3:5:43 ты сейчас в терминах GCC рассказываешь? :) 
nick = sectoid time = 27 3:6:27 давай сначала вообще. что есть closure? функция замкнутая на контекст, верно? 
nick = swizard time = 27 3:6:35 ага 
nick = sectoid time = 27 3:7:22 теперь смотри что у нас есть в GCC 
nick = sectoid time = 27 3:7:28 в GCC есть 3 типа объектов 
nick = sectoid time = 27 3:7:36 int32, cons и closure 
nick = sectoid time = 27 3:7:57 closure есть function offset (address) + lexical frame pointer 
nick = sectoid time = 27 3:8:10 причему lexical frame pointer - не относительный, а абсолютный 
nick = sectoid time = 27 3:8:40 я в лямбдах запутался( 
nick = swizard time = 27 3:9:20 хм 
nick = sectoid time = 27 3:9:22 твой пример в LC 
nick = sectoid time = 27 3:9:23 ((lambda (f) <br />   (f 17))<br /> (lambda (x)<br />   ((lambda (g)<br />      ((lambda (h) <br />         (+ (h 4) (g 4)))<br />       ((lambda (y) (g y)))))<br />    (lambda (y) (+ x y))))) 
nick = sectoid time = 27 3:9:29 jq 
nick = sectoid time = 27 3:9:31 сча 
nick = sectoid time = 27 3:9:58 вот твой пример в LC<br />((lambda (f) <br />   (f 17))<br /> (lambda (x)<br />   ((lambda (g)<br />      ((lambda (h) <br />         (+ (h 4) (g 4)))<br />       ((lambda (y) (g y)))))<br />    (lambda (y) (+ x y))))) 
nick = swizard time = 27 3:10:21 тоесть ты хочень сказать, что надо делать все функции через dum/rap, и при вызове по указателю он там env правильно ставит?  
nick = swizard time = 27 3:10:32 в смысле, выставляет 
nick = sectoid time = 27 3:10:33 не все через dum/rap 
nick = sectoid time = 27 3:10:44 dum/rap нужен для letrec 
nick = sectoid time = 27 3:10:51 просто letrec в LC невыразим 
nick = sectoid time = 27 3:10:56 без извращений 
nick = sectoid time = 27 3:11:9 могу попробовать сделать примеры поменьше и ручками оттранслировать в GCC 
nick = sectoid time = 27 3:11:52 let (и letrec!) у нас эквивалентен лямбда-абстракции с последующей аппликацией (тут же) 
nick = sectoid time = 27 3:12:28 вся разница лишь в том, что при letrec скоп аргументов общий 
nick = sectoid time = 27 3:12:36 т.е. они &quot;видят&quot; друг-друга 
nick = swizard time = 27 3:12:49 хорошо, какой асм-то генерировать :) 
nick = swizard time = 27 3:12:54 а то я что-то уже тоже запутался 
nick = sectoid time = 27 3:13:16 попробовать модифицировать твой генератор?) 
nick = sectoid time = 27 3:13:22 или допилить свой? 
nick = swizard time = 27 3:13:44 да погоди пока пилить, напиши лучше пример-убийцу на  gcc руками 
nick = sectoid time = 27 3:13:50 ох 
nick = sectoid time = 27 3:13:53 там столько термов 
nick = sectoid time = 27 3:13:58 можно его сделать короче? 
nick = swizard time = 27 3:13:58 в смысле код, который должен получится 
nick = sectoid time = 27 3:14:9 если низзя - ок, напишу счас 
nick = swizard time = 27 3:14:38 чуток короче можно, но тогда станет непонятно по результату правильно он работает или нет 
nick = swizard time = 27 3:14:41 а так сразу видно 
nick = sectoid time = 27 3:14:51 ок, счас напишу 
nick = sectoid time = 27 3:15:14 пишу в sexp-gcc 
nick = turtle time = 27 3:15:46 Я тут тоже думал. 
nick = turtle time = 27 3:16:9 В конечном итоге как получится, конечно, нам решать, будет там скоуп динамик или не динамик. 
nick = turtle time = 27 3:16:18 AP - создаёт фрейм, RAP - нет. 
nick = sectoid time = 27 3:16:33 счас если напишу пример - будет точно лексик 
nick = sectoid time = 27 3:16:40 динамик мона потом поверх навернуть 
nick = swizard time = 27 3:16:55 про AP/RAP я тоже думал 
nick = turtle time = 27 3:17:3 Если мы сделаем функцию, а параметры будем хотеть смотреть вне её скоупа - так не надо просто делать. 
nick = swizard time = 27 3:17:18 но там такая проблема, что RAP нельзя без DUP делать, а DUP делает фрейм 
nick = turtle time = 27 3:17:22 Вне лексического скоупа. Ошибка компиляции, итпа. 
nick = sectoid time = 27 3:17:59 turtle: ну кагбэ в этом и идея лекс. скопа, не? 
nick = turtle time = 27 3:18:6 Ну ка кбы да. 
nick = sectoid time = 27 3:21:4 там тока на top-level будет чуть-чуть сложно 
nick = sectoid time = 27 3:25:26 какой же адовый этот ваш киллер-пример 
nick = swizard time = 27 3:26:18 это минимальный между прочим,  я  его из bumper-ai.lisp еле локализовал  
nick = sectoid time = 27 3:27:14 похоже я криво превратил его в LC 
nick = sectoid time = 27 3:27:17 попытка номер 2 
nick = swizard time = 27 3:35:20 блин а вообще можно выполнить LD n i, где n — это не константа?  
nick = sectoid time = 27 3:35:30 нет 
nick = swizard time = 27 3:35:36 хмм 
nick = swizard time = 27 3:36:17 тогда уровень вложенности фиксированный может быть при динамическом резолвинге 
nick = sectoid time = 27 3:40:2 (:LDC 17)<br />(:LDF :L2)<br />(:AP 1)<br /><br />;; lambda l1<br />(:LABEL :l1)<br />(:LDC 17) ; 17<br />(:LD 0 0) ; f argument<br />(:AP 1)<br />(:RTN)<br /><br />;; lambda l2<br />(:LABEL :l2)<br />(:LDF :L6)<br />(:LDF :L3)<br />(:AP 1)<br />(:RTN)<br /><br />;; lambda l3<br />(:LABEL :l3)<br />(:LDF :L5)<br />(:LDF :L4)<br />(:AP 1)<br />(:RTN)<br /><br />;; lambda l4<br />(:LABEL :l4)<br />(:LDC 4)<br />(:LD 0 0) ;; h (closure)<br />(:AP 1) ;; (h 4)<br />(:LDC 4)<br />(:LD 1 0) ;; g (closure)<br />(:AP 1) ;;<br />(:ADD)<br />(:RTN)<br /><br />;; lambda l5<br />(:LABEL :l5)<br />(:LD 0 0) ; y - argument<br />(:LD 1 0) ; g - closure<br />(:AP 1)<br />(:RTN)<br /><br />;; lambda l6<br />(:LABEL :l6)<br />(:LD 1 0) ;; x (closured from parent)<br />(:LD 0 0) ;; y - argument<br />(:ADD)<br />(:RTN)<br /> 
nick = sectoid time = 27 3:40:8 первое предполдожение 
nick = sectoid time = 27 3:40:12 счасть уточню 
nick = swizard time = 27 3:42:43 хммм ты его уже пробовал в эмуляторе гонять? 
nick = sectoid time = 27 3:42:52 еще нет 
nick = sectoid time = 27 3:43:5 я хочу чтобы он расчитал за меня смещения 
nick = sectoid time = 27 3:43:46 <br />    LDC 17<br />    LDF 7<br />    AP 1<br />;(LABEL L1 3):<br />    LDC 17<br />    LD 0 0<br />    AP 1<br />    RTN<br />;(LABEL L2 7):<br />    LDF 27<br />    LDF 11<br />    AP 1<br />    RTN<br />;(LABEL L3 11):<br />    LDF 23<br />    LDF 15<br />    AP 1<br />    RTN<br />;(LABEL L4 15):<br />    LDC 4<br />    LD 0 0<br />    AP 1<br />    LDC 4<br />    LD 1 0<br />    AP 1<br />    ADD<br />    RTN<br />;(LABEL L5 23):<br />    LD 0 0<br />    LD 1 0<br />    AP 1<br />    RTN<br />;(LABEL L6 27):<br />    LD 1 0<br />    LD 0 0<br />    ADD<br />    RTN<br /> 
nick = sectoid time = 27 3:44:1 уже загрузилась 
nick = sectoid time = 27 3:44:47 data stack: 42 
nick = sectoid time = 27 3:44:52 <br />    LDC 17<br />    LDF 8<br />    AP 1<br />    RTN<br />;(LABEL L1 4):<br />    LDC 17<br />    LD 0 0<br />    AP 1<br />    RTN<br />;(LABEL L2 8):<br />    LDF 28<br />    LDF 12<br />    AP 1<br />    RTN<br />;(LABEL L3 12):<br />    LDF 24<br />    LDF 16<br />    AP 1<br />    RTN<br />;(LABEL L4 16):<br />    LDC 4<br />    LD 0 0<br />    AP 1<br />    LDC 4<br />    LD 1 0<br />    AP 1<br />    ADD<br />    RTN<br />;(LABEL L5 24):<br />    LD 0 0<br />    LD 1 0<br />    AP 1<br />    RTN<br />;(LABEL L6 28):<br />    LD 1 0<br />    LD 0 0<br />    ADD<br />    RTN 
nick = sectoid time = 27 3:45:0 а сколько должно быть? 
nick = swizard time = 27 3:45:25 столько и должно :) 
nick = swizard time = 27 3:45:42 тока я не понимаю, что у тебя тут происходит 
nick = sectoid time = 27 3:45:53 бгггг) 
nick = sectoid time = 27 3:46:8 псевдокод:<br />((lambda l1 (f) <br />   (f 17))<br /><br /> (lambda l2 (x)<br />   ((lambda l3 (g)<br />      ((lambda l4 (h) <br />         (+ (h 4) (g 4)))<br />       <br />       (lambda l5 (y) (g y))))<br />    (lambda l6 (y) (+ x y)))))<br /> 
nick = sectoid time = 27 3:46:38 в общем пруф оф концепт работает 
nick = sectoid time = 27 3:46:42 осталось написать код) 
nick = sectoid time = 27 3:46:50 моя идея простая, свиз 
nick = sectoid time = 27 3:47:1 мы передаем замыкания 
nick = sectoid time = 27 3:47:3 через параметры 
nick = sectoid time = 27 3:47:17 т.е. через environment 
nick = sectoid time = 27 3:47:28 там лежат забинженые готовые closure 
nick = sectoid time = 27 3:47:33 тогда ничто никуда не ползет 
nick = sectoid time = 27 3:47:59 уф 
nick = sectoid time = 27 3:48:2 покурю пока 
nick = turtle time = 27 3:48:2 Ну тогда получается, что их в этом скоупе лексическом только и можно использовать. 
nick = turtle time = 27 3:48:21 Я в контексте того, что мы напишем библиотечные функции. 
nick = sectoid time = 27 3:48:28 тривиально 
nick = sectoid time = 27 3:49:19 (lambda (world-state ghost-state)<br />  (let ((lib-fn1 ...)<br />        (lib-fn2 ...)<br />        ...<br />        (lib-fnN ...))<br />    &lt;body&gt;)) 
nick = turtle time = 27 3:49:39 А хотя, наши библиотечные функции не будут из чужого скопа ничего брать. 
nick = turtle time = 27 3:49:45 Буду почище. 
nick = sectoid time = 27 3:50:5 более того, мы можем наделать helper'ов уже замкнутых на world-state начальный 
nick = sectoid time = 27 3:50:8 для вещей что не меняются 
nick = turtle time = 27 3:50:9 Я про lib-fn, которые вынесены на начальную lambda. 
nick = sectoid time = 27 3:50:17 и засунуть замыкания в ai-state 
nick = sectoid time = 27 3:50:32 изменяемую часть будет передавать замыканию как параметр 
nick = turtle time = 27 3:50:41 Ну замыкаться то будут в своём скоупе. 
nick = turtle time = 27 3:50:50 Ну нам только параметры и интересны, конечно. 
nick = sectoid time = 27 3:50:53 на свой скоуп* 
nick = turtle time = 27 3:50:56 Императив не пройдёт. :) 
nick = sectoid time = 27 3:50:56 кстати 
nick = sectoid time = 27 3:50:59 интересный вопрос 
nick = sectoid time = 27 3:51:11 а можно в CONS'ы засунуть CLOSURE? 
nick = turtle time = 27 3:51:17 Можно. 
nick = swizard time = 27 3:51:30 да 
nick = sectoid time = 27 3:51:36 кавайи 
nick = sectoid time = 27 3:51:44 тогда считайте что объекты мы уже придумали) 
nick = sectoid time = 27 3:51:49 бггг) 
nick = sectoid time = 27 3:51:54 так 
nick = sectoid time = 27 3:52:6 все, курю и иду пилить этот ад в виде транслятора) 
nick = sectoid time = 27 3:52:57 а, не, еще кое-что 
nick = sectoid time = 27 3:53:3 насчет letrec 
nick = sectoid time = 27 3:53:52 (let ((x1 f1) (x2 f2) ... (xN fN)) body) эквивалентен:<br />((lambda (x1 x2 ... xN)) f1 f2 ... fN) 
nick = sectoid time = 27 3:53:58 это всем очевидно? 
nick = swizard time = 27 3:54:34 ну да, let —  это синтаксический сахар 
nick = sectoid time = 27 3:54:40 а letrec эквивалентен тому же самому! только конвенция вызова этой нашей лямбды - не AP, а RAP! 
nick = swizard time = 27 3:57:13 ну окей, попробуй наваять 
nick = sectoid time = 27 3:57:28 оок. пилю 
nick = swizard time = 27 3:57:29 я чёто уже плохо соображаю, поэтому возразить ничего не могу :) 
nick = sectoid time = 27 3:57:45 ну, ручная компиляция моей идеи дала правильный ответ) 
nick = sectoid time = 27 3:57:52 так что я думаю мы на верном пути 
nick = swizard time = 27 3:58:1 поковыряю может перед сном тогда в отдельной ветке вариант с динамическим резолвом, если силы будут 
nick = sectoid time = 27 3:58:3 а что у нас с AI LM/ghost'ов? 
nick = turtle time = 27 3:58:38 КОнкретно с AI никак, я только ассемблер дописал. 
nick = turtle time = 27 3:58:46 Сейчас спеку перечитываю. 
nick = sectoid time = 27 3:59:32 ассемблер в репе? 
nick = sectoid time = 27 3:59:38 свиз, твою ветку надо мержить? 
nick = turtle time = 27 3:59:49 Да, всё в репе. 
nick = swizard time = 27 4:3:41 не, пока не надо 
nick = swizard time = 27 4:3:49 хотя она рабочая вроде относительно 
nick = swizard time = 27 4:3:55 за исключением киллер-примера 
nick = swizard time = 27 4:8:44 да с замыканиями идея походу правильная 
nick = swizard time = 27 4:9:10 я щас погонял в эмуляторе goto.gcc — там контрол стек растёт, а стек кадров нет 
nick = swizard time = 27 4:9:33 походу при вызове по указателю действительно окружение восстанавливается 
nick = swizard time = 27 4:10:7 интересно 
nick = sectoid time = 27 4:11:11 хех 
nick = sectoid time = 27 4:11:20 ничего, мы еще и tail call'ы туда привинтим 
nick = sectoid time = 27 4:11:28 но сначала - рабочий компилятор без TCO 
nick = sectoid time = 27 4:11:32 чтобы ты работать мог 
nick = sectoid time = 27 4:11:43 посмотри, кстате, на какой глубине стека он дохнет 
nick = sectoid time = 27 4:20:10 а, там не видно... 
nick = turtle time = 27 4:25:32 Что-то я ассемблеры то подзабыл. 
nick = sectoid time = 27 4:25:41 что там? 
nick = turtle time = 27 4:25:52 В ассемблерах? 
nick = sectoid time = 27 4:26:3 ага 
nick = turtle time = 27 4:26:6 Геморно там. 
nick = turtle time = 27 4:26:17 Раньше как-то не замечалось, когда мелкий был. 
nick = sectoid time = 27 4:26:21 гггг 
nick = turtle time = 27 4:27:41 Да ассемблер то фиг с ним. Что-то не соображу какой-нибудь совсем простейший алгоритм для хождения. 
nick = swizard time = 27 4:28:10 я щас короче поразмышлял — если эта идея с замыканиями реально сработает, то у меня получится использовать CPS в ai пакмана 
nick = swizard time = 27 4:28:42 просто будем класть continuation в ai-state, а на очередном шаге его звать 
nick = sectoid time = 27 4:29:11 работает она) 
nick = sectoid time = 27 4:29:21 ага, так и будем) 
nick = swizard time = 27 4:29:46 и тогда всё совсем ровно должно получиться, можно будет спокойно выбирать цели и дискретно к ним двигаться, подправляя стратегию по ходу игры (например, при приближении гоустов) 
nick = swizard time = 27 4:30:23 я тогда завтра начну прямо с программирования ai на CL 
nick = swizard time = 27 4:30:36 потом по ходу странслируем в IL 
nick = swizard time = 27 4:31:26 ладно, пойду я спать тогда 
nick = turtle time = 27 4:31:39 Давай. 
nick = swizard time = 27 4:32:4 до завтра 
nick = sectoid time = 27 4:32:15 ночи) 
nick = turtle time = 27 4:44:35 Какой-то совсем убогий ассемблер. 
nick = sectoid time = 27 4:44:53 у меня тут снова моооооозг от скопов 
nick = turtle time = 27 4:45:4 Да уж. :) 
nick = turtle time = 27 4:45:11 Ладно, я тоже спать пойду, наверное. 
nick = sectoid time = 27 4:45:17 давай 
nick = sectoid time = 27 4:45:19 ночи тебе 
nick = sectoid time = 27 4:45:23 а я еще попедалю 
nick = turtle time = 27 4:45:24 Ага. Спасибо. 
nick = sectoid time = 27 4:45:39 или тоже спать пойти? %) 
nick = sectoid time = 27 5:19:34 так, код закинул в реп. код не рабочий (пока что). проснусь - доделаю его, протестирую и вмержу в мастер. AI пока пилите на CL. 
nick = sectoid time = 27 5:19:57 завел много будильников на 10.30 утра (через 6 часов, гыгы) 
nick = sectoid time = 27 5:19:59 /me тоже тихо умер 
nick = sectoid time = 27 7:26:54 я таки не уснул%( 
nick = sectoid time = 27 7:27:5 в итоге допинал реализацию до почти рабочего состояния 
nick = sectoid time = 27 7:27:13 мозгодробительный тест проходит на ура 
nick = sectoid time = 27 7:27:33 не хватает мелочей вроде макросов/определения функций 
nick = sectoid time = 27 7:27:50 стандартной библиотеки (она будет, как тока допинаю defun) 
nick = sectoid time = 27 7:28:3 ну и системы для удобной загрузки всего этого 
nick = sectoid time = 27 12:25:42 есть кто живой? 
nick = turtle time = 27 12:53:21 Всем привет. 
nick = turtle time = 27 12:54:9 Еле отодрал себя от кровати. :) 
nick = sectoid time = 27 13:17:30 я сначала себя с трудом туда загнал, а потом выколупал 
nick = sectoid time = 27 13:17:42 свиз похоже еще в объятиях морфея 
nick = turtle time = 27 13:27:54 Похоже, да. 
nick = turtle time = 27 13:28:16 Какой-то большой алгоритм получается волновой. 
nick = turtle time = 27 13:28:23 Частичный который. 
nick = turtle time = 27 13:28:34 Ни по интрукциям омжно не влезть, ни по CPU. 
nick = sectoid time = 27 13:58:13 можно не влезть или не получится влезть 146% ? 
nick = turtle time = 27 13:58:52 В спеке ограничение. 
nick = turtle time = 27 13:58:59 256 инструкций. 
nick = turtle time = 27 13:59:9 И 1024 выполнение. 
nick = turtle time = 27 13:59:18 Т.е. весьма жёсткие ограничения. 
nick = sectoid time = 27 14:4:17 я помню 
nick = sectoid time = 27 14:4:23 1024 даже жестче наверное 
nick = turtle time = 27 14:5:1 Ага. 
nick = sectoid time = 27 14:7:24 /me утопал часа на 2 
nick = turtle time = 27 14:7:40 Давай. 
nick = swizard time = 27 14:36:7 привет 
nick = turtle time = 27 14:41:12 Привет. 
nick = swizard time = 27 14:43:48 я вот подумал, что раз у нас карта максимум 256x256, то можно попробовать не программировать a* для пакмана, а использовать перебор для пасфайндинга 
nick = turtle time = 27 14:44:15 Это как? 
nick = swizard time = 27 14:44:26 а как мы в шахтах робота гоняли, так же 
nick = swizard time = 27 14:44:40 просто там A* на IL дофига объёмный получается 
nick = swizard time = 27 14:44:49 там же нет хеш-табличек и тд 
nick = turtle time = 27 14:44:51 А, ты про пакмана? 
nick = swizard time = 27 14:44:55 ага 
nick = turtle time = 27 14:45:8 Ну можно попробовать, конечно. 
nick = swizard time = 27 14:45:46 ок я щас попробую изобразить какой-то вариант ai на cl 
nick = turtle time = 27 15:0:36 Гост ничего не делает, уже 41 инструкцию сожрал. 
nick = turtle time = 27 15:0:45 По мне так полный бесперспективняк его программить. :) 
nick = swizard time = 27 15:2:49 а ты смотрел всех этих miner.ghc, flipper.ghc? 
nick = swizard time = 27 15:2:57 и код гоустов из эмулятора? 
nick = turtle time = 27 15:3:16 Да, смотрел. 
nick = turtle time = 27 15:3:33 У них ничего нет, просто тупые. 
nick = swizard time = 27 15:6:5 хм 
nick = swizard time = 27 15:6:11 а что же делать? :) 
nick = turtle time = 27 15:6:39 Надо хотя бы какого-нибудь намутить. :) 
nick = swizard time = 27 15:9:59 а как там у sectoid’а дела с gcc, он не рассказывал? 
nick = turtle time = 27 15:11:3 Вроде не смог заснуть, пока не победил. :) 
nick = turtle time = 27 15:11:20 sectoid  <br />я таки не уснул%(<br />в итоге допинал реализацию до почти рабочего состояния<br />мозгодробительный тест проходит на ура<br />не хватает мелочей вроде макросов/определения функций<br />стандартной библиотеки (она будет, как тока допинаю defun)<br />ну и системы для удобной загрузки всего этого 
nick = turtle time = 27 15:11:26 Хотя, судя по всему, не до конца. 
nick = turtle time = 27 15:11:45 Но для наших нужд должно хватить. 
nick = swizard time = 27 15:11:51 у него это в отдельной ветке жизнь была, или в мастере? 
nick = turtle time = 27 15:12:21 Не знаю. 
nick = turtle time = 27 15:12:44 Судя по всему в отдельной. 
nick = swizard time = 27 15:38:6 а сам сектоид сейчас куда делся — спать пошёл? 
nick = turtle time = 27 15:40:49 Сказал, что на 2 часа утопал. 
nick = turtle time = 27 15:41:0 Было это в 14:07 
nick = turtle time = 27 15:41:4 Скоро придёт, наверное. 
nick = turtle time = 27 15:41:10 А что, смотришь его ветку? 
nick = swizard time = 27 15:41:19 да, немного поглядел 
nick = swizard time = 27 15:42:3 я вот просто думаю, что нам имеет смысл сделать транслятор CL-&gt;IL, чтобы код не портировать руками 
nick = swizard time = 27 15:42:10 код пакмана в смысле 
nick = turtle time = 27 15:42:29 А мы сейчас как делаем? 
nick = swizard time = 27 15:42:56 я вроде прикинул — если с определённой осторожностью писать на кл, то там можно после небольших преобразований напрямую в IL транслировать 
nick = swizard time = 27 15:43:13 щас мы как бы на IL пытались писать, но с отдельными макрами и библиотеками 
nick = turtle time = 27 15:43:33 А ты как предлагаешь? 
nick = swizard time = 27 15:43:51 примерно так: 
nick = swizard time = 27 15:44:22 берём ai.lisp, натравливаем на него какой-нибудь cl-&gt;il 
nick = swizard time = 27 15:44:44 он берёт там дефайны, преобразует их в top-level letrec 
nick = swizard time = 27 15:44:53 ну или даже сразу в лямбды 
nick = swizard time = 27 15:45:0 вырезает funcall-ы 
nick = swizard time = 27 15:45:3 и тд 
nick = turtle time = 27 15:45:5 А, понял. 
nick = turtle time = 27 15:45:11 Сейчас мы, типа, на IL пишем. 
nick = swizard time = 27 15:45:12 а потом translate 
nick = turtle time = 27 15:45:49 Впрямую. А ты, чтобы дебажить и все прелести использовать, хочешь на некотором подмножестве CL писать, чтобы это подмножество потом транслировать в IL, который потом в gcc? 
nick = swizard time = 27 15:46:8 ну да, типа того… просто так мы сходу получаем repl, в котором можно свободно отлаживаться 
nick = turtle time = 27 15:46:20 Имеет смысл, наверное. 
nick = turtle time = 27 15:46:26 Без отлдаки тяжко. 
nick = turtle time = 27 15:46:37 Я сейчас госта пытаюсь отлаживать - кошмар тот ещё. :) 
nick = swizard time = 27 15:46:47 да, аналогично, я поседел вчера в эмуляторе баги искать :) 
nick = turtle time = 27 15:46:57 Хотя, тут даже ручками что-то не видно, что влезет. :) 
nick = turtle time = 27 15:47:9 Ну надо хотя бы какой-нибудь простой алгоритм накидать, конечно. 
nick = turtle time = 27 15:48:0 Сектоид, конечно, обратное предлагал, il-&gt;cl, который отлаживать. 
nick = turtle time = 27 15:48:4 ХЗ что проще. 
nick = swizard time = 27 15:48:13 попробуй, может, сначала изобразить аггресивного гоуста, который просто двигается в сторону сближения с пакманом 
nick = turtle time = 27 15:48:53 Хотя, cl в il первести не сильно сложно, по идее. 
nick = swizard time = 27 15:48:59 il-&gt;cl написать проще, но cl в качестве хост-языка в сто раз удобней, потому что он поддерживается slime :)  
nick = turtle time = 27 15:49:1 Так он на первой же карте застрянет. 
nick = turtle time = 27 15:49:16 Если тупо на сближение по координатам вести. 
nick = swizard time = 27 15:49:44 да и чёрт с ним, у нас же четыре гоуста, пусть один застрянет :) зато когда пакман приблизится, он будет атакован 
nick = turtle time = 27 15:49:55 Они все застрянут. :) 
nick = swizard time = 27 15:49:57 а он должен приближаться, ему же все точки сожрать надо 
nick = turtle time = 27 15:50:10 Ты смотрел карту демонстрационную? 
nick = swizard time = 27 15:50:17 все застрянут, если им всем одинаковую прогу задать 
nick = turtle time = 27 15:50:17 http://icfpcontest.org/game.html 
nick = swizard time = 27 15:50:19 смотрел 
nick = turtle time = 27 15:50:35 Ну а сколько ты хочешь прог? 
nick = swizard time = 27 15:51:20 все четыре :) одну flipper, одну из game.html, одного аггресивного и последнего мудрого какого-нибудь можно попробовать сделать 
nick = turtle time = 27 15:51:30 :) 
nick = turtle time = 27 15:51:36 Какой ты хитрый и коварный. 
nick = swizard time = 27 15:51:44 просто надо же максимально затруднить задачу командам, которые будут пытаться анализировать наших гоустов 
nick = swizard time = 27 15:52:9 есть шанс, что они там в списке увидят тупого гоуста из примеров, и соответствующе построят стратегию 
nick = turtle time = 27 15:52:17 Может, одного бота сделать с максимальным выбором по CPU, чтобы у них LM тормозил? 
nick = swizard time = 27 15:52:29 можно и так попробовать :) 
nick = swizard time = 27 15:53:6 в общем, идея такая — если не получится хороший ai сделать, то хоть максимально затруднить жизнь оппонентам 
nick = swizard time = 27 15:54:8 можно ещё хитрее — просто разогнать четырёх гоустов по углам карты, а там они пусть болтаются 
nick = swizard time = 27 15:54:19 пакман пойдёт за таблеткой — и тут-то его и сожрут 
nick = swizard time = 27 15:54:24 с какой-то вероятностью 
nick = turtle time = 27 16:6:15 Госты не знаю размер карты. 
nick = turtle time = 27 16:6:32 Вообще обрубки какие-то. :) 
nick = swizard time = 27 16:7:22 окей, пошли третьи сутки контеста :) 
nick = swizard time = 27 16:7:35 предыдущие провальные какие-то были 
nick = swizard time = 27 16:7:51 ну ничё, если сектоид действительно одолел gcc, то мы ща наверстаем 
nick = turtle time = 27 16:8:0 Ну не совсем провальные. 
nick = sectoid time = 27 16:43:6 вот и я 
nick = sectoid time = 27 16:43:13 замотался чуть-чуть 
nick = sectoid time = 27 16:43:38 gcc я одолел 
nick = sectoid time = 27 16:43:46 осталось тока чуть-чуть марафет навести 
nick = swizard time = 27 16:44:16 и что, прямо вот транслирует всё как надо уже? :) 
nick = sectoid time = 27 16:44:35 вроде да) 
nick = swizard time = 27 16:45:5 ты его уже мержил куда-то? покажешь потом, как им пользоваться? :) 
nick = sectoid time = 27 16:45:25 еще не мержил, говорю же - счас марафет наведу да проверю еще одну штуку в letrec 
nick = swizard time = 27 16:45:35 окей окей 
nick = sectoid time = 27 16:46:45 а ты пока AI пишешь? 
nick = swizard time = 27 16:46:50 ага 
nick = swizard time = 27 16:46:57 тут кстати идея такая возникла 
nick = sectoid time = 27 16:47:2 какая?) 
nick = swizard time = 27 16:47:10 написать транслятор cl-&gt;il 
nick = sectoid time = 27 16:47:28 ммм. внезапно. а зачем?) 
nick = swizard time = 27 16:47:30 не полного cl, конечно, а его маленького совсем подмножества 
nick = sectoid time = 27 16:47:46 дык маленькое подмножество и реализуем в il  
nick = sectoid time = 27 16:47:56 il:defun у нас есть, il:defmacro есть 
nick = swizard time = 27 16:48:10 потому что я вот щас пишу на cl, проверяю и дебажу в репле, с (debug), inspect и тд, удобно 
nick = sectoid time = 27 16:48:12 счас надо еще чуть-чуть добавить кой-чего и мона реализовывать) 
nick = swizard time = 27 16:48:23 чтобы потом руками не переписывать, можно сделать транслятор 
nick = swizard time = 27 16:48:32 он там вроде должен минимальный совсем получиться 
nick = swizard time = 27 16:48:52 из самого сложного — преобразовать список defun в letrec 
nick = swizard time = 27 16:49:13 ну и по мелочи — убрать funcall’ы, и тд 
nick = swizard time = 27 16:49:26 и должен получиться чистый il 
nick = sectoid time = 27 16:49:38 можно в принципе 
nick = swizard time = 27 16:49:42 который тут же можно странслировать в gcc и гонять 
nick = sectoid time = 27 16:49:50 можно реализовать псевдо-funcall в виде макры 
nick = swizard time = 27 16:50:17 а, во чего ещё забыл спросить 
nick = sectoid time = 27 16:50:22 (funcall fn &amp;rest args) == (fn . args) 
nick = swizard time = 27 16:50:37 у тебя там в новой версии можно лямбды передавать аргументами функций? 
nick = sectoid time = 27 16:50:49 конечно 
nick = sectoid time = 27 16:50:58 и значения можно let'ить 
nick = swizard time = 27 16:51:8 ну тогда ваще отлично же 
nick = sectoid time = 27 16:51:18 есть у кого тестик ilisp'а на letrec? 
nick = swizard time = 27 16:51:26 ща дам 
nick = swizard time = 27 16:51:58 ну собственно experiment.lisp глянь из examples 
nick = sectoid time = 27 16:52:15 о, круто 
nick = swizard time = 27 16:52:17 там letrec с такой же проблемой скоупа, как киллер-пример 
nick = sectoid time = 27 16:52:17 счас проверю 
nick = sectoid time = 27 16:52:30 киллер-пример passed :) 
nick = swizard time = 27 16:52:40 и плюс simple-loop.lisp оттуда же, это на рекурсию 
nick = sectoid time = 27 16:53:24 я тут интернировал все символы ilisp в одноименный пакадж. и вот теперь думаю рад ли я этому 
nick = swizard time = 27 16:53:43 :) 
nick = sectoid time = 27 16:55:36 скока должно получаться? 2? 
nick = swizard time = 27 16:55:50 в каком варианте? 
nick = sectoid time = 27 16:56:6 в experiment.lisp 
nick = sectoid time = 27 16:56:36 (il:letrec ((nth (il:lambda (x) (il:+ x 1)))<br />            (init (il:lambda (x)<br />                     (il:let ((f (il:lambda (y) (nth y))))<br />                       (il:let ((g (il:lambda (z) (f z))))<br />                         (g x))))))<br />  (init 1)) 
nick = swizard time = 27 16:56:43 ну ваще 121 вроде 
nick = sectoid time = 27 16:56:53 хм 
nick = swizard time = 27 16:56:57 а у тебя другой код  
nick = sectoid time = 27 16:57:5 покажи свой) 
nick = sectoid time = 27 16:57:12 я попробую его 
nick = swizard time = 27 16:57:17 тогда да, 2 вроде, я просто в ветках запутался 
nick = swizard time = 27 16:57:19 ща дам 
nick = swizard time = 27 16:57:30 а блин уже не дам 
nick = swizard time = 27 16:57:44 ну и ладно, это тот же самый код, просто упрощённый для читабельности 
nick = swizard time = 27 16:57:51 попробуй simple-loop.lisp 
nick = sectoid time = 27 16:58:1 (letrec ((loop (lambda (i)<br />                 (if (&gt;= i 16) i (loop (+ i 1))))))<br />  (loop 0))<br /> 
nick = sectoid time = 27 16:58:3 этот? 
nick = swizard time = 27 16:58:8 ага 
nick = sectoid time = 27 16:59:18 16 
nick = swizard time = 27 16:59:33 ага 
nick = sectoid time = 27 16:59:34 отработало;) 
nick = sectoid time = 27 16:59:40 уф, ура, оно работает) 
nick = swizard time = 27 16:59:42 ну круто, давай доделывай скорей =) 
nick = sectoid time = 27 16:59:48 счас доделаю 
nick = sectoid time = 27 16:59:52 кстати, оно уже на generic'ах 
nick = turtle time = 27 16:59:56 Свет в конце тоннела. :) 
nick = turtle time = 27 17:0:6 *тоннеля 
nick = swizard time = 27 17:0:56 ну что ж, значит, вчерашний день не провальный вовсе 
nick = swizard time = 27 17:1:11 теперь сектоид — герой дня 
nick = turtle time = 27 17:1:17 :) 
nick = turtle time = 27 17:1:27 Мастер лямбда калькулюса. 
nick = sectoid time = 27 17:1:42 героем буду когда смержу 
nick = swizard time = 27 17:2:58 не ну это было реальное озарение про вызов замыканий… я вчера сколько доку читал, ничто меня там не навело на мысль, что env-фреймы дропаются до уровня, сохранённого в кложуре  
nick = sectoid time = 27 17:3:26 тогда была бы вообще чепуха) 
nick = swizard time = 27 17:3:31 хотя, конечно, это надо было ещё в первый день догадаться, когда я goto.gcc в эмуляторе дебажил 
nick = sectoid time = 27 17:4:58 свиз, прост иначе это было бы слишком 
nick = sectoid time = 27 17:5:11 контест обычно достаточно балансовая игра 
nick = sectoid time = 27 17:7:11 хотя был еще контест с машинками и топливом... 
nick = sectoid time = 27 17:20:42 так-с 
nick = sectoid time = 27 17:20:45 еще проблемка 
nick = sectoid time = 27 17:20:59 у нас нет возможности создавать &amp;rest параметры 
nick = sectoid time = 27 17:21:1 и &amp;optional 
nick = sectoid time = 27 17:21:7 в ilisp 
nick = sectoid time = 27 17:21:20 потому (list ...) будет или спец-формой, или макрой 
nick = swizard time = 27 17:21:41 да не надо тогда вообще list и tuple 
nick = swizard time = 27 17:21:59 если мы сделаем транслятор из cl, будет просто несколько cons в этом месте 
nick = sectoid time = 27 17:27:45 написал уже макру list 
nick = sectoid time = 27 17:27:53 кстати да, наружный код макр может быть на CL 
nick = sectoid time = 27 17:35:37 мой транслятор скинул 
nick = sectoid time = 27 17:35:44 лежит в системе ilisp 
nick = swizard time = 27 17:36:9 а расскажи вкрадце как им пользоваться 
nick = sectoid time = 27 17:36:25 грузим систему 
nick = swizard time = 27 17:36:27 я бы попробовал bumper-ai переписать на него и проверить в эмуляторе 
nick = sectoid time = 27 17:36:55 дальше творим свой пакет, и в нем (:use :il) 
nick = sectoid time = 27 17:37:11 этим ты говоришь, что пакет на ILisp, а не CL 
nick = sectoid time = 27 17:37:47 дальше в этом пакете объявляешь нужные функции (через defun IL'овский), макры (defmacro соответственно) 
nick = sectoid time = 27 17:38:2 последней формой в файле идет : 
nick = sectoid time = 27 17:39:9 (ilisp.impl:build-ai-core &lt;ast&gt; :debug nil/t) 
nick = sectoid time = 27 17:39:22 смотреть на ilisp/backend-gcc.lisp 
nick = sectoid time = 27 17:39:25 там оно объявлено 
nick = sectoid time = 27 17:40:5 он должен подтянуть все функции, обернуть &lt;ast&gt; в форму lambda и оттранслировать 
nick = sectoid time = 27 17:40:17 местами код может быть грязноват - писал с 4 до 7 утра 
nick = sectoid time = 27 17:42:29 счас чуть-чуть очухаюсь и верну тест-сьют да почищу баги (их там наверняка есть) 
nick = sectoid time = 27 17:43:1 turtle: а подлей лог жабров в реп) 
nick = swizard time = 27 17:43:11 сейчас попробую, буду задавать тогда вопросы по ходу дела 
nick = swizard time = 27 17:43:42 а ты пока глянь на досуге файл ai/ai-cl.lisp на предмет возможности его автоматической трансляции в IL 
nick = sectoid time = 27 17:43:43 оок 
nick = swizard time = 27 17:43:54 там только этот файл нужен будет 
nick = sectoid time = 27 17:44:10 посмотрю 
nick = sectoid time = 27 17:44:20 счас тока по работе 1 штуку срочную сделаю 
nick = swizard time = 27 17:44:29 если я правильно понимаю, там он в 1:1 должен почти маппиться 
nick = swizard time = 27 17:44:30 окей 
nick = sectoid time = 27 17:44:54 кстати, ai-cl.lisp нам нужно автоматом транслировать, или человек-переводчик сканает?) 
nick = sectoid time = 27 17:45:20 может проще его руками перевести? 
nick = swizard time = 27 17:45:20 ну если автоматом не получится, то сканает, конечно :) 
nick = sectoid time = 27 17:45:40 просто не исключено что руками будет проще 
nick = turtle time = 27 17:45:42 Вспотеля на этом ассемблере писать. :) Логи в репу залил - и то развлечение. :) 
nick = sectoid time = 27 17:45:50 100 строк всего 
nick = sectoid time = 27 17:46:0 я про ai-cl 
nick = sectoid time = 27 17:46:14 если конечно он распухнет до 10к портянки - да, надо транслятор будет делать) 
nick = swizard time = 27 17:46:49 руками один раз проще, конечно, но если много раз надо будет, то проще уже сразу на IL писать 
nick = sectoid time = 27 17:46:55 а еще на save-hook круто иметь whitespace-cleanup ;) 
nick = turtle time = 27 17:47:1 Лучше на руки не ориентироваться. 
nick = turtle time = 27 17:47:31 Потому что руками каждый раз грустно будет. 
nick = swizard time = 27 17:48:57 а зачем там в ilisp/package.lisp два раза подряд «defpackage #:ilisp» ? :) 
nick = sectoid time = 27 17:49:18 наверное потому, что я криворукий 
nick = sectoid time = 27 17:49:21 убери, плиз 
nick = swizard time = 27 17:49:27 окей 
nick = swizard time = 27 18:1:21 а глянь, пожалуйста, в ilisp/examples/bumper-ai.lisp , что-то там у меня не срастается 
nick = swizard time = 27 18:1:30 Lock on package COMMON-LISP violated when<br />interning GCC-MACRO/COMMON-LISP/LAMBDA while in package<br />ILISP-BUMPER-AI.<br /> 
nick = swizard time = 27 18:2:2   6: (SB-INT:INTERN* &quot;GCC-MACRO/COMMON-LISP/LAMBDA&quot; 28 #&lt;COMMON-LISP:PACKAGE &quot;COMMON-LISP&quot;&gt; :NO-COPY COMMON-LISP:NIL)<br />  7: (COMMON-LISP:INTERN &quot;GCC-MACRO/COMMON-LISP/LAMBDA&quot; #&lt;COMMON-LISP:PACKAGE &quot;COMMON-LISP&quot;&gt;)<br />  8: (ILISP.IMPL::GCC-MACRO-P COMMON-LISP:LAMBDA)<br />  9: ((:METHOD ILISP.IMPL::TRANSLATE-WALK (ILISP.IMPL::GCC-TRANSLATOR COMMON-LISP:T)) #&lt;ILISP.IMPL::GCC-TRANSLATOR {100B00D1E3}&gt; (COMMON-LISP:LAMBDA (ILISP.IMPL::INITIAL-STATE ILISP.IMPL::UNKNOWN) (ILISP.I..<br /> 
nick = swizard time = 27 18:2:21 может, я что не так делаю? :) 
nick = swizard time = 27 18:14:43 ну, короче, почему-то ничего пока не получается сделать 
nick = sectoid time = 27 18:14:52 вернулся 
nick = sectoid time = 27 18:15:5 счас гляну 
nick = sectoid time = 27 18:16:59 ух как интересно) 
nick = sectoid time = 27 18:17:2 счас разберемся) 
nick = sectoid time = 27 18:17:24 а, понял 
nick = sectoid time = 27 18:21:31 свиз, лови фиксов еще 
nick = swizard time = 27 18:21:52 ща 
nick = sectoid time = 27 18:21:58 мона в build-ai-core сразу затолкать вызов минимизации, unlabel и вывод 
nick = turtle time = 27 18:23:54 1024th это 1024 или 1024 тысячи? 
nick = sectoid time = 27 18:24:33 контекст 
nick = turtle time = 27 18:25:37 &quot;it was the 1024th instruction executed;&quot; 
nick = turtle time = 27 18:25:43 Наверное, 1024-ая тут. 
nick = turtle time = 27 18:29:15 В общем, с волновым алгоритмом не влезем мы в 1024 инструкции. 
nick = turtle time = 27 18:29:25 ХОтя, можем и влезть. 
nick = sectoid time = 27 18:30:33 1024я 
nick = swizard time = 27 18:37:8 sectoid 
nick = swizard time = 27 18:37:14 слушай, там такая засада похоже 
nick = sectoid time = 27 18:37:24 какая? 
nick = swizard time = 27 18:37:36 build-ai-core оборачивает мой аст в (il:lambda (initial-state unknown) 
nick = sectoid time = 27 18:37:48 да 
nick = swizard time = 27 18:38:4 но я из своего аста не могу взять эти параметры, потому что они из другого пакаджа 
nick = sectoid time = 27 18:38:16 а 
nick = sectoid time = 27 18:38:17 хм 
nick = sectoid time = 27 18:38:26 засада 
nick = sectoid time = 27 18:38:47 интернируй их нафиг в il ?) 
nick = sectoid time = 27 18:38:54 и пусть их 
nick = swizard time = 27 18:39:34 может, лучше вместо top-level lambda сделать top-level let, а лямбду я сам напишу? :) 
nick = swizard time = 27 18:39:47 тоесть letrec 
nick = sectoid time = 27 18:41:18 ммм 
nick = sectoid time = 27 18:41:24 можно и так 
nick = sectoid time = 27 18:41:30 у меня башка тупит( 
nick = swizard time = 27 18:43:54 твоя top-level lambda как-то по-особому обрабатывается? 
nick = sectoid time = 27 18:44:14 неа 
nick = sectoid time = 27 18:44:34 мне просто надо было куда-то толкать letrec со стандартной библиотекой 
nick = swizard time = 27 18:45:0 просто смотри, если мы пишем lambda bla bla, то теперь код возвращает замыкание 
nick = swizard time = 27 18:45:28 а для бота там нужна сразу функция 
nick = sectoid time = 27 18:46:7 давай наверх вытяни letrec стандартной либой, а лябду толкай сам 
nick = swizard time = 27 18:46:29 не погодь, так тоже не получается  
nick = swizard time = 27 18:46:31 смотри 
nick = sectoid time = 27 18:46:57 я понял о чем ты 
nick = swizard time = 27 18:47:18 надо какой-то отдельный случай придумать для toplevel лямбды 
nick = sectoid time = 27 18:47:21 главное передавай в build-ai-core лямбду 
nick = sectoid time = 27 18:47:30 я сделаю унутре костыль 
nick = sectoid time = 27 18:47:42 который ее будет правильно звать 
nick = swizard time = 27 18:47:52 ок, подойдёт 
nick = swizard time = 27 18:48:27 тоесть мой аст для build-ai-core должен будет обязательно обёрнут быть в (lambda (init-state unknown) …), правильно? 
nick = swizard time = 27 18:48:36 тоесть лябмда с двумя параметрами 
nick = swizard time = 27 18:49:0 или можно вообще любое замыкание? :) 
nick = swizard time = 27 18:49:17 вот так: (ilisp.impl:build-ai-core 'init) 
nick = swizard time = 27 18:49:32 а выше там типа (defun init (init-state unknown) …) 
nick = sectoid time = 27 18:49:46 пойдет) 
nick = turtle time = 27 18:49:56 Мда, текущий гост ни хрена не делает, но тормзит знатно. :) 
nick = swizard time = 27 18:49:58 окей, тогда жду пуша 
nick = turtle time = 27 18:50:7 Может, получится его научить куда-нибудь вменяемо ходить. 
nick = sectoid time = 27 18:50:10 счас ублажу этот блядский кол-центр, и сделаю 
nick = swizard time = 27 18:50:33 окей, я тогда пойду быстро перекушу и ai поделаю 
nick = swizard time = 27 18:50:47 а чем гоуст занят, пока он тормозит? :) 
nick = turtle time = 27 18:52:47 Он смотрит карту, свою строит. 
nick = swizard time = 27 19:2:12 не ну а так класс прямо с новым gcc, у меня вот получилось там foldl  запустить :) 
nick = swizard time = 27 19:2:42 ладно пойду дальше ai ковырять тогда 
nick = sectoid time = 27 19:5:30 свиз, более того - я жду именно имя пусковой фунции в build-ai-core 
nick = sectoid time = 27 19:5:34 счас залью в реп 
nick = sectoid time = 27 19:15:59 обновление в репе 
nick = swizard time = 27 19:17:47 ща заценим 
nick = swizard time = 27 19:18:50 always-down работает? 
nick = swizard time = 27 19:20:11 воу запахало 
nick = swizard time = 27 19:20:46 так ну тогда последний тест: пробую портировать bumper-ai, и если заработает, то это уже половина победы =) 
nick = sectoid time = 27 19:21:4 я нужен в ближайшие полчаса? 
nick = swizard time = 27 19:21:35 давай я идею свою выскажу и можешь идти :) 
nick = swizard time = 27 19:21:40 я вот чего подумал 
nick = swizard time = 27 19:22:17 этот ILISP наш по-сути очень близок (синтаксически) к тому подмножеству CL, на котором я щас пишу ai-cl 
nick = swizard time = 27 19:22:44 там реально почти один в один, за исключением синтаксических вариаций вроде letrec/labels, funcall и тд 
nick = swizard time = 27 19:22:54 может нам того 
nick = swizard time = 27 19:23:1 ваще упразднить ILISP 
nick = swizard time = 27 19:23:10 и спокойно транслировать CL? :) 
nick = sectoid time = 27 19:23:17 хм 
nick = sectoid time = 27 19:23:21 можно в принципе 
nick = sectoid time = 27 19:23:38 довинтить макр и попробовать 
nick = sectoid time = 27 19:23:52 счас 30 минут подремаю и попробую изобразить proof-of-concept 
nick = sectoid time = 27 19:24:3 если что не сложно будет откатить все назад 
nick = swizard time = 27 19:24:3 да без проблем :) 
nick = sectoid time = 27 19:24:12 только не увлекайся CL-фишками сильно) 
nick = swizard time = 27 19:24:22 я держу себя в руках =) 
nick = sectoid time = 27 19:24:40 ок, тогда я афк минут 30 
nick = sectoid time = 27 19:24:46 вернусь - упатчу ilisp 
nick = swizard time = 27 19:25:10 ага, давай 
nick = swizard time = 27 19:36:29 ЕСТЬ, да есть же ж =) 
nick = swizard time = 27 19:36:40 скомпилировался и заработал bumper-ai 
nick = swizard time = 27 19:37:11 сектоид теперь официально герой вчерашнего дня 
nick = sectoid time = 27 19:38:10 скорее герой этого утра%) 
nick = swizard time = 27 19:38:13 ну всё, можно теперь у нас, наконец, всё есть, чтобы спокойно обучать пакмана 
nick = sectoid time = 27 19:38:27 подремать не дадут мне походу тутощние 
nick = swizard time = 27 19:38:34 =) 
nick = sectoid time = 27 19:38:43 в смысле мои домочадцы 
nick = turtle time = 27 19:41:29 Надо будет сектоиду какую-нибудь медальку нарисовать. :) 
nick = sectoid time = 27 19:49:8 та лан) все молодцы) 
nick = sectoid time = 27 19:49:18 лучше нарисуйтесь в киев, как бардак на востоке кончиццо 
nick = turtle time = 27 19:59:55 Пипец, у них ghc глючит. 
nick = turtle time = 27 20:0:3 Надо будет написать. 
nick = swizard time = 27 20:0:26 а что там? 
nick = swizard time = 27 20:0:39 ты на game.html тестируешь? 
nick = turtle time = 27 20:0:46 Память произвольно меняется. 
nick = turtle time = 27 20:0:53 Так и не понял по какому принципу. 
nick = sectoid time = 27 20:2:5 спроси в ирке 
nick = turtle time = 27 20:7:35 Кака-то тишина в ирке. :) 
nick = turtle time = 27 20:7:44 Может, где-то в спеке отражено? 
nick = sectoid time = 27 20:7:46 dcoutts - орг, как я понимаю 
nick = turtle time = 27 20:7:49 Ага. 
nick = sectoid time = 27 20:7:54 перечитай спеку 
nick = turtle time = 27 20:8:43 Читаю вот. 
nick = sectoid time = 27 20:9:45 The contents of the data memory and registers persist between game ticks.<br /> 
nick = turtle time = 27 20:11:34 Это то понятно. 
nick = turtle time = 27 20:11:42 У меня в течение одного тика баг. 
nick = turtle time = 27 20:11:42 mov [255],8<br />mov e,7<br />mov [248],e<br />add [248],[255]<br />mov g,[240]<br />mov h,[241]<br />int 8<br />hlt<br /> 
nick = turtle time = 27 20:12:11 А, погоди. это не то. 
nick = sectoid time = 27 20:12:31 сходу вопрос) 
nick = sectoid time = 27 20:12:53 mov e,7<br />mov [248],e<br /><br />а нельзя <br />mov [248], 7<br /><br />? 
nick = turtle time = 27 20:13:29 Это тестовая хрень. 
nick = sectoid time = 27 20:13:34 а 
nick = turtle time = 27 20:18:41 Пойду отойду. 
nick = sectoid time = 27 20:26:13 swizard: куда смотреть ? что именно наш парсер должен быть способным прожевать? 
nick = swizard time = 27 20:26:38 ai/ai-cl.lisp 
nick = swizard time = 27 20:27:19 если там встретишь какую-то конструкцию, которую сходу непонятно как транслировать, то говори — я перепишу 
nick = sectoid time = 27 20:27:32 оок 
nick = sectoid time = 27 20:35:2 гыгыгыгы 
nick = sectoid time = 27 20:35:12 defmacro/defun будут спец-формами! 
nick = sectoid time = 27 20:42:39 этот CL просто праздник какой-то... 
nick = swizard time = 27 20:42:55 в хорошем смысле? :) 
nick = sectoid time = 27 20:43:30 да) 
nick = sectoid time = 27 20:53:18 хочешь build-ai-core который жрет список файлов, транслирует и собирает файл .gcc ? 
nick = swizard time = 27 20:53:45 а список зачем, для библиотечных функций типа? 
nick = swizard time = 27 20:54:35 вообще хочу, я там уже наваял что-то по-идее работающее 
nick = swizard time = 27 20:55:1 если я нигде не ошибся, то пакман должен уже целенаправленно сходить за всеми мегатаблетками 
nick = sectoid time = 27 20:55:1 да, для библиотечных 
nick = sectoid time = 27 20:55:14 ибо я умудрился реализовать defun/defmacro 
nick = swizard time = 27 20:55:24 хехе :) 
nick = sectoid time = 27 20:55:26 счас добавлю костылик для in-package 
nick = sectoid time = 27 20:55:32 и буду тупо компилить 
nick = sectoid time = 27 20:55:42 и дописывать stdlib для косяков 
nick = swizard time = 27 20:56:3 а какие примерно прогнозы по времени? а то у меня уже руки чешутся в эмуляторе погонять, я вот щас думаю, подождать твой компилер, или на IL переписать руками 
nick = sectoid time = 27 20:56:27 минут полчаса 
nick = sectoid time = 27 20:56:36 постараюсь быстрее 
nick = swizard time = 27 20:56:53 да не, не надо быстрее, лучше аккуратней :) 
nick = sectoid time = 27 20:57:16 напомни, как по wildcard pathname'у получить список совпадающих pathname'ов на файлы? 
nick = sectoid time = 27 20:57:28 не помнишь? 
nick = swizard time = 27 20:57:47 сходу нет, да и забей, достаточно имхо руками все файлы ему передать 
nick = sectoid time = 27 20:58:4 сча 
nick = sectoid time = 27 20:58:57 (directory #p&quot;./*.lisp&quot;) 
nick = sectoid time = 27 20:58:59 хеееехехехе 
nick = sectoid time = 27 20:59:5 помню же что просто было 
nick = sectoid time = 27 20:59:9 и по-наркомански 
nick = swizard time = 27 20:59:58 так а что, ты хочешь сказать, что у тебя получилось мой CL нормально странслировать? 
nick = sectoid time = 27 21:0:15 счас, пажжи, еще не все получилось 
nick = sectoid time = 27 21:0:19 напомни 
nick = sectoid time = 27 21:0:20 (with-open-file (fi gcc-input-file)<br />	(read fi)) 
nick = sectoid time = 27 21:0:33 read fi должен же 1ю top-level форму вернуть? 
nick = swizard time = 27 21:0:52 да 
nick = swizard time = 27 21:1:30 если там много форм, то можно (iter (for form in-stream fi) … ) 
nick = sectoid time = 27 21:1:40 лан, счас руками сделаю сначала прогон твоего файла 
nick = sectoid time = 27 21:1:45 а потом буду уже обертку делать 
nick = swizard time = 27 21:3:4 на самом деле в этом году icfpc нехило такой бонус лисперам даёт, остальным вон приходится трёхэтажный дсл городить: http://users.livejournal.com/_winnie/434074.html 
nick = swizard time = 27 21:3:21 а мы, по-сути, на хост языке программу пакману пишем 
nick = sectoid time = 27 21:3:44 угу 
nick = sectoid time = 27 21:13:47 у нас же всегда снаружи letrec ? 
nick = swizard time = 27 21:14:0 ну вроде да 
nick = swizard time = 27 21:14:22 когда *lib* чем-то наполнен, по крайней мере 
nick = sectoid time = 27 21:14:35 fuf 
nick = sectoid time = 27 21:14:37 ага 
nick = sectoid time = 27 21:21:9 так, все чуточку усложнилось 
nick = sectoid time = 27 21:21:17 свиз. ты setq юзал где-то? 
nick = swizard time = 27 21:21:23 нет 
nick = sectoid time = 27 21:21:27 ага, гут 
nick = sectoid time = 27 21:21:29 счас введу 
nick = swizard time = 27 21:21:37 а зачем? :) 
nick = swizard time = 27 21:23:59 вот это победа 
nick = swizard time = 27 21:24:4 я короче не утерпел 
nick = swizard time = 27 21:24:17 портировал руками аи на ilisp 
nick = swizard time = 27 21:24:22 почти ничего править не пришлось 
nick = swizard time = 27 21:24:27 и он собака заработал =) 
nick = swizard time = 27 21:24:40 пакман там почти уровень прошёл 
nick = swizard time = 27 21:24:44 ща запушу 
nick = sectoid time = 27 21:25:16 давай 
nick = swizard time = 27 21:25:22 ilisp/examples/power-pill-hunter.lisp 
nick = sectoid time = 27 21:25:26 а я тут доламываю таки переход на cl 
nick = sectoid time = 27 21:25:32 и снова убегу на пару часов 
nick = sectoid time = 27 21:25:46 сорри реал под конец контеста начинает заедать 
nick = swizard time = 27 21:26:0 давай, с CL у меня существенно быстрее должны дела пойти 
nick = sectoid time = 27 21:27:6 зачем-то реализовал setq 
nick = sectoid time = 27 21:27:15 и потом понял что в letrec мне он все-равно без толку 
nick = swizard time = 27 21:27:59 да не надо setq, на самом деле, вроде всего хватает 
nick = sectoid time = 27 21:28:16 о, может знаешь как в iterate пройтись по plist'у? 
nick = swizard time = 27 21:28:18 зацените бота-то, я там рядом ассемблер положил: ilisp/examples/power-pill-hunter.gcc 
nick = swizard time = 27 21:28:24 знаю 
nick = sectoid time = 27 21:28:37 заценю, но я в другом бранче 
nick = sectoid time = 27 21:28:40 подскажи с plist'ом 
nick = sectoid time = 27 21:28:45 чтобы я доку не мучал счас 
nick = swizard time = 27 21:28:58 (tier (generating el in list) (for key = (next el)) (for value = (next el)) … 
nick = sectoid time = 27 21:29:27 ty! 
nick = swizard time = 27 21:33:43 ща попробую проапгрейдить пакмана, чтобы он дожрал все точки на уровне и будет прямо полноценный ai, хотя и примитивный 
nick = grepz time = 27 21:37:25 Дико извиняюсь, только сейчас до компа добрался. Всем привет. 
nick = swizard time = 27 21:37:40 привет! 
nick = grepz time = 27 21:37:59 ох нифига вы монстры, смотрю коммиты... 
nick = swizard time = 27 21:38:19 у нас уже первые успехи =) 
nick = swizard time = 27 21:38:35 пакман без пяти минут уровень пройти может 
nick = grepz time = 27 21:38:48 :) круто 
nick = grepz time = 27 21:39:17 А с гостами чего-нибудь получилось? 
nick = swizard time = 27 21:39:33 с гостами пока похуже, насколько я понимаю 
nick = swizard time = 27 21:40:2 может, тебе имеет смысл помочь Азамату 
nick = grepz time = 27 21:40:3 там бы тоже какой транслятор, я пробовал вручную на асме писать, это ад 
nick = grepz time = 27 21:40:14 Я за, чем могу? 
nick = swizard time = 27 21:40:38 он на асме и пытается сейчас :) 
nick = swizard time = 27 21:41:5 может, действительной попробовать какой-то транслятор изобразить 
nick = grepz time = 27 21:41:14 turtle, какие идеи насчёт гостов? 
nick = grepz time = 27 21:42:21 http://94.173.40.148/ 13600, мощно 
nick = sectoid time = 27 21:44:28 неслабо 
nick = sectoid time = 27 21:44:42 черт 
nick = sectoid time = 27 21:44:49 меня все-таки дергают( 
nick = swizard time = 27 21:44:50 а это что за скорборд, от оргов? 
nick = sectoid time = 27 21:44:51 не успеваю 
nick = grepz time = 27 21:44:55 да 
nick = sectoid time = 27 21:44:55 может кто-то подхватить? 
nick = swizard time = 27 21:45:4 ну давай я 
nick = swizard time = 27 21:45:45 но тока чуть попозже, я аи допинаю чтобы он уровень до конца проходил 
nick = grepz time = 27 21:46:56 я смотрю turtle как раз небольшой язык для гостов изобрёл. 
nick = sectoid time = 27 21:55:31 свиз 
nick = sectoid time = 27 21:55:34 бранч cl-compatible-translator 
nick = sectoid time = 27 21:55:40 осталось забороть funcall и function 
nick = sectoid time = 27 21:56:21 я вызывал пробный пример вот так: <br />(build-ai (list #p&quot;./ilisp/stdlib.lisp&quot; #p&quot;./ai/ai-cl.lisp&quot;) #P&quot;./test.gcc&quot; 'gcc-init)<br /> 
nick = swizard time = 27 21:56:47 окей, примерно понятно 
nick = swizard time = 27 21:56:57 я минут через 20 подхвачу 
nick = sectoid time = 27 21:57:25 постараюсь вернуться скорее 
nick = sectoid time = 27 21:57:35 * как можно скорее 
nick = swizard time = 27 22:10:57 тадааам я прошёл уровень =)) 
nick = swizard time = 27 22:11:2 8760 score 
nick = swizard time = 27 22:11:13 ща закоммичу ai 
nick = grepz time = 27 22:12:8 исходя из hall of fame значение выше среднего, уже круто. :) 
nick = grepz time = 27 22:12:22 максимально в 13600 пока так никто и не побил 
nick = swizard time = 27 22:12:44 ну это как бы не окончательная победа если что :) 
nick = grepz time = 27 22:12:54 это понятно. :) 
nick = swizard time = 27 22:13:2 дело в том, что бот пока на гоустов не обращает внимания 
nick = grepz time = 27 22:13:10 Интересно кто в команде jabber.ru играет, они вообще сурово взялись за тесты 
nick = swizard time = 27 22:13:12 так получилось, что их пути пока не пересеклись =) 
nick = swizard time = 27 22:13:55 ну это нормальная практика, они просто несколько раз сабмитят чтобы посмотреть какие успехи у того или иного аи 
nick = swizard time = 27 22:14:17 закоммитил power-pill-hunter.lisp 
nick = swizard time = 27 22:15:12 так, ща надо прикинуть, получится ли быстро его научить бегать от гоустов, или приняться за наследие сектоида 
nick = grepz time = 27 22:16:35 wc ilisp/examples/power-pill-hunter.gcc ~/Projects/icfpc-2014<br /> 1000  2195 12339 ilisp/examples/power-pill-hunter.gcc 
nick = grepz time = 27 22:16:38 нехило 
nick = swizard time = 27 22:17:1 ну до лимита ещё далеко, если ты об этом  
nick = grepz time = 27 22:18:8 ты сначала за power pills пытаешся идти? 
nick = swizard time = 27 22:18:37 да, он сначала целенаправленно ходит за всеми таблетками власти, а потом подчищает то, что осталось 
nick = grepz time = 27 22:18:57 у меня только что проехал мимо на повороте, хотя до таблетки было 2 клетки :) 
nick = swizard time = 27 22:19:4 надо его научить шарахаться от гоустов и добывать фрукты 
nick = swizard time = 27 22:19:24 да там pathfinding убогий пока 
nick = swizard time = 27 22:19:47 надо будет хотябы wave сделать 
nick = grepz time = 27 22:20:6 Учить надо от гостов бегать, я сейчас запустил гостов ходить от края до края и пакман пройти мимо уже никак не может 
nick = swizard time = 27 22:20:25 вот кстати да, вариант 
nick = swizard time = 27 22:20:33 у нас же 4 проги для гоустов 
nick = swizard time = 27 22:20:38 одного можно сделать такого стража 
nick = swizard time = 27 22:20:52 чтобы все агрессивные пакманы типа моего об них разбивались 
nick = grepz time = 27 22:21:22 ага, можно попробовать отсканить карту, найти проходы и поставить там стража 
nick = grepz time = 27 22:21:41 хотя памяти крупицы, на полный скан может нехватить 
nick = swizard time = 27 22:22:3 ну или тупо окружить какую-нибудь таблетку четырьмя гоустами, перекрыв проходы =) 
nick = swizard time = 27 22:22:12 чтобы пакман никак уровень не завершил 
nick = swizard time = 27 22:22:21 хотя score он всё равно наберёт 
nick = grepz time = 27 22:22:36 о! а время действия таблетки же фиксировано? 
nick = swizard time = 27 22:22:43 ага 
nick = grepz time = 27 22:23:12 впринципе стратегия стражей может проканать, надо поэксперементировать с твоим пакманом 
nick = swizard time = 27 22:23:33 давай, хотя я вроде придумал, как его быстро научить шарахаться от гоустов 
nick = turtle time = 27 22:23:50 Так, я тут. 
nick = grepz time = 27 22:24:25 turtle, у тебя код в репе(ghc-assembler) свежий? 
nick = turtle time = 27 22:26:29 Свежий вроде бы. 
nick = turtle time = 27 22:26:36 Сейчас прочитаю  что тут было. 
nick = turtle time = 27 22:26:44 grepz: тебе, наверное, тоже надо пару гостов накидать. 
nick = grepz time = 27 22:26:54 я как раз пытаюсь вникнуть 
nick = grepz time = 27 22:29:18 turtle, я хочу попробовать изобразить стратегию стражей используя твой транслятор, может быть будет эффективно. Сейчас ещё Свиз научит пакмана от них бегать и посмотрим. 
nick = swizard time = 27 22:32:11 так, на самом деле там ограничение по ресурсам на ход типа, 3072 инструкции 
nick = swizard time = 27 22:32:24 как бы понять, сколько инструкций у меня ход занимает 
nick = grepz time = 27 22:33:32 там помоему есть pascal расширение позволяющее сохранять данное в env 
nick = grepz time = 27 22:33:40 можно как-нибудь прикрутить навреное 
nick = turtle time = 27 22:33:46 grepz: там транслятор я не видел смысла делать, хотя сейчас не знаю. Набросал дебильный ассемблер, чтобы просто легче было. 
nick = turtle time = 27 22:33:50 И херачу на асме. 
nick = turtle time = 27 22:34:6 Из того что есть - гост не может узнать размеры карты. 
nick = turtle time = 27 22:34:37 Ограничение госта на 256 инструкций в памяти. И на 1024 на выполнение. 
nick = turtle time = 27 22:34:54 Поэтому я и подумал, что смысла делать транслятор нет, всё равно ничего умного там сделать не получится. 
nick = turtle time = 27 22:34:59 Память - 256 байт. 
nick = turtle time = 27 22:35:14 Это не просто мало, а вообще ни на что не хватит. 
nick = grepz time = 27 22:35:21 ну впринципе правильно, довольно быстро в потолок можно упереться 
nick = turtle time = 27 22:35:29 Поэтому нужны какие-нибудь довольно дебильные стратегие для гостов. 
nick = grepz time = 27 22:35:44 а госты всегда в центре начинают? 
nick = turtle time = 27 22:35:45 Дебильные имеется в виду относительно простые. 
nick = turtle time = 27 22:35:50 Нет, не всегда. 
nick = turtle time = 27 22:36:0 Это картой определяется где они начинают. 
nick = grepz time = 27 22:36:17 понял, координаты пакмана вроде можно получить? 
nick = turtle time = 27 22:36:33 Да, коры пакмана - без проблем. Коры других гостов - тоже. 
nick = grepz time = 27 22:36:46 с этого уже можно начать 
nick = turtle time = 27 22:36:46 Блин, было бы побольше ресурсов, можно было бы пакману дороги перекрывать. :) 
nick = grepz time = 27 22:36:57 вот у меня такая же мысль выше была 
nick = turtle time = 27 22:37:1 Потом, карта максимальный размер имеет 256 на 256. 
nick = grepz time = 27 22:37:2 в коробочку брать 
nick = swizard time = 27 22:37:10 можно сделать проще — перекрывать узкие проходы :) 
nick = swizard time = 27 22:37:18 чтобы обойти нельзя было 
nick = turtle time = 27 22:37:21 Но сейчас, по факту, даже волновой алгоритм особо не простроишь. 
nick = turtle time = 27 22:37:35 Мало памяти. 
nick = turtle time = 27 22:37:48 Да и за ресурсы cpu очень легко выйти. 
nick = grepz time = 27 22:38:29 а координа power pills нам не известны? 
nick = grepz time = 27 22:38:35 *координаты 
nick = turtle time = 27 22:38:54 &quot;А у меня eDSL'ка нарисовалась. Корявая, зато с типами&quot; :) 
nick = turtle time = 27 22:38:58 Гостам? Нет. 
nick = turtle time = 27 22:39:24 Если только не перебрать карту от стен до стен. 
nick = swizard time = 27 22:39:25 turtle, ты прикинь как на такой dsl-ке алгоритмы писать =) 
nick = turtle time = 27 22:39:31 Но там все инструкции на это уйдут. 
nick = turtle time = 27 22:39:47 swizard: да вообще попа, да. 
nick = turtle time = 27 22:40:5 swizard: &quot;From this it follows that each invocation of the AI, before a move, was allowed to run up to 3072 * 10^3 instructions.&quot; 
nick = turtle time = 27 22:40:17 Не 3072 инструкции, а в 1000 раз больше. 
nick = swizard time = 27 22:40:35 о как, тогда живём 
nick = grepz time = 27 22:40:50 да, тут уже можно програмке подумать 
nick = turtle time = 27 22:41:40 Как я и говорил вчера - ресурсы только у пакмана. 
nick = turtle time = 27 22:42:32 С гостами не разгуляешься, поэтому противостояния крутого не получится. 
nick = turtle time = 27 22:43:2 grepz: в общем, попробуй изобразить что-нибудь гениально простое. ) 
nick = swizard time = 27 22:43:12 во я щас наверно тогда параллельно заставлю пакмана гоняться за синими гоустами 
nick = grepz time = 27 22:43:14 попробую что-нибудь :) 
nick = turtle time = 27 22:43:32 А то с волновым алгоритмом я застрял + на багу в симуляторе наткнулся. :) Какой-то там стейт тупит. 
nick = grepz time = 27 22:43:43 Свиз, если разобрать входные данные от гостов(второй параметр), то от них вообще можно красиво бегать 
nick = swizard time = 27 22:43:47 сожранный гоуст респавнится синим, или уже обычным? 
nick = turtle time = 27 22:44:1 Сожранные невидим же. 
nick = turtle time = 27 22:44:6 И жрать не может, и сожрать нельзя. 
nick = grepz time = 27 22:44:8 он невидим некоторое время, потом вроде сразу обычным становится 
nick = swizard time = 27 22:44:18 окей 
nick = turtle time = 27 22:44:22 Время пока таблетка действует. 
nick = turtle time = 27 22:45:33 &quot;When a power pill is eaten, all ghosts turn around and move in the opposite direction to their previous move, and fright mode is enabled. While in fright mode, if a ghost occupies the same square as a Lambda-Man, the ghost is eaten. When a ghost is eaten, it is returned to its starting position and starting direction, and is invisible until fright mode expires. While invisible, the ghost can neither eat nor be eaten.&quot; 
nick = turtle time = 27 22:45:38 Вот выдержка из спеки. 
nick = turtle time = 27 22:46:36 15300 там некоторые набирают на стандартной карте. 
nick = swizard time = 27 22:46:54 ох 
nick = swizard time = 27 22:47:12 походу это надо сожрать всех гоустов и все фрукты 
nick = swizard time = 27 22:47:32 ну ничё щас мы тоже как-нибудь выступим 
nick = turtle time = 27 22:47:35 Да, наверное. 
nick = turtle time = 27 22:47:41 Может, даже и не по одному разу. :) 
nick = turtle time = 27 22:48:47 [22:43] &lt;mietek&gt; But it means I can't just continue using `LD 1 x` to reference the previous frame!<br />[22:45] &lt;mietek&gt; As I then have to use `LD 2 x`, `LD 3 x`... 
nick = turtle time = 27 22:48:57 С ирка. Да... :) 
nick = swizard time = 27 22:49:42 хех, поздновато они спохватились :) 
nick = grepz time = 27 22:52:8 а дебажить данные с регистров в симуляторе никак? 
nick = turtle time = 27 22:54:29 int 8 
nick = turtle time = 27 22:54:37 Или int _debug если у меня в примере смотреть. 
nick = turtle time = 27 22:54:43 Но память там не продебажишь. 
nick = grepz time = 27 22:55:0 ага, нашёл, спасибо 
nick = grepz time = 27 23:11:10 вообще самое эффективное наверно будет(так как карты будут разные) постоянно сокращать дистанцию с пакманом, выбирая на изгибах навправление к пакману. И обратное если fright mode. Плюс какой-то простой алгоритм, чтобы не ходить кругами. 
nick = grepz time = 27 23:11:27 Потому что какой-то продвинутый алгоритм тут фиг изобразишь 
nick = grepz time = 27 23:11:55 Ну и обход по стенке с левой и правой стороны 
nick = turtle time = 27 23:23:11 Ну попробуй тогда такое изобразить. 
nick = turtle time = 27 23:23:29 fright мод его ещё наверх поворачивает. 
nick = turtle time = 27 23:37:45 swizard: ты gcc dump в репу залил в дальнейшем для сабмита? 
nick = swizard time = 27 23:38:27 не, просто чтобы не транслировать, если вдруг кому-то посмотреть захочется 
nick = swizard time = 27 23:38:40 но можно будет это и сабмитить, если надо 
nick = turtle time = 27 23:40:11 Ну так то да, надо будет рабочее решение в репу ложить. 
nick = turtle time = 27 23:40:21 Я чуть попозже сделаю сборку архива для сабмита. 
nick = swizard time = 27 23:40:43 ага, окей 
nick = swizard time = 27 23:41:19 ща я чуток домучаю охотника на гоустов, и можно будет попробовать даже на скорборд зайти, если получится 
nick = swizard time = 27 23:41:47 там правда уже под 12к очков в среднем :( 
nick = turtle time = 27 23:42:57 Ну, что поделаешь. 
nick = swizard time = 27 23:52:24 фух вроде осилил гоустов 
nick = swizard time = 27 23:52:35 ща попробую перевести на IL и погоняем в эмуляторе 
nick = turtle time = 28 0:2:56 Да, погоням-посмотрим. :) 
nick = swizard time = 28 0:2:59 запушил  
nick = swizard time = 28 0:3:11 вроде работает, от гоустов бегает 
nick = swizard time = 28 0:3:30 но он ещё должен уметь гоняться за синими гоустами, но, почему-то, не делает этого 
nick = swizard time = 28 0:3:44 у него как-то крышу сносит, когда гоусты синие 
nick = turtle time = 28 0:4:46 За фруктом ещё нет у него мотивации бежать? 
nick = swizard time = 28 0:5:14 пока ещё нет 
nick = turtle time = 28 0:5:15 8000 - это получется все пилюли собрал. 
nick = turtle time = 28 0:5:19 И только. 
nick = swizard time = 28 0:5:26 это он у тебя столько набрал? 
nick = turtle time = 28 0:6:10 В эмуляторе. 
nick = turtle time = 28 0:6:34 Смотри, там ещё фрукты два раз появляются. Имеет смысл подождать и не есть все пилюли пока фрукта не будет. 
nick = grepz time = 28 0:7:41 хтрый он у тебя, убегать начинает когда счёт коначается 
nick = grepz time = 28 0:7:42 или совпадение? 
nick = grepz time = 28 0:7:55 гм, а сейчас вообще на месте встрял 
nick = swizard time = 28 0:8:9 у него сейчас, теоретически, должна быть такая стратегия: 
nick = swizard time = 28 0:8:20 1. если близко злой гоуст — драпать 
nick = swizard time = 28 0:8:30 2. если близко синий — гнаться 
nick = turtle time = 28 0:8:35 На месте встрял, это, наверное, тормоза эмулятора. 
nick = swizard time = 28 0:8:41 но со вторым пунктом баг какой-то 
nick = swizard time = 28 0:8:50 он там реально затупить может на какое-то время 
nick = swizard time = 28 0:8:54 ща попробую пофиксить 
nick = grepz time = 28 0:10:24 и ещё, поймал 2-мя гостами его в квадрат 4 на 4, госты затупили с верхнего края квадрата(выход справа для пакмана был возможен), в итоге пакман делает шаг к гостам и шаг от них, так вот они уже почти минуту веселятся. 
nick = turtle time = 28 0:11:32 Хе. :) 
nick = swizard time = 28 0:11:43 блин :) 
nick = swizard time = 28 0:12:32 ща попробую отдебажить эти моменты 
nick = swizard time = 28 0:15:23 а понял причины затупа 
nick = swizard time = 28 0:15:29 это был timeout 
nick = swizard time = 28 0:15:35 там зацикливается что-то 
nick = turtle time = 28 0:26:33 Блин, в лимит не влез. :) 
nick = grepz time = 28 0:26:50 по памяти? 
nick = turtle time = 28 0:28:16 По количеству выполняемых инструкций. 
nick = turtle time = 28 0:28:21 Ты закоммить своего госта. 
nick = grepz time = 28 0:29:1 он пока мало что умеет, пока ещё добиваюсь более-менее разумного поведения 
nick = turtle time = 28 0:29:19 Ну закоммить что есть. 
nick = turtle time = 28 0:29:46 Хотя я тут подумал, можно посчитать на одном шаге, решение принять на другом. Память же сохраняется. 
nick = grepz time = 28 0:37:27 Вопрос, если я бежал направо, решил, что мне нужно бежать налево, для чего повернулся вверх. Там допустим стенка, я правильно понимаю, что я просто уткнусь в стенку и буду стоять на месте до следующего цикла? 
nick = turtle time = 28 0:39:1 Нет. 
nick = turtle time = 28 0:40:0 Тебя там разворачивает вроде как. 
nick = grepz time = 28 0:40:58 гм, сейчас ещё раз проверю тогда 
nick = turtle time = 28 0:41:14 Секцию Movement посмотри в спеке. 
nick = turtle time = 28 0:41:26 Короче, гхост куда-нибудь обязательно двигается. 
nick = turtle time = 28 0:41:37 Куда двигаться выбирается по порядку и куда свободно. 
nick = grepz time = 28 0:43:46 http://gameinternals.com/post/2072558330/understanding-pac-man-ghost-behavior разбор полётов для классического пакмана. :) 
nick = swizard time = 28 1:29:17 если что я там наваял эмулятор пакманий, чтобы можно было нормально дебажить аи 
nick = turtle time = 28 1:31:49 Как ты его запускаешь? 
nick = swizard time = 28 1:32:30 ai&gt; (run-simulator *world-state*) 
nick = swizard time = 28 1:33:0 *world-state* можно взять из ai-cl.lisp, он там закоментированный правда 
nick = swizard time = 28 2:2:35 короче закоммитил пакмана 
nick = swizard time = 28 2:2:49 теперь он стабильно проходит уровни 
nick = swizard time = 28 2:3:1 но надо будет подумать как правильно убегать от гоустов 
nick = swizard time = 28 2:3:8 щас он просто временно шарахается от них 
nick = swizard time = 28 2:3:32 Азамат, ты щас здесь? 
nick = turtle time = 28 2:3:50 Я здесь. 
nick = swizard time = 28 2:4:13 ты уже волновой алгоритм наизусть выучил, наверно? :) 
nick = turtle time = 28 2:5:2 Ну как бы да. 
nick = turtle time = 28 2:6:17 8000 очков. 
nick = turtle time = 28 2:6:22 Опять фрукты не ест. :) 
nick = turtle time = 28 2:6:31 Так у тебя же A* с прошлого контеста есть. 
nick = swizard time = 28 2:6:39 сможешь его быстро накидать на кл, или как-то популярно мне объяснить как его делать? :) 
nick = turtle time = 28 2:6:52 Популярно могу. :) 
nick = swizard time = 28 2:6:56 A* я не могу 1:1 портировать, у нас нету хешей 
nick = swizard time = 28 2:6:59 только списки 
nick = turtle time = 28 2:7:10 В общем, массивчик с нашей картой составляем. 
nick = turtle time = 28 2:7:24 Начальную клетку помечаем нулём. 
nick = turtle time = 28 2:7:41 Потом ещё нужен механизм для пометки того, что клетку смотрели. 
nick = turtle time = 28 2:8:23 Ну и смотрим, если клетку не смотрели и она с каким-то числом, то смотрим соседние. 
nick = turtle time = 28 2:8:41 Если клетки пустые (не стена), то ставим счётчик +1 к текущей. 
nick = turtle time = 28 2:9:4 Ту клетку, с которой смотрели смежную (стартовую) помечаем, что смотрели и вследующий раз не смотрим. 
nick = turtle time = 28 2:9:6 И повторяем. 
nick = turtle time = 28 2:9:24 Пока на целевой клетке не появится число, или пока у нас изменений больше нет. 
nick = turtle time = 28 2:9:44 Если на целевой клетке число так и не появилось, то нельзя пройти. 
nick = turtle time = 28 2:10:0 Если появилось, то пусть простраиваем любой в порядке уменьшения числа по соседним клеткам. 
nick = swizard time = 28 2:10:58 ага примерно понятно, спасибо 
nick = swizard time = 28 2:11:14 во бтв зацените мы в proton-pack восьмое место взяли 
nick = swizard time = 28 2:11:15 http://94.173.40.148/#proton-pack 
nick = swizard time = 28 2:11:31 я все сабмиты в гит складываю на всякий случай 
nick = swizard time = 28 2:11:57 в классике, похоже, не получается в топ попасть 
nick = turtle time = 28 2:12:18 А у тебя бот не волновым алгоритмом что ли ходит? 
nick = swizard time = 28 2:12:42 не, жадным с перебором =) 
nick = swizard time = 28 2:13:4 просто его запрограммировать две секунды, а волновой уже думать надо 
nick = turtle time = 28 2:13:8 Ну в классике он у нас ни фруктов не кушает, ни гостов. 
nick = swizard time = 28 2:13:9 ща попробуем 
nick = turtle time = 28 2:13:18 А у меня с гостом провал, похоже. :) 
nick = turtle time = 28 2:13:57 http://ru.wikipedia.org/wiki/%D0%92%D0%BE%D0%BB%D0%BD%D0%BE%D0%B2%D0%BE%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC 
nick = turtle time = 28 2:14:5 Тут, кстати, иллюстрации есть в тему. 
nick = swizard time = 28 2:16:11 до окончания контеста ещё 14 часов, можно успеть допинать :) 
nick = turtle time = 28 2:16:20 :) 
nick = swizard time = 28 2:18:9 так, в классике нас сожрали 
nick = swizard time = 28 2:18:24 Status: Game over! Lose. You scored 1660 after 38875 game ticks. 
nick = turtle time = 28 2:18:35 Эээх. 
nick = swizard time = 28 2:19:11 на самом деле там у меня где-то беда — не укладываюсь в секунду, похоже: lambdaman program (step function) faulted CycleLimit 
nick = swizard time = 28 2:23:33 хмм 
nick = swizard time = 28 2:23:55 что-то есть ощущение, что нифига волновой алгоритм не подойдёт 
nick = swizard time = 28 2:24:20 потому что массивов в языке нет 
nick = swizard time = 28 2:24:39 а там надо каунтеры в ячейках инкрементировать 
nick = turtle time = 28 2:24:58 А setf тоже что ли нет? 
nick = swizard time = 28 2:25:10 если перестраивать каждый раз список списков — всё погибнет 
nick = swizard time = 28 2:25:13 хм 
nick = swizard time = 28 2:25:27 ST в gcc есть  
nick = swizard time = 28 2:25:33 но в трансляторе он не поддержан 
nick = swizard time = 28 2:25:55 но в любом случае нужно же позиционироваться в списке списков 
nick = swizard time = 28 2:26:10 хотя я это и так, в принципе, периодически делаю 
nick = turtle time = 28 2:26:41 Ну любой 2-мерный массив можно представить одномерным. 
nick = turtle time = 28 2:26:57 Вопрос в том только с каких ячеек начинается новая строка. 
nick = turtle time = 28 2:27:8 Если это не список произвольных списков, а массив, как в нашем случае. 
nick = turtle time = 28 2:27:25 То по ширине края. 
nick = swizard time = 28 2:27:44 а не факт, что одномерный список лучше двумерного :)  
nick = turtle time = 28 2:27:45 В целом, ST - заманчиво выглядит, конечно. 
nick = turtle time = 28 2:27:59 Я не про лучше, а про возможность. :) 
nick = swizard time = 28 2:28:32 в двумерном для позиционирования можно проматывать по рядам, а потом идти к столбцу 
nick = swizard time = 28 2:28:42 а в одномерном придётся долго пилить  
nick = swizard time = 28 2:28:48 короче, надо бы подумать 
nick = turtle time = 28 2:30:13 В одномерном, если в env всё сохранить, то тупо по индексу? Или как он работает? 
nick = swizard time = 28 2:32:0 а по какому индексу, массивов-то нет 
nick = grepz time = 28 2:32:9 Game Over: You lost<br />State<br />Score: 180 Lives: 0 Ticks: 19371  :) 
nick = swizard time = 28 2:32:18 только консы, числа и кложы 
nick = grepz time = 28 2:32:25 это 4 очень тупых госта на простой карте 
nick = grepz time = 28 2:32:33 против текущего пакмана 
nick = swizard time = 28 2:32:46 а как они его? :) 
nick = grepz time = 28 2:33:5 а хз, просто меняют направление в его сторону и ничего больше 
nick = grepz time = 28 2:33:20 он шкерится в тупики или ответвления и там застревает 
nick = swizard time = 28 2:33:26 хехе :)) 
nick = swizard time = 28 2:33:43 да, надо придумать, как правильно убегать от гоустов 
nick = swizard time = 28 2:33:56 щас он просто шарахается недалеко 
nick = grepz time = 28 2:34:0 я себе мозг сломал. незнаю как люди раньше на ассемблере писали... 
nick = turtle time = 28 2:34:26 Так LD 0 0, к примеру, тупо же читает? Если ST его может туда сохранить, то сохраняем сколько угодно. 
nick = swizard time = 28 2:34:31 я в 10 классе три игрушки написал на асме, мне очень нравилось :) 
nick = turtle time = 28 2:34:34 Или я чего-то недопонял? 
nick = turtle time = 28 2:35:5 Я тоже в детстве на асме писал. Вообще другие языки не признавал. Сейчас как-то тяжко. :) 
nick = grepz time = 28 2:35:36 меня миновала чаша сия, только сейчас иногда, но там такие инструкции теперь, каких в некоторых высокоуровневых языказ нет 
nick = swizard time = 28 2:36:15 а дай код своих злобных гоустов, я попробую надрессировать пакмана удирать от них 
nick = grepz time = 28 2:37:44 Где-то через час-два причешу, выложу более-менее рабочее что-то, пока запушу эксперименты, минутку 
nick = grepz time = 28 2:38:58 ghc/ghost/pursue.ghc: very simple pursue mechanism 
nick = grepz time = 28 2:39:3 закомитил 
nick = grepz time = 28 2:40:29 только убери с карты их комнатку, а то они боюсь будут жутко тупить 
nick = swizard time = 28 2:41:55 ок ща гляну 
nick = grepz time = 28 2:44:33 ещё заметил, если у пакмана за спиной стенка, а с обеих сторон впереди него госты он просто стоит на месте 
nick = swizard time = 28 2:45:0 а выход при этом есть? 
nick = grepz time = 28 2:45:19  G    G <br />    #<br />     l<br />##### 
nick = grepz time = 28 2:45:25 блин 
nick = grepz time = 28 2:45:26 сейчас 
nick = swizard time = 28 2:45:28 у меня просто гоусты считаются препятствием при пасфайндинге 
nick = grepz time = 28 2:46:1   <br />   G     G      G<br />          #<br />          #<br />          L<br />######### 
nick = grepz time = 28 2:46:11 вот при таком расположении он стоит на месте 
nick = grepz time = 28 2:46:29 идти впринципе есть куда 
nick = swizard time = 28 2:47:5 ок примерно понял, ща попробую поправить 
nick = grepz time = 28 2:50:11 но впринципе с тупыми агрессивными гостами, которые не убегают в fright mode он справляется хорошо 
nick = grepz time = 28 2:50:24 я бы ещё ввёл отслеживание счётчика fright mode 
nick = grepz time = 28 2:50:33 а то он отважно бросается на них под самый конец 
nick = grepz time = 28 2:54:42 да, и в определённых позициях пакмана и госта у оргов вешается скрипт... :/ понятное дело вместе с моим браузером 
nick = swizard time = 28 2:54:55 да, у меня чёто тоже :( 
nick = swizard time = 28 2:55:15 а gcc vm там прямо на джаваскрипте чтоли? 
nick = turtle time = 28 2:55:26 Ага. 
nick = grepz time = 28 2:55:28 да 
nick = swizard time = 28 2:56:46 интересно 
nick = turtle time = 28 2:57:0 Заобфускаченный. Хотел было память смотреть удобно, геморно. :) 
nick = turtle time = 28 2:57:7 Сходу не разобрался, забил. 
nick = grepz time = 28 2:57:32 тоже самое, пытался вникнуть, забил 
nick = turtle time = 28 2:57:57 Ты мне лучше расскажи как ты на сближение идёшь с пакманом? 
nick = turtle time = 28 2:58:19 А то мой волновой алгоритм обломался, разбившись об ограничения. :( 
nick = grepz time = 28 3:0:20 вобщем там сейчас работает нормально только выбор направления до пакмана.<br />По идее должно быть так:<br />1. Узнали где пакман относительно госта(up/down, left/right)<br />2. Узнали что находится вокрут(1 клетка)<br />3. Далее выбрали направление до пакмана исходя из текущего вектора движения, если противоположный вектор по X, меняем Y, и т.д.<br />И всё это ещё фильтруется условием наличия стенок вокруг нас 
nick = grepz time = 28 3:1:35 тут ещё надо добавить отслеживание уже пройденных клеток, хотя бы трейс из 5-10, чтобы избежать блуждания в комнатках 
nick = turtle time = 28 3:1:54 Можно в области памяти стек соорудить. 
nick = turtle time = 28 3:2:3 И туда пушить клетки. 
nick = swizard time = 28 3:2:5 кстати да, если комнату не убрать, то все привидения выбраться из неё не могут :) 
nick = grepz time = 28 3:2:20 да, есть такое 
nick = turtle time = 28 3:2:29 Меня, собственно, это и сподвигло на волновой алгоритм. 
nick = grepz time = 28 3:3:59 Свиз, прошёл пакман хоть раз уровень у тебя? 
nick = grepz time = 28 3:4:20 имеется ввиду с этими агрессивными гостами 
nick = swizard time = 28 3:4:24 с твоими привиденьями нет, но я запускал всего пару раз 
nick = swizard time = 28 3:4:35 ща я переделываю немного алгоритм шараханья от гоустов 
nick = grepz time = 28 3:4:39 ок 
nick = swizard time = 28 3:5:6 точнее один раз прошёл легко — когда все гоусты в клетке застряли =) 
nick = grepz time = 28 3:6:2 :) 
nick = sectoid time = 28 3:6:2 мда... &quot;отошел&quot; называется... 
nick = grepz time = 28 3:6:32 есть кстати ещё вариант для гостов: если мы напоролись на собственный трейс, включить режим блуждания по стенке на N ходов 
nick = sectoid time = 28 3:6:49 привет, тим 
nick = sectoid time = 28 3:6:52 могу чем-то помочь? 
nick = grepz time = 28 3:6:55 привет 
nick = turtle time = 28 3:7:4 Привет. Если логов нет, я тебе свежие логи в репу положил. 
nick = sectoid time = 28 3:7:54 логи есть 
nick = sectoid time = 28 3:7:57 вкуриваю 
nick = grepz time = 28 3:9:23 пойду порисую схемки, 8 утра, голова совсем не работает, да ещё этот чёртов ассемблер... 
nick = grepz time = 28 3:9:32 а схемки всегда помогают :) 
nick = swizard time = 28 3:9:57 может, тебе лучше поспать хоть немного? :) 
nick = swizard time = 28 3:10:11 до окончания ещё 11 часов 
nick = sectoid time = 28 3:10:16 swizard: логи длинные, зараза 
nick = sectoid time = 28 3:10:27 можно выжимку?) 
nick = grepz time = 28 3:10:31 надо добить пару багов, а то потом вспоминать придётся что делал 
nick = swizard time = 28 3:11:44 sectoid: вкрадце: к транслятору с cl я так и не приступал, задо доделал ai, который взял у нас 8-е место на самой простой карте, сейчас ковыряю дальше. grepz сделал аггресивных гоустов, которые, если нигде не застрянут, сжирают моего пакмана без шансов  
nick = swizard time = 28 3:12:0 короче, дело потихоньку идёт 
nick = sectoid time = 28 3:12:7 отлично 
nick = sectoid time = 28 3:12:14 ты пишешь в ilisp? 
nick = swizard time = 28 3:12:25 нет, в кл, потом руками портирую :( 
nick = sectoid time = 28 3:12:32 понятно 
nick = sectoid time = 28 3:12:40 т.е. резон добить компилер таки есть? 
nick = swizard time = 28 3:12:46 конечноно я себе написал эмулятор, и  
nick = swizard time = 28 3:12:51 тоесть да 
nick = swizard time = 28 3:13:2 и я себе написал эмулятор игры 
nick = swizard time = 28 3:13:8 правда там гоусты не ходят 
nick = swizard time = 28 3:13:15 но аи пакмана отлаживать можно 
nick = sectoid time = 28 3:13:20 эх 
nick = sectoid time = 28 3:13:27 это то, что таки да, надо было сходу писать 
nick = swizard time = 28 3:13:38 поэтому было бы ваще круто если бы гцц код можно было сразу из кл получать 
nick = sectoid time = 28 3:13:49 счас сделаю) 
nick = sectoid time = 28 3:13:56 ты подмножество не расширял пока? 
nick = swizard time = 28 3:14:8 нет, наоборот, сузил =) 
nick = sectoid time = 28 3:14:53 годнота 
nick = sectoid time = 28 3:15:4 счас тогда допинаю CL-транслятор перед сном 
nick = swizard time = 28 3:15:26 ага 
nick = swizard time = 28 3:15:48 там кстати баги небольшие в ilisp’е всплыли 
nick = sectoid time = 28 3:16:2 какого рода? 
nick = swizard time = 28 3:16:18 в какой-то вариации дерева if-ов он вложенный (if … ) начинает считать вызовом функции 
nick = swizard time = 28 3:16:31 и ругается, что нет такой функции if 
nick = sectoid time = 28 3:16:52 ммм 
nick = sectoid time = 28 3:16:57 примера нетути? 
nick = swizard time = 28 3:17:3 попробую ща повторить 
nick = sectoid time = 28 3:17:5 а ты там точно подставлял ilisp:if ? 
nick = sectoid time = 28 3:17:15 может ты забыл там вставить ilisp? 
nick = swizard time = 28 3:17:16 у меня там :use :il 
nick = sectoid time = 28 3:17:19 ммм 
nick = sectoid time = 28 3:17:22 ммммм 
nick = sectoid time = 28 3:17:45 если снова наступишь - сдампай примерчик (не обязательно даже минимальный) 
nick = sectoid time = 28 3:18:56 /me пашет час, потом спать. утром около 11 по киеву снова вольюсь. 
nick = sectoid time = 28 3:19:3 жалко сегодняшний вечер( 
nick = turtle time = 28 3:19:54 Я через два часа отойду и в 10-11 по МСК планирую опять тут. 
nick = swizard time = 28 3:19:59 ну ок спокойной ночи 
nick = swizard time = 28 3:20:19 да я наверно тоже ещё часа полтора-два посижу 
nick = sectoid time = 28 3:21:17 спокойной ночи еще рано мне) я пока тут) 
nick = swizard time = 28 3:21:45 а отлично, тогда я щас тебе тесткейс с ифом дам  
nick = turtle time = 28 3:21:55 Пойду гуглу читать. Что-то идей нет пока как в лабиринтах ходить. 
nick = turtle time = 28 3:22:3 За дёшево. :) 
nick = swizard time = 28 3:23:0 а чем тебе не нравится текущий пакманий пасфайндинг? 
nick = sectoid time = 28 3:24:13 тем что не лезет в ghost'а?) 
nick = sectoid time = 28 3:24:18 или это уже для пакмана? 
nick = turtle time = 28 3:24:43 Я пока не знаю как его на асме сделать. И сколько нужно будет ресурсов. 
nick = turtle time = 28 3:24:51 Вкратце, кстати, напомни что за алгоритм. 
nick = swizard time = 28 3:25:3 он вообще элементарный: 1. смотрим, куда можно пойти из стартовой позиции, 2. делаем цикл по доступным из стартовой позиции клеткам, 3. переносим стартовую позицию в первую клетку и рекурсивно повторяем 1. 
nick = swizard time = 28 3:25:20 если путь найден — ок, если нет, то берём следующую доступную клетку 
nick = turtle time = 28 3:25:44 Ну тут циклов CPU не хватит. 
nick = turtle time = 28 3:25:51 Там всего 1024 инструкции на шаг. 
nick = swizard time = 28 3:26:3 хм 
nick = turtle time = 28 3:26:32 Да и рекурсивно делать... Это... :) 
nick = turtle time = 28 3:26:47 Там ещё и памяти нема. :) 
nick = sectoid time = 28 3:26:56 свиз:<br />Variable GAME-LOOP unbound<br />   [Condition of type SIMPLE-ERROR]<br /> 
nick = swizard time = 28 3:26:57 хех :) 
nick = swizard time = 28 3:27:4 хм 
nick = swizard time = 28 3:27:14 а ты обновил репо? 
nick = sectoid time = 28 3:27:19 тока что мержил 
nick = sectoid time = 28 3:27:22 счас еще вытяну 
nick = swizard time = 28 3:27:33 а понял 
nick = sectoid time = 28 3:27:37 да, у меня последний мастер 
nick = swizard time = 28 3:27:42 ща пофикшу 
nick = sectoid time = 28 3:28:0 гуть, жду 
nick = swizard time = 28 3:28:40 блин вот кстати да 
nick = swizard time = 28 3:28:56 надо видимо чем-то чистить хеш библиотечных функций 
nick = sectoid time = 28 3:29:10 новый транслятор лишен этого 
nick = sectoid time = 28 3:29:23 у него хэш - в инстансе транлсятора 
nick = swizard time = 28 3:29:23 потому как я функцию переназвал, в одном месте забыл поменять, и он старую использует спокойно 
nick = swizard time = 28 3:29:36 о круто 
nick = sectoid time = 28 3:29:46 и он (хеш) перезаполняется при каждом (build-ai ...) 
nick = sectoid time = 28 3:30:37 (build-ai (list #p&quot;./ilisp/stdlib.lisp&quot; #p&quot;./ai/ai-cl.lisp&quot;) #P&quot;./test.gcc&quot; 'gcc-init)<br /><br />вот магическая команда) счас если после исправлений заработает - быть хэппи) 
nick = sectoid time = 28 3:31:55 swizard: жду фикса 
nick = swizard time = 28 3:32:34 ушёл 
nick = swizard time = 28 3:32:52 слушай, а вот в КЛ я делаю (funcall (make-game-loop) …) 
nick = swizard time = 28 3:33:8 а в lisp я могу ((make-game-loop) …) сделать? 
nick = sectoid time = 28 3:33:17 о, новая бага 
nick = sectoid time = 28 3:33:21 мммм 
nick = sectoid time = 28 3:33:23 мммммм 
nick = swizard time = 28 3:33:27 или мне надо забиндить? 
nick = sectoid time = 28 3:33:32 вот это кажется оно и есть 
nick = sectoid time = 28 3:33:37 у меня funcall кривой 
nick = sectoid time = 28 3:33:42 счас улучшу - перекоммичу 
nick = swizard time = 28 3:33:53 давай 
nick = sectoid time = 28 3:36:43 функал починил. выяснилось что у нас нет &lt; ;))) 
nick = swizard time = 28 3:37:33 да у нас дофига чего нет, например, OR :) 
nick = sectoid time = 28 3:38:4 могу вернуть 
nick = grepz time = 28 3:38:4 эм, &lt; и &lt;= я сегодня добавлял, должны быть 
nick = sectoid time = 28 3:38:14 grepz: ты не туда добавлял) 
nick = grepz time = 28 3:38:21 ок :) 
nick = sectoid time = 28 3:38:25 в бранче новый транслятор 
nick = sectoid time = 28 3:38:28 счас сделаю макры 
nick = sectoid time = 28 3:38:41 (&lt; a b) == (not (&gt;= a b)) ? 
nick = sectoid time = 28 3:48:42 (defmacro and (&amp;rest args)<br />  (case (length args)<br />    (0 0)<br />    (1 (first args))<br />    (t `(if ,(first args) <br />            ,(first args)<br />            (and ,@(cdr args)))))) 
nick = sectoid time = 28 3:48:43 я прав? 
nick = swizard time = 28 3:49:26 по-моему это OR 
nick = sectoid time = 28 3:49:27 нет, не прав 
nick = sectoid time = 28 3:49:29 это OR 
nick = swizard time = 28 3:50:21 ты в репле напиши (or 1 2 3 4) и сделай C-c C-m на форму 
nick = swizard time = 28 3:50:27 он тебе нарисует как надо 
nick = sectoid time = 28 3:50:36 ага 
nick = sectoid time = 28 3:50:40 спасиб 
nick = sectoid time = 28 3:51:33 а у нас никакой там операции and/or не было? 
nick = sectoid time = 28 3:51:38 мы ручами их писали раньше? 
nick = sectoid time = 28 3:51:56 ага, ручами 
nick = sectoid time = 28 3:52:8 лан, если будет сильно жЫрно - сделаю оптимизированый 
nick = turtle time = 28 3:52:14 Ручками писали, да. 
nick = sectoid time = 28 3:53:54 ыыыыыы 
nick = sectoid time = 28 3:53:56 собрался AI 
nick = swizard time = 28 3:54:12 что, даже работает? :) 
nick = swizard time = 28 3:54:36 если да, то давай-ка его в мастер, а то я взмок уже две версии синхронизировать :) 
nick = sectoid time = 28 3:55:30 как проверить? в игру его? 
nick = swizard time = 28 3:56:3 ага 
nick = swizard time = 28 3:56:33 ну или можешь попробовать посравнивать с аналогом power-pill-hunter.gcc 
nick = swizard time = 28 3:56:42 но наверно там асм ведь не 1:1 будет 
nick = sectoid time = 28 3:56:59 lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty<br />lambdaman program (step function) faulted DataStackEmpty 
nick = sectoid time = 28 3:57:1 хнык 
nick = sectoid time = 28 3:57:11 где-то налагал 
nick = swizard time = 28 3:57:31 попробуй сначала always-down скомпилить 
nick = swizard time = 28 3:57:35 сделать тебе рыбу? 
nick = swizard time = 28 3:57:41 на кл в смысле 
nick = sectoid time = 28 3:59:4 счас найду 
nick = sectoid time = 28 3:59:9 я кажись понял где налажал 
nick = grepz time = 28 4:1:20 lambdaman program (step function) faulted CycleLimit 
nick = grepz time = 28 4:1:27 это значит что он все тики отъел? 
nick = sectoid time = 28 4:1:33 ага 
nick = sectoid time = 28 4:1:37 не тики 
nick = sectoid time = 28 4:1:43 наверное кол-во вычислений 
nick = grepz time = 28 4:1:51 ну cpu tick 
nick = grepz time = 28 4:2:9 не game tick, но это уже детали 
nick = grepz time = 28 4:2:51 1	90240	TGO 
nick = grepz time = 28 4:2:57 Вот это хайскор 
nick = swizard time = 28 4:4:14 блин а что же мне делать c cyclelimit 
nick = swizard time = 28 4:4:29 я даже не очень представляю, где он может у меня отъедаться вообще 
nick = grepz time = 28 4:5:31 возникает такое ощущение что он просто в лупе вешается 
nick = sectoid time = 28 4:5:59 а у меня где-то адреса поехали... 
nick = grepz time = 28 4:6:49 притом очень чётко вешается, когда ему госты ходы перекрывают 
nick = swizard time = 28 4:7:2 вообще у меня пасфайнд с лимитом 
nick = swizard time = 28 4:7:5 попробую уменьшить 
nick = grepz time = 28 4:7:10 а теперь ещё и вот: lambdaman program (step function) faulted TagMismatch 
nick = grepz time = 28 4:7:20 ####################<br />#\.=...............#<br /># ##################<br /># ...=.............#<br /># ##################<br /># .....=...........#<br /># ##################<br /># .......=.........#<br /># ##################<br /># .........=.......#<br /># ##################<br /># ...........=.....#<br /># ##################<br /># .............=...#<br /># ##################<br /># ...............=.#<br /># ##################<br /># oooooooooooooooo%#<br />#################### 
nick = grepz time = 28 4:7:26 вот на этой карте 
nick = grepz time = 28 4:7:34 блин, вобщем ты понял :) 
nick = swizard time = 28 4:7:52 закоммить плз эту карту в ai/maps в текстовом виде, я её на симуляторе отлажу 
nick = grepz time = 28 4:8:0 сейчас 
nick = grepz time = 28 4:9:8 готово 
nick = grepz time = 28 4:9:23 да, походу просто где-то баг 
nick = grepz time = 28 4:9:34 таг мисматч и выедает всё время 
nick = swizard time = 28 4:9:50 если это так, ща быстро выловим в симуляторе 
nick = swizard time = 28 4:9:55 бтв 12 часов осталось 
nick = swizard time = 28 4:10:13 надо быстренько научить пакмана фрукты жрать 
nick = grepz time = 28 4:10:33 кстати, ещё момент, он у тебя что делает, когда power pills рядом лежат? 
nick = swizard time = 28 4:10:46 жрёт их 
nick = sectoid time = 28 4:10:56 Error: Failed parsing 'lambdaman.gcc' :<br />Expected  at position LineColPos 41 0 479 expecting one of [';', ] at LineColPos 41 0 479 :<br />                              v<br />DD     LDC 2     CONS     RTN BDA3858 40):     LD 2 0     LD 2 1     LD<br />                              ^ 
nick = sectoid time = 28 4:10:59 еще лучше( 
nick = swizard time = 28 4:11:13 он сначала целенаправленно обходит все power pils, а потом только обычные точки 
nick = swizard time = 28 4:11:19 ээ 
nick = sectoid time = 28 4:11:20 опа... жоп-па 
nick = grepz time = 28 4:11:42 ситуация: гост в 3 клетках от пакмана и движется на него, а он выжирает все power pills 
nick = sectoid time = 28 4:11:46 а, понял) 
nick = grepz time = 28 4:11:47 вобщем на этой карте всё видно 
nick = sectoid time = 28 4:12:21 swizard: if-exists :overwrite это не то что ты хочешь;) ты хочешь :supersede 
nick = sectoid time = 28 4:12:55 собраный always-down работает верно 
nick = sectoid time = 28 4:13:0 а вот ai-cl - нет( 
nick = grepz time = 28 4:13:31 ещё одну карту пушнул, из hall-of-fame 
nick = grepz time = 28 4:13:42 на ней госты его почти сразу ловят 
nick = sectoid time = 28 4:13:43 lambdaman program (step function) faulted DataStackEmpty<br /> 
nick = sectoid time = 28 4:15:14 возможно я неверно транслирую какой-то терм... 
nick = turtle time = 28 4:18:3 Если адреса едут, может, это из-за неуникальности меток. 
nick = sectoid time = 28 4:18:19 не уверен что там адреса едут... 
nick = turtle time = 28 4:18:20 Как там нумерация происходит? По наименованию? 
nick = sectoid time = 28 4:18:30 свиз, а есть какой-то 100% рабочий ai? 
nick = sectoid time = 28 4:18:37 который ты руками транслировал в IL 
nick = turtle time = 28 4:18:54 Свиз, ты его волновому алгоритму обучил? 
nick = sectoid time = 28 4:18:57 power-pill-hunter.lisp ? 
nick = swizard time = 28 4:19:1 да 
nick = swizard time = 28 4:19:20 нет, волновому не стал 
nick = swizard time = 28 4:19:28 и так в циклы где-то не укладываемся 
nick = swizard time = 28 4:25:5 grepz, а глянь плз, продолжает ли щас крашиться  
nick = swizard time = 28 4:25:9 я там чуток поправил 
nick = grepz time = 28 4:25:18 момент 
nick = grepz time = 28 4:26:33 cyclelimit опять 
nick = swizard time = 28 4:26:57 cyclelimit да, я надеюсь его щас побороть, вроде понял в чём дело 
nick = swizard time = 28 4:27:7 а type mismatch? 
nick = sectoid time = 28 4:27:11 мержить в мастер мой бранч? 
nick = swizard time = 28 4:27:17 давай 
nick = grepz time = 28 4:27:22 type mismatch пока не вижу 
nick = sectoid time = 28 4:28:13 подлил 
nick = sectoid time = 28 4:28:24 собирать ботов вот так:<br />(build-ai (list #p&quot;./ilisp/stdlib.lisp&quot; #p&quot;./ai/ai-cl.lisp&quot;) #P&quot;./test.gcc&quot; 'gcc-init :debug nil) 
nick = sectoid time = 28 4:28:39 первая - обязательно - это stdlib нашел ILisp'а 
nick = sectoid time = 28 4:28:46 второй исходник - бот 
nick = swizard time = 28 4:29:12 оно рабочий код генерит, ты проверял, да? 
nick = sectoid time = 28 4:29:24 (build-ai (list #p&quot;./ilisp/stdlib.lisp&quot; #p&quot;./ilisp/examples/power-pill-hunter.lisp&quot;) #P&quot;./test.gcc&quot; 'gcc-init :debug nil) 
nick = sectoid time = 28 4:29:34 собрало рабочий powerpill 
nick = sectoid time = 28 4:32:6 в ./ilisp/stdlib.lisp можно дописывать новые библиотечные макры/функции 
nick = grepz time = 28 4:32:15 нет, опять type mismatch 
nick = grepz time = 28 4:32:27 *tag mismatch 
nick = grepz time = 28 4:32:46 и опять на той же карте с кучей power pills 
nick = sectoid time = 28 4:32:46 оно хоть бы говорило по какому адресу type mismatch 
nick = grepz time = 28 4:33:14 дебага тут явно не хватает конечно, что с гостами, что с пакманом 
nick = sectoid time = 28 4:33:38 могу впилить спец-формы break и trace 
nick = swizard time = 28 4:35:18 так, вроде бы должен победить cyclelimit 
nick = swizard time = 28 4:35:31 ща попробуем сразу по-царски cl скомпилить 
nick = swizard time = 28 4:35:35 такс 
nick = sectoid time = 28 4:36:36 закинул поддержку (break)/(trace x) 
nick = sectoid time = 28 4:37:39 на этом я наверное опрокинусь 
nick = swizard time = 28 4:37:57 ща погоди буквально 30 секунд 
nick = swizard time = 28 4:38:4 я пробою скомпилить 
nick = swizard time = 28 4:38:10 если всё ок будет, то иди :) 
nick = sectoid time = 28 4:38:19 жду) 
nick = swizard time = 28 4:41:6 так окей, build-ai у меня получился 
nick = swizard time = 28 4:41:17 а с CL пока откладываем, да? 
nick = sectoid time = 28 4:42:14 что с CL? :) 
nick = sectoid time = 28 4:42:17 не понял) 
nick = sectoid time = 28 4:42:26 build-ai должен ждать и CL-код 
nick = swizard time = 28 4:42:35 хм 
nick = swizard time = 28 4:43:18 не хочет :( 
nick = sectoid time = 28 4:43:25 как пробуешь? 
nick = sectoid time = 28 4:43:27 что говорит? 
nick = swizard time = 28 4:43:39 IMPL&gt; (build-ai (list #p&quot;../ilisp/stdlib.lisp&quot; #p&quot;../ai/ai-cl.lisp&quot;) #P&quot;../ilisp/examples/power-pill-hunter.gcc&quot; 'gcc-init :debug nil) 
nick = swizard time = 28 4:43:55 lambdaman program (step function) faulted DataStackEmpty<br /> 
nick = sectoid time = 28 4:44:21 цуко 
nick = sectoid time = 28 4:44:27 значит где-то таки нафакапил 
nick = sectoid time = 28 4:44:52 а они счас идентичны, только power-pull-hunter.lisp на IL, а ai-cl.lisp на CL? 
nick = sectoid time = 28 4:45:0 верно? 
nick = swizard time = 28 4:45:4 но он при этом транслирует работоспособный код на ilisp, это нормально? :) 
nick = swizard time = 28 4:45:27 ну практически идентичны, с точностью до небольшого фикса в plan-path 
nick = swizard time = 28 4:45:41 plan-route тоесть 
nick = swizard time = 28 4:46:26 ну или погоди секунду 
nick = swizard time = 28 4:46:42 а ну да 
nick = swizard time = 28 4:48:1 могу закоммитить свой фикс 
nick = sectoid time = 28 4:48:6 давай 
nick = sectoid time = 28 4:48:21 мне прост надо отыскать где он бочинить 
nick = swizard time = 28 4:49:19 ушло 
nick = sectoid time = 28 4:49:44 есть подозрение у меня на (funcall (make-game-loop (make-ai-state next-path)) map pacman-info ghosts fruits) 
nick = swizard time = 28 4:50:20 а если это самое с let переписать? 
nick = sectoid time = 28 4:51:5 сравни make-game-loop в ai-cl и power-hunger 
nick = swizard time = 28 4:51:33 что за power-hunger? 
nick = swizard time = 28 4:51:37 hunter? 
nick = swizard time = 28 4:51:42 ну да я там так переписал 
nick = sectoid time = 28 4:51:53 хммм 
nick = sectoid time = 28 4:53:6 ошибка сохраняется 
nick = sectoid time = 28 4:53:9 вот зараза 
nick = swizard time = 28 4:53:35 вот блин я ещё и на ilisp теперь не могу перенести фикс :( 
nick = sectoid time = 28 4:53:47 почему не можешь? 
nick = sectoid time = 28 4:54:8 ilisp-вариант он собирает верно 
nick = sectoid time = 28 4:54:13 и все работает 
nick = swizard time = 28 4:54:36 эмм 
nick = sectoid time = 28 4:54:57 хм... 
nick = swizard time = 28 4:54:59 а кто оттуда поубирал все defpackage и тд :)  
nick = sectoid time = 28 4:55:6 я поубирал 
nick = sectoid time = 28 4:55:15 ибо теперь они не нужны 
nick = sectoid time = 28 4:55:27 теперь все через build-ai собирается 
nick = sectoid time = 28 4:55:36 который умеет и ilisp и common lisp 
nick = sectoid time = 28 4:55:45 ну, должен уметь common lisp 
nick = swizard time = 28 4:57:1 понял 
nick = swizard time = 28 4:57:15 я думал, по-старому тоже можно  
nick = swizard time = 28 4:57:17 ну да ладно 
nick = swizard time = 28 4:57:46 лимиты не работают, короче, всё равно у меня cyclelimit 
nick = swizard time = 28 4:58:0 ща будем дебажить 
nick = sectoid time = 28 4:58:52 можешь еще поглядеть на stdlib.lisp 
nick = sectoid time = 28 4:59:0 внимательно изучить тамошние макры 
nick = sectoid time = 28 4:59:5 может я что-то неверно написал 
nick = sectoid time = 28 5:0:39 у меня голова просто уже не работает 
nick = swizard time = 28 5:1:24 да, давай лучше спать иди 
nick = swizard time = 28 5:1:37 я тоже щас чуток ещё потуплю и пойду 
nick = sectoid time = 28 5:1:39 ночи всем 
nick = swizard time = 28 5:1:43 пока 
nick = turtle time = 28 5:2:57 Пока. 
nick = grepz time = 28 5:10:1 swizard, tag mismatch очень чётко возникает, когда госты запирают пакмана, например в такой ситуации:<br />       #=#<br />       # #<br /> ###\#<br />  =     #<br />#### 
nick = swizard time = 28 5:10:37 понял, щас попробую промоделировать 
nick = grepz time = 28 5:12:0 ну и ещё момент: если убрать power pills то проблема исчезает 
nick = swizard time = 28 5:23:52 вроде пофиксил проблему 
nick = grepz time = 28 5:25:12 да, больше ошибка не возникает 
nick = grepz time = 28 5:26:3 а в чём проблема была? 
nick = swizard time = 28 5:27:38 да там тривиальная — путь был невозможен, и в одном месте это не проверилось 
nick = swizard time = 28 5:28:25 да и вроде победил cyclelimits 
nick = grepz time = 28 5:28:34 крута :) 
nick = swizard time = 28 5:28:41 по крайней мере у меня не получается его щас повторить 
nick = swizard time = 28 5:28:56 если ты наткнёшься — дай карту тогда 
nick = grepz time = 28 5:29:0 ок 
nick = swizard time = 28 5:29:45 ща наверно попробую быстро-быстро поддержать фрукт и надо будет хоть немного поспать 
nick = swizard time = 28 5:29:59 пойду только чаю заварю 
nick = grepz time = 28 5:30:26 Ок, я ещё потестирую пакмана/поковыряюсь в гостах, да на работу. :( 
nick = swizard time = 28 5:30:41 окей 
nick = swizard time = 28 5:30:59 ну ладно, в любом случае, какой-то ненулевой сабмишн у нас есть 
nick = swizard time = 28 5:31:7 какой-то пакман, и какие-то гоусты 
nick = swizard time = 28 5:31:25 пакман при должном везении проходит уровни, а гоусты при должном везении сжирают пакмана 
nick = grepz time = 28 5:31:45 будут фрукты, думается и очки выше будут гораздо 
nick = swizard time = 28 5:31:50 блин там в скорборде уже 17600 на классической карте =) 
nick = grepz time = 28 5:31:55 да-да 
nick = grepz time = 28 5:33:16 Может ещё turtle что-то более вразумительное сможет сваять, время ещё есть 
nick = grepz time = 28 5:33:26 это по поводу гостов 
nick = turtle time = 28 5:33:51 Я отойду до 10-11. 
nick = turtle time = 28 5:33:59 Я там сделал отметку тупиков. 
nick = swizard time = 28 5:34:7 давай, спокойной ночи 
nick = turtle time = 28 5:34:10 Но что-то он поиск по нему произвести не может. :) 
nick = turtle time = 28 5:34:20 А так почти хороший вариант. :) 
nick = turtle time = 28 5:35:59 grepz: ты там одним глазком глянь. 
nick = turtle time = 28 5:36:8 Может, я леса не увидел за деревьями. 
nick = grepz time = 28 5:36:10 ты пушил? 
nick = turtle time = 28 5:36:16 Да. 
nick = grepz time = 28 5:36:25 ок, сейчас кофе глотну и посмотрю 
nick = turtle time = 28 5:36:35 Ещё, если не ложисья спать, сделай какого-нибудь госта cpu-eater. 
nick = turtle time = 28 5:36:53 Смысл в том, чтобы он как можно больше операций у вражеского лямбдамена взял по расчёту. 
nick = turtle time = 28 5:37:4 Ну и движение своё можешь добавить. Главное, чтобы cpu кушал. 
nick = grepz time = 28 5:37:15 ок. :) попробую 
nick = swizard time = 28 5:58:25 сделал поддержку фруктов, но работает кривовато :) 
nick = swizard time = 28 5:58:50 он боится гоустов, которые сидят в своей каморке, и не может его сожрать 
nick = grepz time = 28 5:59:20 ну тут только если препятствия обсчитывать, то есть длинну хода для госта, тяжеловато 
nick = swizard time = 28 6:1:34 может попробовать за фруктами напролом переть :) 
nick = grepz time = 28 6:2:15 лучше завершить уровень чем помереть. :) 
nick = grepz time = 28 6:4:9 не пробовал на скорборду запускать? 
nick = swizard time = 28 6:4:30 ща попробую 
nick = swizard time = 28 6:5:12 Status: Game over! Lose. You scored 1960 after 35361 game ticks. 
nick = grepz time = 28 6:5:23 это на классике? 
nick = swizard time = 28 6:6:19 да, на proton-pack столько же сколько и было 
nick = swizard time = 28 6:6:31 ввидимо там тоже фрукт не дают сожрать :( 
nick = swizard time = 28 6:6:37 ща подумаю ещё 
nick = grepz time = 28 6:7:6 я попробую туртлевских гостов и моих позапускать с твоим новым ботом 
nick = grepz time = 28 6:7:11 посмотрим результат 
nick = grepz time = 28 6:11:4 не, его бот также тупит в тесных помещениях как и мой 
nick = grepz time = 28 6:11:23 но вместе они всё равно неплохо работают если им удаётся выйти 
nick = grepz time = 28 6:11:46 агрессивные преследуют, а эти разбредаются по карте и непроизвольно блокируют пути 
nick = grepz time = 28 6:14:29 ещё один момент, если агрессивный садится на хвост и пакман идёт по дорожке pills'ов, то агрессивный догоняет пакмана 
nick = swizard time = 28 6:15:22 за счёт того, что он быстрее? 
nick = grepz time = 28 6:15:50 вроде бы скорость при съедании pills'ов понижается 
nick = grepz time = 28 6:16:8 где-то в правилах это видел 
nick = grepz time = 28 6:16:26 да: Lambda-Man (eating) 	137 
nick = grepz time = 28 6:16:31 Lambda-Man 	127 
nick = grepz time = 28 6:16:36 ticks per move 
nick = grepz time = 28 6:17:37 проблема в том, чтобы эффективно сесть на хвост агрессивному нужно находится на небольшом расстоянии клеток до 5 
nick = grepz time = 28 6:17:47 иначе он теряет пакмана в развилках 
nick = swizard time = 28 6:19:53 хм 
nick = swizard time = 28 6:23:13 так, вроде получилось сожрать фрукт 
nick = swizard time = 28 6:23:21 но опять вернулись cyclelimit 
nick = swizard time = 28 6:24:48 блин правда стал как-то странно от гоустов убегать 
nick = swizard time = 28 6:24:59 они его раз в свою клетку загнали и сожрали 
nick = grepz time = 28 6:25:25 ну вот та версия, что в репе вполне исправно бегает по лабиринту 
nick = swizard time = 28 6:26:1 я пока последнюю ещё не запушил 
nick = swizard time = 28 6:26:10 не факт ещё, что она лучше 
nick = grepz time = 28 6:36:6 ещё момент, бывает что пакман будучи преследуем и оторвавшись от преслодователя на 3-4 клетки поворачивает в сторону преслодователя, потом вроде соображает и опять начинает убегать 
nick = swizard time = 28 6:36:44 да, у него есть такое :) 
nick = swizard time = 28 6:37:2 блин, не работает чёто 
nick = swizard time = 28 6:37:19 ладно, коммичу в отдельную ветку, пойду посплю хоть немного 
nick = grepz time = 28 6:38:6 удачи, я на работу, сейчас закомичу последние изменения в гостах, но эксперимент с бэктрекингом пока провалился с треском, попытаюсь успеть доделать сегодня 
nick = swizard time = 28 6:38:32 хорошо, пока! 
nick = grepz time = 28 6:48:39 нормально, если turtle отладит своих выходящих из тупиков гостов, то всё будет ок, добился, что агресивные госты всё-таки вылазят из тупиков, но нужно чтобы пакман хотя бы рядом пробегал 
nick = grepz time = 28 6:48:53 а дальше они уже пытаются сесть ему на хвост 
nick = turtle time = 28 9:49:13 Всем привет. 
nick = turtle time = 28 9:49:21 Новостей, я так понимаю, нет? :) 
nick = turtle time = 28 9:50:13 А что, волновой алгоритм действительно так накладен по инструкциям? 
nick = turtle time = 28 9:50:44 Просто на самом деле бы расчитывать через какое количество шагов гост может подобраться если в кратчайший путь идти. 
nick = swizard time = 28 11:31:27 привет 
nick = swizard time = 28 11:31:42 ничего себе ты монстр ч 10 встал 
nick = turtle time = 28 11:31:54 Да я не ложился. :) 
nick = turtle time = 28 11:32:11 Я просто на праздник сходил отлучался. 
nick = swizard time = 28 11:35:17 волновой алгоритм действительно накладен по инструкциям без ST 
nick = swizard time = 28 11:35:36 а как правильно ST сделать надо подумать 
nick = turtle time = 28 11:35:40 Типа, по консам приходится много ходить? 
nick = swizard time = 28 11:36:22 да, либо консить много, либо как-то хитро деструктивно каунтеры делать 
nick = turtle time = 28 11:37:9 Может, ST даст нужную императивную хрень? 
nick = swizard time = 28 11:37:15 я ща подумаю, может, попробовать быстро щас сделать и всё равно поэкспериментировать 
nick = swizard time = 28 11:37:25 просто там карты пока маленькие  
nick = swizard time = 28 11:37:39 на них мож нормально всё будет 
nick = turtle time = 28 11:38:25 Ну, можно так то. 
nick = turtle time = 28 11:38:42 У меня гост на большую карту не расчитан. :) 
nick = turtle time = 28 11:38:48 Заранее, как говорится. 
nick = swizard time = 28 11:40:3 ща попробую изобразить тогда 
nick = turtle time = 28 12:6:18 В общем, научились боты вылазить из тупика. 
nick = turtle time = 28 12:6:33 Правда, как-то странно ходят. 
nick = swizard time = 28 12:6:40 отлично, а я щас минут через 15 уже должен волну доделать 
nick = turtle time = 28 12:6:50 Хотя, может, это потому, что я назад пытаюсь ходить. 
nick = turtle time = 28 12:7:0 Сейчас посмотрю влезаю ли я. в память. 
nick = turtle time = 28 12:10:45 Что-то я тупанул. Гостов всё равно пришлось делать, нужно было минимальный транслятор для него налабать. 
nick = sectoid time = 28 12:14:27 утро пришло 
nick = swizard time = 28 12:15:19 привет 
nick = sectoid time = 28 12:16:11 с компилером CL у нас та же беда, как я понимаю? 
nick = turtle time = 28 12:16:46 Позднее такое утро. :) 
nick = sectoid time = 28 12:17:6 у меня 11:16:00 
nick = sectoid time = 28 12:17:16 я уже успел в посольство съездить 
nick = swizard time = 28 12:17:16 да, но я локализовал проблему — не работает labels :) 
nick = swizard time = 28 12:17:28 если на letrec перееписать всё ок 
nick = sectoid time = 28 12:17:37 о как 
nick = sectoid time = 28 12:17:43 счас починим тогда) 
nick = sectoid time = 28 12:17:55 аще странно, ибо labels в letrec же и транслируются 
nick = sectoid time = 28 12:18:10 (defmacro labels (bindings &amp;rest body)<br />  `(letrec ,(iter (for (name lambda-list &amp;rest fn-body) in bindings)<br />                  (collect `(,name (lambda ,lambda-list ,@fn-body))))<br />     ,@body)) 
nick = sectoid time = 28 12:18:24 очень странно 
nick = sectoid time = 28 12:18:29 лан, счас заценим) 
nick = swizard time = 28 12:19:33 ну я просто в одном месте в ilisp забыл labels на letrec поменять и всё сломалось 
nick = swizard time = 28 12:19:41 а потом поменял и починилось 
nick = sectoid time = 28 12:20:18 интересно 
nick = sectoid time = 28 12:20:26 счас попробую воспроизвести и починить 
nick = turtle time = 28 12:20:30 В общем, одну реализацию госта сделал. 
nick = turtle time = 28 12:20:33 Который гоняется. 
nick = sectoid time = 28 12:20:34 поздно конечно, но лучше хоть счас 
nick = turtle time = 28 12:20:52 Можно, конечно, сделать бота на опережение. 
nick = turtle time = 28 12:20:58 Как оригинальном пакмане. 
nick = turtle time = 28 12:21:16 Идти на клетку 2-3перед пакманом. 
nick = turtle time = 28 12:32:14 В общем я по плану сейчас до часу поделаю бота, потом после часа пишу сборку архива для сабмита. Потом опять бота. 
nick = sectoid time = 28 12:34:50 а я починил баг... 
nick = sectoid time = 28 12:35:3 в компилере CL 
nick = swizard time = 28 12:37:27 класс 
nick = swizard time = 28 12:37:34 а я вроде запрограммировал волну 
nick = swizard time = 28 12:37:47 ща попробуем тогда что-нибудь изобразить 
nick = sectoid time = 28 12:37:53 тока у меня симулякр в хроме падает( 
nick = turtle time = 28 12:38:22 У меня в фф не падает. 
nick = sectoid time = 28 12:38:37 свиз, проверишь CL'ный AI? 
nick = sectoid time = 28 12:38:46 labels теперь компилируется правильно 
nick = sectoid time = 28 12:39:16 и насчет ST: форма setq у нас есть и работает 
nick = sectoid time = 28 12:39:22 так что мона пользоваться) 
nick = swizard time = 28 12:39:23 ща, скоро проверю 
nick = swizard time = 28 12:40:8 seta не подойдёт, нужен (setf (car cell) …) :( 
nick = sectoid time = 28 12:40:32 а это невозможно 
nick = sectoid time = 28 12:40:45 у нас ST может только меня значение того, что в env 
nick = sectoid time = 28 12:40:56 т.е. только переменной 
nick = sectoid time = 28 12:41:5 place увы не канает 
nick = swizard time = 28 12:46:53 так блин 
nick = swizard time = 28 12:47:1 а как мне быть 
nick = swizard time = 28 12:47:11 вот у меня есть ветка, в которой я сделал волну 
nick = swizard time = 28 12:47:30 и я хочу в эту ветку вмержить мастер с твоими изменениями 
nick = swizard time = 28 12:47:35 это как вкрадце? :) 
nick = swizard time = 28 12:48:49 ох лол там 20400 скор :) 
nick = sectoid time = 28 12:49:41 кто-то плотно взялся за хант на гостов 
nick = sectoid time = 28 12:49:57 коммитишь все незакоммиченое 
nick = sectoid time = 28 12:50:1 git status 
nick = sectoid time = 28 12:50:7 проверяешь что ты на своей ветке 
nick = swizard time = 28 12:50:13 ага 
nick = sectoid time = 28 12:50:22 git fetch<br />git merge --no-ff origin/master 
nick = sectoid time = 28 12:50:26 радуешься) 
nick = swizard time = 28 12:52:59 ок получилось! 
nick = swizard time = 28 12:53:15 только блин виснит эмулятор собака 
nick = swizard time = 28 12:54:43 так, походу с волной облом-таки 
nick = swizard time = 28 12:54:56 по циклам не укладываемся 
nick = swizard time = 28 12:55:21 жалко, в эмуляторе хорошо бегает :( 
nick = sectoid time = 28 12:56:50 в эмуляторе эмулятора?) 
nick = swizard time = 28 12:57:8 ну да, на локальном симуляторе 
nick = sectoid time = 28 12:57:13 я понял) 
nick = swizard time = 28 12:57:43 чёрт а  
nick = turtle time = 28 12:58:16 И что делать то? 
nick = swizard time = 28 12:58:25 походу волна ваще не вариант, я не знаю как на однонаправленных списках эффективно матрицу сделать 
nick = turtle time = 28 12:58:39 А с ST тоже не выйдет? 
nick = swizard time = 28 12:59:7 ну а как, он же биндинг правит, а не содержимое ячейки 
nick = swizard time = 28 12:59:16 грубо говоря ST — это setq 
nick = swizard time = 28 12:59:26 а нам нужен setcar и setcdr 
nick = swizard time = 28 12:59:33 как там они зазываются 
nick = turtle time = 28 13:0:10 Ну да. 
nick = turtle time = 28 13:0:15 Проверил сейчас. 
nick = swizard time = 28 13:0:37 ладно, я пойду перекушу быстро тогда и дальше буду форсированно править старый вариант 
nick = swizard time = 28 13:0:49 с CL транстлятором, конечно, существенно лучше пошло дело 
nick = swizard time = 28 13:11:17 а финальных сабмишнов можно много делать или только один? 
nick = turtle time = 28 13:11:26 По идее, много. 
nick = swizard time = 28 13:11:58 может, тогда на всякий случай засабмитить текущее решение из мастера, пока всё не поломали? :) 
nick = turtle time = 28 13:12:18 Так в репе же есть. 
nick = turtle time = 28 13:12:29 Если что, через час засабмитим. 
nick = turtle time = 28 13:12:32 Ты таг сделай тогда. 
nick = turtle time = 28 13:12:38 Типа, рабочее решение. :) 
nick = swizard time = 28 13:13:3 ок, а с гоустами мы как в итоге решили? 
nick = turtle time = 28 13:14:7 Пока не решили. Есть deadline-pursue, там вроде госты показывают зачатки интеллекта. 
nick = turtle time = 28 13:14:25 Есть waver - ничего не делает, но грузит проц. :) 
nick = turtle time = 28 13:14:48 Есть грепзовский гост, которые тоже преследует. 
nick = turtle time = 28 13:15:0 Но он в тупиках застревает. 
nick = swizard time = 28 13:19:42 а у нас вообще 4 гоуста может быть, мы их одинаковыми хотим сделать или разными? 
nick = turtle time = 28 13:20:14 Ну если одинаковыми, они одной толпой ломятся. 
nick = swizard time = 28 13:22:45 блин с транслятором из CL беда какая-то всё же 
nick = swizard time = 28 13:22:48 походу 
nick = sectoid time = 28 13:23:24 да? блин( 
nick = sectoid time = 28 13:23:29 а какая? 
nick = swizard time = 28 13:24:40 код генерируется разный из ilisp и cl  
nick = swizard time = 28 13:24:53 в смысле первый работает, а второй как-то нет 
nick = swizard time = 28 13:25:6 ну тоесть работает, но тупит и застревает 
nick = sectoid time = 28 13:25:15 йех 
nick = swizard time = 28 13:25:17 и в другую сторону сначала уходит 
nick = sectoid time = 28 13:25:36 надо искать минимальный пример... 
nick = swizard time = 28 13:25:38 походу где-то то в AND/OR/&gt;=/&lt; косяк 
nick = sectoid time = 28 13:25:41 а 
nick = sectoid time = 28 13:25:50 мона глянуть стандартную либу 
nick = swizard time = 28 13:26:54 хм я просто не знаю успеем ли мы щас за оставшиеся 3 часа пофиксить все баги там 
nick = swizard time = 28 13:27:34 если хочешь посмотреть, то в мастере сейчас лежат ai/ai-cl.lisp и ilisp/examples/power-pill-hunter.lisp 
nick = swizard time = 28 13:27:47 они оба компилируются build-ai, но работают по-разному 
nick = sectoid time = 28 13:28:2 может там not кривой 
nick = sectoid time = 28 13:28:9 счас попробую 
nick = swizard time = 28 13:29:38 ты просто на дифф этих файлов тогда глянь, он вполне читаемый 
nick = sectoid time = 28 13:29:54 сча гляну 
nick = swizard time = 28 13:30:54 во и кстати эта 
nick = swizard time = 28 13:31:6 волну-то я не переделывал на ilisp 
nick = swizard time = 28 13:31:15 странслировал из CL и проверил 
nick = swizard time = 28 13:31:23 может, она и рабочая там на самом деле 
nick = turtle time = 28 13:32:4 Хм... 
nick = sectoid time = 28 13:32:8 счас попробую починить мастер 
nick = turtle time = 28 13:32:22 Надо бы попробовать проверить. 
nick = swizard time = 28 13:32:26 а зачем ты там делаешь (defmacro &lt; (a b)<br />  `(not (&gt;= ,a ,b)))<br />кстати 
nick = swizard time = 28 13:32:41 можно же просто аргументы поменять местами? 
nick = sectoid time = 28 13:34:42 потому, что я слоу) 
nick = sectoid time = 28 13:35:18 хм 
nick = sectoid time = 28 13:35:35 вроде счас после фиксов cl-ai и power-pill-hunter работают одинаково 
nick = swizard time = 28 13:36:15 ща гляну 
nick = sectoid time = 28 13:36:22 залил 
nick = swizard time = 28 13:38:55 да, блин, у меня по-разному 
nick = swizard time = 28 13:39:11 хотя вариант cl перестал застревать и чёто бегает тоже 
nick = swizard time = 28 13:39:20 но не так, как ilisp :) 
nick = swizard time = 28 13:39:45 во у меня с волной идея появилась как недорого матрицу обновлять! 
nick = swizard time = 28 13:40:14 ща попробую лайфхак с замыканиями, как мы в 2012 году с картой делали 
nick = turtle time = 28 13:40:59 А, ну это да. Клёво тогда сделали. 
nick = sectoid time = 28 13:41:36 а у тебя ilisp и ai-cl точно одинаковые? 
nick = swizard time = 28 13:42:35 ну вроде бы да 
nick = sectoid time = 28 13:42:40 алгоритмически 
nick = sectoid time = 28 13:42:49 никаких там лимитов и прочего нет? 
nick = sectoid time = 28 13:44:10 аааа 
nick = sectoid time = 28 13:44:12 АААА 
nick = sectoid time = 28 13:44:36 OR починил 
nick = sectoid time = 28 13:44:47 попробуй 
nick = swizard time = 28 13:45:44 ща 
nick = swizard time = 28 13:47:4 не опять не так 
nick = sectoid time = 28 13:47:13 да что ж такое 
nick = swizard time = 28 13:47:27 прямо берёт и с самого старта в другую сторону поехал 
nick = swizard time = 28 13:48:13 слушай, посмотри повнимательней дифф, не исключено, что это я где-то что-то неэквивалентно заменил при ручной трансляции на ilisp 
nick = sectoid time = 28 13:49:13 хм... 
nick = sectoid time = 28 13:57:14 -  (labels ((plan-route-rec (source rev-path limit)<br />-             (if (or (= limit 0))  <br /><br />хм? 
nick = sectoid time = 28 13:57:25 or из одного? так и задумано? 
nick = sectoid time = 28 13:58:27 лан, это не роялит 
nick = swizard time = 28 13:58:39 не, это артефакт 
nick = swizard time = 28 13:58:45 там было ещё условие типа 
nick = swizard time = 28 13:58:49 забыл убрать ор 
nick = sectoid time = 28 14:2:13 угу 
nick = sectoid time = 28 14:2:20 нет ошибок( 
nick = sectoid time = 28 14:2:27 вернее не могу найти где.. 
nick = sectoid time = 28 14:2:57 аааа 
nick = sectoid time = 28 14:2:59 нашел! 
nick = swizard time = 28 14:3:2 но у тебя в эмуляторе бот себя тоже по-разному ведёт? 
nick = sectoid time = 28 14:3:2 нашеееееел! 
nick = sectoid time = 28 14:3:17 исходное<br /><br />                  (if (or (integerp nearest-object)<br />                          (&lt; current-sq-dist nearest-sq-dist))<br /> 
nick = sectoid time = 28 14:3:57 ты транслировал в :<br />                  (if (integerp nearest-object)<br />                      ...<br />                      (if (&gt; nearest-sq-dist current-sq-dist)<br /> 
nick = sectoid time = 28 14:4:11 (&lt; current-sq-dist nearest-sq-dist) != (&gt; nearest-sq-dist current-sq-dist) 
nick = sectoid time = 28 14:4:34 (&lt; current-sq-dist nearest-sq-dist) == (&gt;= nearest-sq-dist current-sq-dist) 
nick = sectoid time = 28 14:4:46 потому они наверное и по-разному ходят) 
nick = sectoid time = 28 14:5:47 swizard:  
nick = swizard time = 28 14:6:3 типа равенство забыл? 
nick = sectoid time = 28 14:6:16 ну, тебе виднее алгоритм 
nick = sectoid time = 28 14:6:23 ты или забыл в исходном AI равенство 
nick = sectoid time = 28 14:6:29 либо забыл его при трансляции 
nick = swizard time = 28 14:6:40 понятно, спасибо :) 
nick = swizard time = 28 14:6:53 ща я чуть волну помучаю и вернусь тогда к мастеру 
nick = sectoid time = 28 14:6:54 есть еще аналогичная огшибка 
nick = sectoid time = 28 14:6:57 счас покажу 
nick = swizard time = 28 14:7:2 давай 
nick = sectoid time = 28 14:7:8 а не 
nick = sectoid time = 28 14:7:11 там все правильно 
nick = sectoid time = 28 14:7:17 в choose dir все правильно 
nick = sectoid time = 28 14:7:26  (defun choose-dir (source target)<br />-  (declare (optimize (debug 3)))<br />   (let ((xs (car source)) (ys (cdr source)) (xt (car target)) (yt (cdr target)))<br />     (if (= ys yt)<br />-        (if (&lt; xs xt) 1 3)<br />-        (if (&lt; ys yt) 2 0))))<br />+        (if (&gt;= xt xs) 1 3)<br />+        (if (&gt;= yt ys) 2 0))))<br /> 
nick = sectoid time = 28 14:7:34 вот тут ты и операцию поменял 
nick = sectoid time = 28 14:8:5 счас поменяю знак в ai-cl и проверю направление 
nick = sectoid time = 28 14:8:28 да) 
nick = sectoid time = 28 14:8:36 побежал в нужную сторону) 
nick = swizard time = 28 14:8:45 отлично, спасибо :) 
nick = swizard time = 28 14:9:3 правильно ли я понимаю, что теперь можно забыть про ilisp? :) 
nick = sectoid time = 28 14:9:5 патч на ai-cl приводящий его в соответствие с power-hunter 
nick = sectoid time = 28 14:9:8 	Modified   ai/ai-cl.lisp<br />diff --git a/ai/ai-cl.lisp b/ai/ai-cl.lisp<br />index 376b442..323ce4f 100644<br />--- a/ai/ai-cl.lisp<br />+++ b/ai/ai-cl.lisp<br />@@ -66,7 +66,7 @@<br />                       (rest-objects (cddr acc))<br />                       (current-sq-dist (funcall dist my-x my-y (car object) (cdr object))))<br />                   (if (or (integerp nearest-object)<br />-                          (&lt; current-sq-dist nearest-sq-dist))<br />+                          (&lt;= current-sq-dist nearest-sq-dist))<br />                       (cons object<br />                             (cons current-sq-dist<br />                                   (if (integerp nearest-object)<br /> 
nick = sectoid time = 28 14:9:14 я его не коммитил 
nick = sectoid time = 28 14:9:25 т.к. не знаю насколько это верно с т.з. алгоритма 
nick = sectoid time = 28 14:9:29 посмотри сам) 
nick = sectoid time = 28 14:9:40 если он верный - приложи-закоммить 
nick = sectoid time = 28 14:10:13 а если нет - то наш IL-вариант ходил в неправильную сторону 
nick = sectoid time = 28 14:10:26 [13:09:03] &lt;swizard&gt; правильно ли я понимаю, что теперь можно забыть про ilisp? :)<br /><br />да, тока реши с направлением) 
nick = sectoid time = 28 14:12:2 блин, он циклится там местами 
nick = sectoid time = 28 14:12:6 так должно быть? 
nick = swizard time = 28 14:12:23 да, если его гоусты загонят :( 
nick = sectoid time = 28 14:13:0 хотя карту проходит с 8100 очками 
nick = sectoid time = 28 14:13:4 стандартную 
nick = sectoid time = 28 14:22:17 осталось 1,5 часа 
nick = sectoid time = 28 14:22:30 борюсь зубами со сном) 
nick = swizard time = 28 14:23:11 ща мы ещё попробует волну разок минут через 15 
nick = sectoid time = 28 14:24:15 я тут пока) 
nick = turtle time = 28 14:26:27 Дописал второго бота. 
nick = turtle time = 28 14:26:36 sectoid: спички вставь. :) 
nick = swizard time = 28 14:26:41 а я вроде сумел волну оптимизировать 
nick = swizard time = 28 14:26:44 ща проверим 
nick = turtle time = 28 14:27:0 А вообще, если честно, чтобы восполнить недостаток глюкозы, надо её съесть. Попробуй сладкий чай. 
nick = sectoid time = 28 14:27:14 turtle: уже бревна в ход пошли 
nick = swizard time = 28 14:27:49 хм 
nick = turtle time = 28 14:28:41 В общем, втоой бот немного хитрее. 
nick = swizard time = 28 14:29:46 блин почему-то волна опять не проходит по лимиту 
nick = swizard time = 28 14:31:40 странно 
nick = swizard time = 28 14:34:26 короче он укладывается если ему длину волны ограничить 8 клеток 
nick = swizard time = 28 14:34:42 но тогда он впадает в ступор, если в радиусе 8 клеток нет объектов 
nick = turtle time = 28 14:34:43 Ну. 
nick = turtle time = 28 14:34:56 Пусть тогда к границам подходит. 
nick = turtle time = 28 14:35:35 Было бы время, можно было бы чекпоинты сделать, типа, откуда сканировал. 
nick = turtle time = 28 14:35:40 И по ним пробегаться. 
nick = sectoid time = 28 14:35:48 а мы можем если нифига нет в радиусе 8 - откатываться на старый алгоритм? 
nick = swizard time = 28 14:36:23 можно попробовать, хотя это достаточно муторно спрограммировать :) 
nick = swizard time = 28 14:48:28 лол сработало похоже 
nick = swizard time = 28 14:48:30 самый ад теперь в том, что он реально гоняется за синими и жрёт их 
nick = swizard time = 28 14:48:49 и фрукты жрёт 
nick = turtle time = 28 14:49:13 Что сработало? Гибридный алгоритм? 
nick = swizard time = 28 14:49:17 да 
nick = swizard time = 28 14:49:31 но карту теперь пройти не может =) 
nick = swizard time = 28 14:49:48 ну что я помержу в мастер гибридную волну? 
nick = turtle time = 28 14:50:25 Ну если будем публиковать, то да, наверное. :) 
nick = swizard time = 28 14:50:29 блин а как в мастер мержить 
nick = turtle time = 28 14:50:45 Ты чем пользуешься то в качестве СКВ? 
nick = swizard time = 28 14:51:9 ну щас гитом :) 
nick = sectoid time = 28 14:51:18 git checkout master 
nick = sectoid time = 28 14:51:25 git merge &lt;branch-name&gt; 
nick = sectoid time = 28 14:51:26 ;) 
nick = turtle time = 28 14:51:29 А вообще? 
nick = turtle time = 28 14:51:38 ТОлько бранч закоммитить надол, наверное. 
nick = sectoid time = 28 14:52:7 ну ессно при чистой копии 
nick = swizard time = 28 14:52:35 done  
nick = swizard time = 28 14:52:39 зацените бота 
nick = swizard time = 28 14:52:48 короче походу надо отломать ему приоритет power pills 
nick = swizard time = 28 14:52:56 пусть жрёт что есть 
nick = turtle time = 28 14:55:28 ОН так в экзамплах и будет? 
nick = swizard time = 28 14:55:52 ну давайте щас уже не перекладывать 
nick = swizard time = 28 14:55:56 час остался 
nick = sectoid time = 28 14:56:0 присоединяюсь к вопросу о том, какую VCS swizard юзает в повседневной жизни 
nick = turtle time = 28 14:56:27 Сожрал мой бот твоего. 
nick = swizard time = 28 14:56:37 по работе svn, у себя гит 
nick = turtle time = 28 14:56:47 А, ну у себя мержиться не надо. :) 
nick = swizard time = 28 14:56:50 но я почти никогда не бранчуюсь в своих проектах просто :) 
nick = swizard time = 28 14:56:51 ну да 
nick = turtle time = 28 14:57:6 Но твой бот и моих сожрал, конечно. :) Не успели убежать. 
nick = swizard time = 28 14:57:21 =) 
nick = sectoid time = 28 14:57:22 подлагивает только) 
nick = sectoid time = 28 14:57:26 а в целом - уняняня) 
nick = turtle time = 28 14:57:35 Издержки яваскрипта. 
nick = swizard time = 28 14:57:39 волна накладная блин 
nick = turtle time = 28 14:58:12 Ха, сожранные боты застряли. :( 
nick = swizard time = 28 15:1:34 блин ребята это победа 
nick = swizard time = 28 15:1:46 15200 на стандартной карте 
nick = swizard time = 28 15:1:50 ща закоммичу 
nick = sectoid time = 28 15:2:13 гут) 
nick = sectoid time = 28 15:2:17 коммить и заливай) 
nick = sectoid time = 28 15:2:25 swizard - герой контеста) 
nick = swizard time = 28 15:2:49 ушло 
nick = swizard time = 28 15:2:56 2 фрукта сожрал, гоустов нажрал 
nick = swizard time = 28 15:4:0 блин но на скорборте ихние гоусты сжирают меня :( 
nick = swizard time = 28 15:4:2 Status: Game over! Lose. You scored 1490 after 33001 game ticks. 
nick = swizard time = 28 15:4:41 ща будем экспериментировать, 40 минут ещё 
nick = swizard time = 28 15:7:4 2920 уже 
nick = turtle time = 28 15:8:27 Поправил ботов. 
nick = turtle time = 28 15:8:51 Ты попробуй с моими гостами. 
nick = turtle time = 28 15:8:57 deadend-predic.ghc 
nick = swizard time = 28 15:9:25 3400 уже 
nick = swizard time = 28 15:9:55 с гоустами ок 
nick = turtle time = 28 15:10:25 Так, я пока собиралку напишу. 
nick = turtle time = 28 15:10:49 Будем power-pill-hunter сабмитить? 
nick = swizard time = 28 15:11:26 ага… тока погоди пока, дай мне ещё минут 20 поэкспериментировать  
nick = swizard time = 28 15:11:31 блин дедлайн жёсткий 
nick = swizard time = 28 15:11:41 гоуст не грузит чёто: Error: ghost1.ghc:2: junk instruction: %def _d_up,0 
nick = turtle time = 28 15:12:17 Ты из ghost-build возьми. 
nick = turtle time = 28 15:12:20 Это исходники. 
nick = swizard time = 28 15:12:45 а ок 
nick = swizard time = 28 15:13:16 с твоими гоустами проще — мой пакман их жрёт :) 
nick = turtle time = 28 15:13:26 Кстати, каких гостов будем сабмитить? 
nick = turtle time = 28 15:13:38 Не знаю, мои госты твоего пакмана склевали. :) 
nick = swizard time = 28 15:13:39 хотя проигрывает, конечно 
nick = swizard time = 28 15:13:42 в итоге 
nick = swizard time = 28 15:13:44 да :) 
nick = swizard time = 28 15:14:2 твоих и будем наверно 
nick = turtle time = 28 15:14:6 Ты predict версию взял или pursue? 
nick = turtle time = 28 15:14:15 Ну я к тому, что там есть две версии pursue и predict. 
nick = swizard time = 28 15:14:19 deadend-predic 
nick = turtle time = 28 15:14:31 Преследование ведёт по цели Точно. 
nick = turtle time = 28 15:14:53 Предикт делает предположение на 4 клетки вперёд. 
nick = turtle time = 28 15:15:12 И когда расстояние между гостом и пакманом меньше 4, переключается на преследование. 
nick = turtle time = 28 15:15:29 Надо попробовать, кстати. 
nick = turtle time = 28 15:15:51 Дв госта надо попробовать. 
nick = turtle time = 28 15:16:59 В теории, если один преследует, а второй предвосхищает движение, они должны окружить. 
nick = turtle time = 28 15:17:38 Ну, в целом, почти так и происходит. 
nick = swizard time = 28 15:17:48 круто давай два тогда :) 
nick = turtle time = 28 15:17:54 Они как-то грамотно пилюлю заблокировали. 
nick = turtle time = 28 15:17:58 Даже старшно как-то. :) 
nick = swizard time = 28 15:18:10 блин зараза по точкам пакман медленней ходит 
nick = swizard time = 28 15:18:15 гоусты догоняют его 
nick = turtle time = 28 15:18:17 Да. 
nick = turtle time = 28 15:19:11 Надо было транслятор писать, успели бы, может, ещё и кемпера нарисовать, который пилюли пасёт. 6) 
nick = sectoid time = 28 15:19:36 гы 
nick = sectoid time = 28 15:19:44 клёвая мысля) 
nick = turtle time = 28 15:20:1 Только уже не успеваем. 
nick = turtle time = 28 15:20:14 Короче, вроде эти два типа ботов вместе хорошо работают. 
nick = turtle time = 28 15:20:27 Во всяком случае, случаев смертей меньше. 
nick = swizard time = 28 15:20:27 ща последний эксперимент попробую — если гоуст угрожает, то всё бросить и бежать к powerpill 
nick = turtle time = 28 15:21:14 &quot;lambdaman program (step function) faulted CycleLimit&quot; - это просчитать не успел? 
nick = swizard time = 28 15:21:47 да :( 
nick = turtle time = 28 15:26:9 Может, размер поля, где он волновой алгоритм делает, уменьшить? 
nick = swizard time = 28 15:26:47 ща попробуем 
nick = swizard time = 28 15:27:37 но это наверно не он 
nick = swizard time = 28 15:27:40 а greedy 
nick = swizard time = 28 15:27:47 он бывает зацикливается 
nick = turtle time = 28 15:28:55 Хм. 
nick = turtle time = 28 15:34:50 Меньше получаса осталось. 
nick = turtle time = 28 15:35:4 Минут через 10-15 задеплоить бы самбишин. 
nick = swizard time = 28 15:35:19 сделаем, я тут последний баг пытаюсь поправить 
nick = swizard time = 28 15:35:27 с тупняком пакмана после смерти 
nick = turtle time = 28 15:37:34 Как думаете, имеет ли смысл вставить в конец тела ботов зацикливание и нагружение проца? 
nick = swizard time = 28 15:37:59 не знаю, а что это может дать? 
nick = swizard time = 28 15:38:4 сломать эмуляцию в ботах? 
nick = turtle time = 28 15:38:36 Да. :) 
nick = turtle time = 28 15:38:49 Либо забрать циклы CPU. 
nick = grepz time = 28 15:39:8 Всем привет 
nick = turtle time = 28 15:39:13 Ты вовремя. :) 
nick = grepz time = 28 15:39:33 едва успел, только сейчас отпустили 
nick = grepz time = 28 15:40:5 turtle, есть что-то годное в плане гостов? я тут между делом ещё один вариант написал, но отлдить не успел, застревают в комнатах иногда 
nick = turtle time = 28 15:40:28 Есть довольно хитрые госты. Смотри deadend-pursue и deadend-predict. 
nick = grepz time = 28 15:40:32 ок 
nick = turtle time = 28 15:40:35 Мы их в паре решили засабмитить. 
nick = grepz time = 28 15:41:0 1 гоняется, другой обходит? 
nick = turtle time = 28 15:41:7 Правда, эти госты на больших картах плохо будут работать, наверное. 
nick = turtle time = 28 15:41:40 Да, типа того. Только он тоже гоняется, на самом деле, но за целью, которая перед пакманом. 
nick = turtle time = 28 15:41:58 В репе лежит, можешь на эмуляторе погонять. 
nick = grepz time = 28 15:42:9 сейчас попробую 
nick = swizard time = 28 15:42:51 короче блин сломан «&lt;« похоже в трансляторе 
nick = sectoid time = 28 15:43:20 Щ_щ 
nick = sectoid time = 28 15:43:31 (defmacro &lt; (a b)<br />  `(&gt;= ,b ,a)) 
nick = sectoid time = 28 15:43:52    ((&gt;= ?form-a ?form-b) (translate-binop  translator :cgte ?form-a ?form-b))<br /> 
nick = swizard time = 28 15:44:37 &gt; должно быть 
nick = sectoid time = 28 15:44:57 почему &gt; ? 
nick = sectoid time = 28 15:45:2 а = ? 
nick = swizard time = 28 15:45:20 (&lt; 3 3) 
nick = swizard time = 28 15:45:23 получаешь true 
nick = sectoid time = 28 15:45:33 ммм 
nick = sectoid time = 28 15:45:45 да 
nick = sectoid time = 28 15:45:49 все 
nick = sectoid time = 28 15:45:54 точно пора отоспаццо 
nick = grepz time = 28 15:45:55 deadend-predict хорошо отрабатывают 
nick = sectoid time = 28 15:46:5 заменишь макры? 
nick = swizard time = 28 15:46:10 да 
nick = turtle time = 28 15:46:29 grepz: проверил в связке с pursue - смертей стало меньше от нашего пакмана. 
nick = grepz time = 28 15:47:5 ну круто, подпортят кровь оппонентам 
nick = turtle time = 28 15:47:23 Ну хз. :) Там такие оппоненты, что палец им в рот не клади. :) 
nick = grepz time = 28 15:47:35 да, score board видел 
nick = turtle time = 28 15:47:37 Плюс он память использует для хранения данных о тупиках. На больших картах будет ой. 
nick = grepz time = 28 15:48:13 я вот думаю, что если кто-то заимплементил взаимодействие гостов, то это будет вообще кабзец 
nick = turtle time = 28 15:48:43 А им не через что, только через дирекшоны и координаты. 
nick = turtle time = 28 15:48:51 А с учётом тех ограничений - это бздец. 
nick = turtle time = 28 15:49:1 Можно, правда, действие делить на шаги разные. 
nick = grepz time = 28 15:49:5 мы же можем получить положение других гостов 
nick = turtle time = 28 15:49:11 Т.е. часть кода выполниалсь на одном шаге, потом на другом. 
nick = grepz time = 28 15:49:26 исходя из этого строить простой алгоритм взаимодействия 
nick = turtle time = 28 15:49:41 Ну, в теории, да. 
nick = turtle time = 28 15:49:56 На практике же я не знаю как в этот мизер вписаться. 
nick = swizard time = 28 15:49:58 так ну что пора сабмишн делать 
nick = turtle time = 28 15:50:6 У тебя готов? 
nick = grepz time = 28 15:50:6 просто уменьшать веса путям, где уже есть другие госты 
nick = swizard time = 28 15:50:23 опаа 
nick = turtle time = 28 15:50:26 Ты положил и скомпиленную версию? 
nick = swizard time = 28 15:50:27 ща сек коммит улетит 
nick = swizard time = 28 15:50:52 ушло 
nick = turtle time = 28 15:51:0 Можно сабмитить? 
nick = swizard time = 28 15:51:9 да 
nick = sectoid time = 28 15:51:10 да 
nick = swizard time = 28 15:51:13 зацените ка 
nick = swizard time = 28 15:51:14 Status: Game over! Win! You scored 10000 after 59001 game ticks. 
nick = turtle time = 28 15:51:17 grepz: для анализа путей надо бы памят и циклов cpu побольше. 
nick = swizard time = 28 15:51:17 это стандарт =) 
nick = sectoid time = 28 15:51:21 грац ) 
nick = grepz time = 28 15:51:26 1	20400	TCB	Team Cannon Brawl<br />2	20400	TCB	T<br />3	20400	UNG	UnaGi 
nick = grepz time = 28 15:51:41 видать возможный максимум 
nick = sectoid time = 28 15:51:50 прикольно 
nick = sectoid time = 28 15:51:59 видимо поднаторели в поедании гхостов 
nick = sectoid time = 28 15:52:8 кстати, сабмитим и оргам, и на борду, так? 
nick = swizard time = 28 15:52:20 да 
nick = swizard time = 28 15:52:31 на proton-pack правда хуже сильно результат теперь 
nick = swizard time = 28 15:52:48 было 6700 стало 2900 но тоже вин 
nick = grepz time = 28 15:53:9 на proton pack кто-то набрал 90240 очков с утра, так и не был побит результат 
nick = swizard time = 28 15:53:11 видимо это из-за того, что карта маленькая, а я его научил сильно бояться гоустов 
nick = swizard time = 28 15:53:24 это на ghostbusters 
nick = grepz time = 28 15:53:31 ой, точно 
nick = swizard time = 28 15:53:36 7 минут бтв 
nick = swizard time = 28 15:53:44 Азамат, ты сабмитишь солюшн? 
nick = sectoid time = 28 15:53:46 эх, коль не тупил бы я с транслятором так - можно было бы значительно больше мозгов напилить боту 
nick = turtle time = 28 15:53:47 Ушёл сабмишин. 
nick = swizard time = 28 15:53:51 отлично 
nick = grepz time = 28 15:54:25 японцы(или отаку) захватили скорборду :) 
nick = swizard time = 28 15:54:29 да, жалко контест кончился в то время, как самое интересное пошло :) 
nick = turtle time = 28 15:54:34 :) 
nick = turtle time = 28 15:54:38 Ну что поделаешь. 
nick = turtle time = 28 15:54:46 К следующему будем лучше готовы. 
nick = turtle time = 28 15:54:52 Давайте подводить итоги. 
nick = turtle time = 28 15:54:57 Очень круто было с вами поучаствовать. 
nick = sectoid time = 28 15:55:4 было очень круто, да) 
nick = swizard time = 28 15:55:10 погодите, а на ghostbusters AAA Skobochka — это кто? 
nick = sectoid time = 28 15:55:22 видимо кривой наш сабмит 
nick = swizard time = 28 15:55:24 да было очень весело :) 
nick = grepz time = 28 15:55:28 это наш 
nick = turtle time = 28 15:55:31 Со swizard мы уже участвовали, но 4 человека веселее и полегче немного. 
nick = swizard time = 28 15:55:42 кривой да не кривой, там 5 место между прочим 
nick = swizard time = 28 15:55:46 если что 
nick = sectoid time = 28 15:55:47 я впервые играю в толковой комманде 
nick = sectoid time = 28 15:55:55 это таки совсем другой фан. очень нравится) 
nick = turtle time = 28 15:56:23 ПОэтому если не против, следующий контест неплохо было бы собраться в этом же составе. 
nick = grepz time = 28 15:56:27 а я хочу извиниться, что нормально поучавствовать не удалось, у меня весь вик енд на работе залипоны были :( 
nick = sectoid time = 28 15:56:28 я за =) 
nick = sectoid time = 28 15:56:45 у меня тоже были &quot;провалы&quot;( 
nick = sectoid time = 28 15:56:58 на след. контест тупо возьму отпуск и выгоню нахер домочадцев 
nick = sectoid time = 28 15:57:8 или понаеду в Мск =))) 
nick = grepz time = 28 15:57:35 да, пожалуй я также поступлю, отпуск и никакой работы, плюс жену и дитё к бабушке на огороды сошлю 
nick = swizard time = 28 15:57:37 я всех за полгода предупредил, что на этих выходных меня не трогать :) 
nick = turtle time = 28 15:57:38 В Мск только swizard, если не ошибаюсь. 
nick = sectoid time = 28 15:57:45 ну не суть =) 
nick = turtle time = 28 15:57:46 Я тоже где-то за полгода. :) 
nick = sectoid time = 28 15:57:49 я тоже предупреждал 
nick = sectoid time = 28 15:57:55 но толку как обычно 0 
nick = sectoid time = 28 15:58:6 надо физически устранять контакт 
nick = turtle time = 28 15:58:18 Уходить в пещеры на 3 сутки. :) 
nick = sectoid time = 28 15:58:29 в пещерах нет оптики и пепси 
nick = sectoid time = 28 15:58:32 и пуэра тоже нет( 
nick = swizard time = 28 15:58:38 ну что ж, надо признать, что большой командой играть существенно интересней и динамичней :) 
nick = turtle time = 28 15:58:41 За год подвести оптику и пепси.  
nick = grepz time = 28 15:58:42 а у меня армия эмбеддед девайсов, которых невозможно уломать не беспокоить меня :) 
nick = swizard time = 28 15:58:43 соло я бы ничерта не успел 
nick = turtle time = 28 15:58:50 Да, большая команда лучше. 
nick = sectoid time = 28 15:59:8 а еще офигенней - большая команда, где все могут в лисп 
nick = turtle time = 28 15:59:13 Да и вдвоём бы вспотели и застряли на контексте переменных. :) 
nick = sectoid time = 28 15:59:20 а то раньше играл на солянке языков) 
nick = swizard time = 28 15:59:26 это точно 
nick = turtle time = 28 15:59:47 sectoid просто мастер лябда калькулюса. Надо, кстати, тоже подтянуть себя в этом. 
nick = swizard time = 28 15:59:57 на самом деле суббота реально провальная была, если бы не озарение сектоида под вечер, то непонятно, сколько бы ещё провозились  
nick = sectoid time = 28 16:0:10 та ну) куда там местер. просто с jtootf в свое время на ту тему много говорили 
nick = swizard time = 28 16:0:17 а так реально с середины воскресенья получилось уже ai нормально писать 
nick = sectoid time = 28 16:0:39 сектоид потратил много драгоценного времени на ненужное обобщение и попытки сделать транслятор в CL 
nick = sectoid time = 28 16:0:51 вместо того, чтобы допетрить сразу транслировать подмножество CL 
nick = sectoid time = 28 16:1:8 а вот тесты помогали очень (пока не отвалились) 
nick = turtle time = 28 16:1:14 Кстати, уже не первый контекст, где нужен алгоритм пасфайндинга. Надо найти что эффективнее, а то я кучу времени потратил, пытаясь приладить волновой алгоритм. 
nick = sectoid time = 28 16:1:31 и не первый где пишем бота 
nick = sectoid time = 28 16:1:37 надо подтянуть тему AI 
nick = swizard time = 28 16:1:43 а вообще, конечно, в этот раз лисперам повезло с заданием 
nick = sectoid time = 28 16:1:51 угу. весьма 
nick = turtle time = 28 16:1:52 Да, прямо под лисперов. 
nick = turtle time = 28 16:2:1 Я даже не думал что настолько будет. 
nick = swizard time = 28 16:2:1 это такой класс писать аи на нормальном лиспе под слаймом :) 
nick = sectoid time = 28 16:2:2 хотя прошлый тоже под лисп был жырный 
nick = turtle time = 28 16:2:12 Я в прошлом не участвовал. 
nick = grepz time = 28 16:2:15 ну это ещё вопрос, хаскеллисты со своим выводом типов тоже могли хорошо развернуться 
nick = turtle time = 28 16:2:27 Прошлый был в августе и от майкрософта. :) 
nick = swizard time = 28 16:2:28 могли, но у них там полюбому DSL 
nick = sectoid time = 28 16:2:30 вывод типов тут помог бы мало 
nick = turtle time = 28 16:2:33 Узнал об этом в сентябре. :) 
nick = grepz time = 28 16:2:34 ну это конечно 
nick = sectoid time = 28 16:2:37 ибо тут проги мелкие 
nick = grepz time = 28 16:2:48 верификация автоматом 
nick = grepz time = 28 16:2:55 не тратится время на поиск косяков 
nick = sectoid time = 28 16:3:11 если бы я не тупил с тест-сьютом - тоже не тратилили бы 
nick = swizard time = 28 16:3:20 http://icfpcontest.org обновился 
nick = turtle time = 28 16:3:21 Ассемблер - это ад. :) 
nick = sectoid time = 28 16:3:24 а семантику тебе система типов не проверит, чай не зависимые типы 
nick = grepz time = 28 16:3:30 turtle, +1 
nick = grepz time = 28 16:3:56 sectoid, ну хотя бы транслирование в подязык простое и без накладок 
nick = swizard time = 28 16:4:4 но вы конечно герои на асме с 256 байт оперативки какой-то алгоритм внятный написать :) 
nick = sectoid time = 28 16:4:6 https://en.wikipedia.org/wiki/SECD_machine 
nick = sectoid time = 28 16:4:14 у ней оказывается даже название есть 
nick = turtle time = 28 16:4:21 Надо было какой-нибудь простейший транслятор написать. Подумал, что не уложимся. 
nick = grepz time = 28 16:5:25 почитаю на реддите потом сакцесс сториз 
nick = sectoid time = 28 16:5:37 как выспимся - надо будет отчет в поинтач сварганить 
nick = grepz time = 28 16:5:40 очень хочется посмотреть на пакмана который максимум набирает 
nick = sectoid time = 28 16:5:48 аналогично 
nick = sectoid time = 28 16:5:55 а не знаете, _adept_ играл? 
nick = turtle time = 28 16:5:57 Я сегодня не спал, кстати. :) 
nick = grepz time = 28 16:6:2 я тоже :) 
nick = swizard time = 28 16:6:8 собирался играть соло на окамле 
nick = sectoid time = 28 16:6:13 а 
nick = sectoid time = 28 16:6:15 точно 
nick = swizard time = 28 16:8:55 так а что народ 
nick = swizard time = 28 16:9:12 я правильно понимаю, что на ghostbusters в hall of fame на пятом месте — это мы? 
nick = grepz time = 28 16:9:22 да 
nick = swizard time = 28 16:9:32 воу  
nick = grepz time = 28 16:9:33 но мы всё равно сильно отстаёт от лидеров 
nick = swizard time = 28 16:9:55 да блин ещё бы часов 10-12, мы бы в тройку везде вошли точно 
nick = sectoid time = 28 16:9:56 ну хоть засветились) 
nick = swizard time = 28 16:10:1 в классике хотя бы 
nick = swizard time = 28 16:10:15 там просто надо стратегию подтюнить чуток, чтобы время по-максимуму потянуть 
nick = swizard time = 28 16:10:20 жрать гоустов и фрукты 
nick = swizard time = 28 16:10:29 а то мы слишком быстро уровень заканчиваем 
nick = turtle time = 28 16:10:35 Ну это да. 
nick = sectoid time = 28 16:10:51 ждать всех фруктов, жрать побольше гостов 
nick = turtle time = 28 16:10:53 Но ладно, что уж. 
nick = turtle time = 28 16:11:6 Гостов много не сожрёшь, поверпиллы ограниченные. 
nick = swizard time = 28 16:11:7 короче, я считаю, что в этот раз у нас был нехилый шанс в призёры войти =) 
nick = swizard time = 28 16:11:20 неизвестно, когда ещё раз такое будет 
nick = swizard time = 28 16:11:24 ну да ладно 
nick = turtle time = 28 16:11:28 Ну, может, этот раз будет ступенькой для следующего раза. :) 
nick = swizard time = 28 16:11:39 это само-собой =) 
nick = swizard time = 28 16:12:7 ща ещё ваши гоусты может жару зададут 
nick = swizard time = 28 16:12:20 нашего пакмана, по крайней мере, они хавают 
nick = swizard time = 28 16:12:53 репо будем открывать наружу? 
nick = grepz time = 28 16:13:1 https://github.com/MarcdeFalco/icfp14 окамловская реализация :) 
nick = sectoid time = 28 16:13:2 да, теперь мона открыть) 
nick = sectoid time = 28 16:13:11 ничего секретного у нас там нет) 
nick = turtle time = 28 16:13:19 Обязательно откроем. 
nick = grepz time = 28 16:13:40 судя по их коду, госты довольно простые, хотя и ребята не из топ скорборды 
nick = swizard time = 28 16:13:42 давайте 
nick = turtle time = 28 16:13:49 Вроде открыл. 
nick = turtle time = 28 16:14:29 Госты на 70 инструкций... :) 
nick = turtle time = 28 16:14:51 Да он у них одинаковый, вроде. 
nick = grepz time = 28 16:15:16 зато симулятор сделали 
nick = grepz time = 28 16:15:28 даже вроде графический 
nick = grepz time = 28 16:16:3 https://github.com/RafaelBocquet/icfp-contest-2014 to` 
nick = grepz time = 28 16:16:6 ещё 
nick = turtle time = 28 16:16:35 Никто не проверял, наша репа видна снаружи? 
nick = swizard time = 28 16:16:52 не знаю, но я уже на неё ссылку дал 
nick = turtle time = 28 16:17:38 Эти тоже с последней репы сделали просто более удодбный ассемблер. 
nick = grepz time = 28 16:17:47 угу 
nick = turtle time = 28 16:18:4 Да, вроде видна репа. 
nick = grepz time = 28 16:18:43 у них госты примерно по той же схеме действуют что и моя версия, преследуют имея небольшую информацию от окружающих объектах 
nick = turtle time = 28 16:19:18 Но ассемблер - ад. :) 
nick = grepz time = 28 16:19:22 :) 
nick = grepz time = 28 16:20:0 я тут спасибо жене многократно успел сказать, она на день варения мне доску с маркерами подарила, иначе в 6 утра я бы искалечил себе мозг окончательно 
nick = turtle time = 28 16:20:1 swizard: ты куда ссылку дал? 
nick = turtle time = 28 16:20:18 Я три листа блокнота исписал. :) 
nick = swizard time = 28 16:20:31 ICFP 2014 game over &lt;http://swizard.livejournal.com/191200.html&gt; 
nick = swizard time = 28 16:20:42  я вообще никуда ничего не записывал :) 
nick = grepz time = 28 16:20:55 монстр блин :) 
nick = swizard time = 28 16:20:59 хотя я ассемблером не занимался 
nick = swizard time = 28 16:21:6 а то бы пришлось наверняка 
nick = grepz time = 28 16:21:22 Score: 2630 Lives: 0 Ticks: 44473 в среднем где-то так против самых продвинутых гостов получается из доступных на классике 
nick = grepz time = 28 16:21:31 иногда чуть больше 
nick = swizard time = 28 16:21:53 а какие госты самые продвинутые? 
nick = grepz time = 28 16:22:9 момент 
nick = grepz time = 28 16:22:29 https://github.com/RafaelBocquet/icfp-contest-2014/blob/master/GH/v2/ghost1.hg.out вот к примеру 
nick = grepz time = 28 16:23:13 https://github.com/veged/icfpc2014 во, эти крутые 
nick = grepz time = 28 16:23:43 пакман у них по крайней мере в топы выходил 
nick = sectoid time = 28 16:23:44 154 инструкции госта 
nick = sectoid time = 28 16:24:41 https://github.com/veged/icfpc2014/blob/master/submission/code/lambdaman.js 
nick = swizard time = 28 16:25:3 мда я щас смотрю на этих гоустов и понимаю, что наш пакман слишком агрессивный 
nick = swizard time = 28 16:25:15 надо, конечно, было смотреть на время окончания таблетки 
nick = grepz time = 28 16:25:25 угу 
nick = grepz time = 28 16:25:35 он их жрать под самый конец действия таблетки пытается 
nick = swizard time = 28 16:25:47 а ты какого пакмана проверяешь кстати? 
nick = swizard time = 28 16:25:51 самого свежего? 
nick = swizard time = 28 16:26:9 просто против гоустов Рафаеля он выигрывает 
nick = grepz time = 28 16:26:24 оказывается нет, сейчас перезапущу с свежим 
nick = turtle time = 28 16:26:46 Ладно, я отойду. Потом прочитаю и чатлоги в репу запушу. Как говорится, information must be free. :) 
nick = turtle time = 28 16:26:53 Ещё раз всем больше спасибо за участие. 
nick = sectoid time = 28 16:26:58 взаимно) 
nick = swizard time = 28 16:27:2 счастливо :) 
nick = turtle time = 28 16:27:16 В следующем году жду всех в этом же составе. :) 
nick = grepz time = 28 16:27:22 большое спасибо, было очень интересно 
nick = sectoid time = 28 16:27:24 аще интересно, можно ли на 4 видах гостов каждый не более 256 инструкций сделать хайвмайнд?) 
nick = grepz time = 28 16:27:39 очень простой 
nick = swizard time = 28 16:27:48 а они же не могут общаться друг с другом  
nick = grepz time = 28 16:27:54 ограниченный ресурс взаимодействия между гостами 
nick = grepz time = 28 16:28:0 но отсекать некоторые решения можно 
nick = grepz time = 28 16:28:16 можно получать инфу о положении других гостов и пакмана 
nick = grepz time = 28 16:28:22 плюс знание местности 
nick = sectoid time = 28 16:28:22 и насколько этому поможет 128 байт _шареной_ памяти;) 
nick = grepz time = 28 16:28:57 выкрутиться можно, к примеру просто при выборе 2х путей выбирать тот который не покрывается гостом(нет госта в том направлении) 
nick = sectoid time = 28 16:29:8 гы 
nick = grepz time = 28 16:29:14 нормальный пасфиндинг не сделаешь, но на развилках можно сворачивать более разумно 
nick = sectoid time = 28 16:29:34 написав эмулятор игры на ILISP, можно было бы моделлировать состояние госта и предугадывать его следующий ход 
nick = sectoid time = 28 16:29:41 а я не додумался( 
nick = swizard time = 28 16:30:23 на самом деле пакман и так около cyclelimit ходит, вряд ли от эмуляции гоустов ему ещё полегчает :) 
nick = grepz time = 28 16:31:12 у меня сейчас регулярно выходит за cycle limit с последним пакманом 
nick = swizard time = 28 16:31:46 да, у меня вроде не было пока 
nick = swizard time = 28 16:32:6 но вообще есть подозрение, что это ещё от эмулятора js зависит 
nick = swizard time = 28 16:32:23 там как-то криво, то на пустом месте тормозит, то летает 
nick = grepz time = 28 16:32:32 есть такое 
nick = swizard time = 28 16:32:38 как они считают cyclelimit — непонятно 
nick = sectoid time = 28 16:32:41 ну и транслятор у нас туповат 
nick = swizard time = 28 16:32:52 во кстати 
nick = sectoid time = 28 16:32:55 есть подозрение что память можно было бы сэкономить, введя ряд оптимизаций 
nick = swizard time = 28 16:33:0 а tail call у нас поддержан? 
nick = sectoid time = 28 16:33:3 неа 
nick = swizard time = 28 16:33:8 упс :) 
nick = sectoid time = 28 16:33:30 написать TCO моя не успел( 
nick = swizard time = 28 16:33:36 а я там зачем-то старался всегда хвостовую рекурсию делать 
nick = swizard time = 28 16:33:46 можно было проще значит :) 
nick = grepz time = 28 16:33:50 я его начинал делать в субботу, но помоему так и не допилил, так как условия начинали с багами работать 
nick = sectoid time = 28 16:34:27 надо будет на досуге попробовать его таки туда вкорячить 
nick = sectoid time = 28 16:34:36 чисто для получения опыта 
nick = grepz time = 28 16:34:37 TRAP работал нормально, а на TAP почему то со стэком проблемы вылезали 
nick = sectoid time = 28 16:34:42 я никогда не писал TCO 
nick = sectoid time = 28 16:36:33 еще из положительного опыта (лично для меня): прогулки очень помогают. правильная работа со скопами была придумана за полчаса размышлений на киевском море) 
nick = sectoid time = 28 16:36:41 в полной темноте среди ночи) 
nick = grepz time = 28 16:37:10 ох ладно, пойду себя в человеческий вид приводить. Ещё раз спасибо ребята, новые вещи узнал, особенно что касается l-calculus'а, вообще раньше один сплошной пробел был, сейчас хоть что-то понимать начал 
nick = swizard time = 28 16:37:32 ага, счастливо! 
nick = grepz time = 28 16:37:50 удачи! 
nick = sectoid time = 28 16:37:53 удачи) 
nick = swizard time = 28 16:37:56 я кстати тоже ходил гулять в субботу, но не помогло :) 
nick = swizard time = 28 16:38:8 видимо, потому что было жарко, и с супругой =) 
nick = sectoid time = 28 16:38:19 а я соло, среди ночи, и на байке - на водохранилище 
nick = sectoid time = 28 16:38:28 но тут еще воздух, да-с. киев-то в лесу 
nick = sectoid time = 28 16:38:37 откатил 20км и ты в лесу 
nick = swizard time = 28 16:39:35 да, действительно, надо было мне тоже ночью, хотя бы прохладней было бы 
nick = swizard time = 28 16:39:49 ладно, пойду я тогда, пожалуй, поработаю, чтоли 
nick = swizard time = 28 16:39:53 для разнообразия 
nick = sectoid time = 28 16:40:11 давай 
nick = sectoid time = 28 16:40:14 а я пойду посплю 
nick = swizard time = 28 16:40:27 наконец-то можно, да =) 
nick = sectoid time = 28 16:42:57 отсюда наверное выйду. всем спасибо, если что - я есть в жабрах. sectoid@gnolltech.com 
nick = swizard time = 28 16:43:16 давай 
nick = swizard time = 28 16:43:24 я тоже пойду 
